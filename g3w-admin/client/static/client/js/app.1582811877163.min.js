(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (global){
"use strict";

require("core-js/shim");

require("regenerator-runtime/runtime");

require("core-js/fn/regexp/escape");

if (global._babelPolyfill) {
  throw new Error("only one instance of babel-polyfill is allowed");
}
global._babelPolyfill = true;

var DEFINE_PROPERTY = "defineProperty";
function define(O, key, value) {
  O[key] || Object[DEFINE_PROPERTY](O, key, {
    writable: true,
    configurable: true,
    value: value
  });
}

define(String.prototype, "padLeft", "".padStart);
define(String.prototype, "padRight", "".padEnd);

"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function (key) {
  [][key] && define(Array, key, Function.call.bind([][key]));
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"core-js/fn/regexp/escape":32,"core-js/shim":484,"regenerator-runtime/runtime":2}],2:[function(require,module,exports){
(function (global){
/**
 * Copyright (c) 2014, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * https://raw.github.com/facebook/regenerator/master/LICENSE file. An
 * additional grant of patent rights can be found in the PATENTS file in
 * the same directory.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    if (typeof global.process === "object" && global.process.domain) {
      invoke = global.process.domain.bind(invoke);
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // Among the various tricks for obtaining a reference to the global
  // object, this seems to be the most reliable technique that does not
  // use indirect eval (which violates Content Security Policy).
  typeof global === "object" ? global :
  typeof window === "object" ? window :
  typeof self === "object" ? self : this
);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/array/from"), __esModule: true };
},{"core-js/library/fn/array/from":33}],4:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/get-iterator"), __esModule: true };
},{"core-js/library/fn/get-iterator":34}],5:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/is-iterable"), __esModule: true };
},{"core-js/library/fn/is-iterable":35}],6:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/json/stringify"), __esModule: true };
},{"core-js/library/fn/json/stringify":36}],7:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-integer"), __esModule: true };
},{"core-js/library/fn/number/is-integer":37}],8:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-nan"), __esModule: true };
},{"core-js/library/fn/number/is-nan":38}],9:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/number/is-safe-integer"), __esModule: true };
},{"core-js/library/fn/number/is-safe-integer":39}],10:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/assign"), __esModule: true };
},{"core-js/library/fn/object/assign":40}],11:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/define-property"), __esModule: true };
},{"core-js/library/fn/object/define-property":41}],12:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/entries"), __esModule: true };
},{"core-js/library/fn/object/entries":42}],13:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/freeze"), __esModule: true };
},{"core-js/library/fn/object/freeze":43}],14:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/keys"), __esModule: true };
},{"core-js/library/fn/object/keys":44}],15:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/object/values"), __esModule: true };
},{"core-js/library/fn/object/values":45}],16:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/promise"), __esModule: true };
},{"core-js/library/fn/promise":46}],17:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/set"), __esModule: true };
},{"core-js/library/fn/set":47}],18:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol"), __esModule: true };
},{"core-js/library/fn/symbol":48}],19:[function(require,module,exports){
module.exports = { "default": require("core-js/library/fn/symbol/iterator"), __esModule: true };
},{"core-js/library/fn/symbol/iterator":49}],20:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _promise = require("../core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (fn) {
  return function () {
    var gen = fn.apply(this, arguments);
    return new _promise2.default(function (resolve, reject) {
      function step(key, arg) {
        try {
          var info = gen[key](arg);
          var value = info.value;
        } catch (error) {
          reject(error);
          return;
        }

        if (info.done) {
          resolve(value);
        } else {
          return _promise2.default.resolve(value).then(function (value) {
            step("next", value);
          }, function (err) {
            step("throw", err);
          });
        }
      }

      return step("next");
    });
  };
};
},{"../core-js/promise":16}],21:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _defineProperty = require("../core-js/object/define-property");

var _defineProperty2 = _interopRequireDefault(_defineProperty);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (obj, key, value) {
  if (key in obj) {
    (0, _defineProperty2.default)(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};
},{"../core-js/object/define-property":11}],22:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _assign = require("../core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = _assign2.default || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
},{"../core-js/object/assign":10}],23:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _isIterable2 = require("../core-js/is-iterable");

var _isIterable3 = _interopRequireDefault(_isIterable2);

var _getIterator2 = require("../core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = (0, _getIterator3.default)(arr), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if ((0, _isIterable3.default)(Object(arr))) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();
},{"../core-js/get-iterator":4,"../core-js/is-iterable":5}],24:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _from = require("../core-js/array/from");

var _from2 = _interopRequireDefault(_from);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  } else {
    return (0, _from2.default)(arr);
  }
};
},{"../core-js/array/from":3}],25:[function(require,module,exports){
"use strict";

exports.__esModule = true;

var _iterator = require("../core-js/symbol/iterator");

var _iterator2 = _interopRequireDefault(_iterator);

var _symbol = require("../core-js/symbol");

var _symbol2 = _interopRequireDefault(_symbol);

var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
} : function (obj) {
  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
};
},{"../core-js/symbol":18,"../core-js/symbol/iterator":19}],26:[function(require,module,exports){
module.exports = require("regenerator-runtime");

},{"regenerator-runtime":506}],27:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],28:[function(require,module,exports){

},{}],29:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var Buffer = require('buffer').Buffer;

var isBufferEncoding = Buffer.isEncoding
  || function(encoding) {
       switch (encoding && encoding.toLowerCase()) {
         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
         default: return false;
       }
     }


function assertEncoding(encoding) {
  if (encoding && !isBufferEncoding(encoding)) {
    throw new Error('Unknown encoding: ' + encoding);
  }
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters. CESU-8 is handled as part of the UTF-8 encoding.
//
// @TODO Handling all encodings inside a single object makes it very difficult
// to reason about this code, so it should be split up in the future.
// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
// points as used by CESU-8.
var StringDecoder = exports.StringDecoder = function(encoding) {
  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
  assertEncoding(encoding);
  switch (this.encoding) {
    case 'utf8':
      // CESU-8 represents each of Surrogate Pair by 3-bytes
      this.surrogateSize = 3;
      break;
    case 'ucs2':
    case 'utf16le':
      // UTF-16 represents each of Surrogate Pair by 2-bytes
      this.surrogateSize = 2;
      this.detectIncompleteChar = utf16DetectIncompleteChar;
      break;
    case 'base64':
      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
      this.surrogateSize = 3;
      this.detectIncompleteChar = base64DetectIncompleteChar;
      break;
    default:
      this.write = passThroughWrite;
      return;
  }

  // Enough space to store all bytes of a single character. UTF-8 needs 4
  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
  this.charBuffer = new Buffer(6);
  // Number of bytes received for the current incomplete multi-byte character.
  this.charReceived = 0;
  // Number of bytes expected for the current incomplete multi-byte character.
  this.charLength = 0;
};


// write decodes the given buffer and returns it as JS string that is
// guaranteed to not contain any partial multi-byte characters. Any partial
// character found at the end of the buffer is buffered up, and will be
// returned when calling write again with the remaining bytes.
//
// Note: Converting a Buffer containing an orphan surrogate to a String
// currently works, but converting a String to a Buffer (via `new Buffer`, or
// Buffer#write) will replace incomplete surrogates with the unicode
// replacement character. See https://codereview.chromium.org/121173009/ .
StringDecoder.prototype.write = function(buffer) {
  var charStr = '';
  // if our last write ended with an incomplete multibyte character
  while (this.charLength) {
    // determine how many remaining bytes this buffer has to offer for this char
    var available = (buffer.length >= this.charLength - this.charReceived) ?
        this.charLength - this.charReceived :
        buffer.length;

    // add the new bytes to the char buffer
    buffer.copy(this.charBuffer, this.charReceived, 0, available);
    this.charReceived += available;

    if (this.charReceived < this.charLength) {
      // still not enough chars in this buffer? wait for more ...
      return '';
    }

    // remove bytes belonging to the current character from the buffer
    buffer = buffer.slice(available, buffer.length);

    // get the character that was split
    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
    var charCode = charStr.charCodeAt(charStr.length - 1);
    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
      this.charLength += this.surrogateSize;
      charStr = '';
      continue;
    }
    this.charReceived = this.charLength = 0;

    // if there are no more bytes in this buffer, just emit our char
    if (buffer.length === 0) {
      return charStr;
    }
    break;
  }

  // determine and set charLength / charReceived
  this.detectIncompleteChar(buffer);

  var end = buffer.length;
  if (this.charLength) {
    // buffer the incomplete character bytes we got
    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
    end -= this.charReceived;
  }

  charStr += buffer.toString(this.encoding, 0, end);

  var end = charStr.length - 1;
  var charCode = charStr.charCodeAt(end);
  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
    var size = this.surrogateSize;
    this.charLength += size;
    this.charReceived += size;
    this.charBuffer.copy(this.charBuffer, size, 0, size);
    buffer.copy(this.charBuffer, 0, 0, size);
    return charStr.substring(0, end);
  }

  // or just emit the charStr
  return charStr;
};

// detectIncompleteChar determines if there is an incomplete UTF-8 character at
// the end of the given buffer. If so, it sets this.charLength to the byte
// length that character, and sets this.charReceived to the number of bytes
// that are available for this character.
StringDecoder.prototype.detectIncompleteChar = function(buffer) {
  // determine how many bytes we have to check at the end of this buffer
  var i = (buffer.length >= 3) ? 3 : buffer.length;

  // Figure out if one of the last i bytes of our buffer announces an
  // incomplete char.
  for (; i > 0; i--) {
    var c = buffer[buffer.length - i];

    // See http://en.wikipedia.org/wiki/UTF-8#Description

    // 110XXXXX
    if (i == 1 && c >> 5 == 0x06) {
      this.charLength = 2;
      break;
    }

    // 1110XXXX
    if (i <= 2 && c >> 4 == 0x0E) {
      this.charLength = 3;
      break;
    }

    // 11110XXX
    if (i <= 3 && c >> 3 == 0x1E) {
      this.charLength = 4;
      break;
    }
  }
  this.charReceived = i;
};

StringDecoder.prototype.end = function(buffer) {
  var res = '';
  if (buffer && buffer.length)
    res = this.write(buffer);

  if (this.charReceived) {
    var cr = this.charReceived;
    var buf = this.charBuffer;
    var enc = this.encoding;
    res += buf.slice(0, cr).toString(enc);
  }

  return res;
};

function passThroughWrite(buffer) {
  return buffer.toString(this.encoding);
}

function utf16DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 2;
  this.charLength = this.charReceived ? 2 : 0;
}

function base64DetectIncompleteChar(buffer) {
  this.charReceived = buffer.length % 3;
  this.charLength = this.charReceived ? 3 : 0;
}

},{"buffer":30}],30:[function(require,module,exports){
(function (global){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var isArray = require('isarray')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"base64-js":27,"ieee754":487,"isarray":31}],31:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],32:[function(require,module,exports){
require('../../modules/core.regexp.escape');
module.exports = require('../../modules/_core').RegExp.escape;

},{"../../modules/_core":182,"../../modules/core.regexp.escape":287}],33:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/es6.array.from');
module.exports = require('../../modules/_core').Array.from;

},{"../../modules/_core":64,"../../modules/es6.array.from":138,"../../modules/es6.string.iterator":150}],34:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.get-iterator');

},{"../modules/core.get-iterator":136,"../modules/es6.string.iterator":150,"../modules/web.dom.iterable":161}],35:[function(require,module,exports){
require('../modules/web.dom.iterable');
require('../modules/es6.string.iterator');
module.exports = require('../modules/core.is-iterable');

},{"../modules/core.is-iterable":137,"../modules/es6.string.iterator":150,"../modules/web.dom.iterable":161}],36:[function(require,module,exports){
var core = require('../../modules/_core');
var $JSON = core.JSON || (core.JSON = { stringify: JSON.stringify });
module.exports = function stringify(it) { // eslint-disable-line no-unused-vars
  return $JSON.stringify.apply($JSON, arguments);
};

},{"../../modules/_core":64}],37:[function(require,module,exports){
require('../../modules/es6.number.is-integer');
module.exports = require('../../modules/_core').Number.isInteger;

},{"../../modules/_core":64,"../../modules/es6.number.is-integer":140}],38:[function(require,module,exports){
require('../../modules/es6.number.is-nan');
module.exports = require('../../modules/_core').Number.isNaN;

},{"../../modules/_core":64,"../../modules/es6.number.is-nan":141}],39:[function(require,module,exports){
require('../../modules/es6.number.is-safe-integer');
module.exports = require('../../modules/_core').Number.isSafeInteger;

},{"../../modules/_core":64,"../../modules/es6.number.is-safe-integer":142}],40:[function(require,module,exports){
require('../../modules/es6.object.assign');
module.exports = require('../../modules/_core').Object.assign;

},{"../../modules/_core":64,"../../modules/es6.object.assign":143}],41:[function(require,module,exports){
require('../../modules/es6.object.define-property');
var $Object = require('../../modules/_core').Object;
module.exports = function defineProperty(it, key, desc) {
  return $Object.defineProperty(it, key, desc);
};

},{"../../modules/_core":64,"../../modules/es6.object.define-property":144}],42:[function(require,module,exports){
require('../../modules/es7.object.entries');
module.exports = require('../../modules/_core').Object.entries;

},{"../../modules/_core":64,"../../modules/es7.object.entries":152}],43:[function(require,module,exports){
require('../../modules/es6.object.freeze');
module.exports = require('../../modules/_core').Object.freeze;

},{"../../modules/_core":64,"../../modules/es6.object.freeze":145}],44:[function(require,module,exports){
require('../../modules/es6.object.keys');
module.exports = require('../../modules/_core').Object.keys;

},{"../../modules/_core":64,"../../modules/es6.object.keys":146}],45:[function(require,module,exports){
require('../../modules/es7.object.values');
module.exports = require('../../modules/_core').Object.values;

},{"../../modules/_core":64,"../../modules/es7.object.values":153}],46:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.promise');
require('../modules/es7.promise.finally');
require('../modules/es7.promise.try');
module.exports = require('../modules/_core').Promise;

},{"../modules/_core":64,"../modules/es6.object.to-string":147,"../modules/es6.promise":148,"../modules/es6.string.iterator":150,"../modules/es7.promise.finally":154,"../modules/es7.promise.try":155,"../modules/web.dom.iterable":161}],47:[function(require,module,exports){
require('../modules/es6.object.to-string');
require('../modules/es6.string.iterator');
require('../modules/web.dom.iterable');
require('../modules/es6.set');
require('../modules/es7.set.to-json');
require('../modules/es7.set.of');
require('../modules/es7.set.from');
module.exports = require('../modules/_core').Set;

},{"../modules/_core":64,"../modules/es6.object.to-string":147,"../modules/es6.set":149,"../modules/es6.string.iterator":150,"../modules/es7.set.from":156,"../modules/es7.set.of":157,"../modules/es7.set.to-json":158,"../modules/web.dom.iterable":161}],48:[function(require,module,exports){
require('../../modules/es6.symbol');
require('../../modules/es6.object.to-string');
require('../../modules/es7.symbol.async-iterator');
require('../../modules/es7.symbol.observable');
module.exports = require('../../modules/_core').Symbol;

},{"../../modules/_core":64,"../../modules/es6.object.to-string":147,"../../modules/es6.symbol":151,"../../modules/es7.symbol.async-iterator":159,"../../modules/es7.symbol.observable":160}],49:[function(require,module,exports){
require('../../modules/es6.string.iterator');
require('../../modules/web.dom.iterable');
module.exports = require('../../modules/_wks-ext').f('iterator');

},{"../../modules/_wks-ext":133,"../../modules/es6.string.iterator":150,"../../modules/web.dom.iterable":161}],50:[function(require,module,exports){
module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

},{}],51:[function(require,module,exports){
module.exports = function () { /* empty */ };

},{}],52:[function(require,module,exports){
module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {
    throw TypeError(name + ': incorrect invocation!');
  } return it;
};

},{}],53:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

},{"./_is-object":85}],54:[function(require,module,exports){
var forOf = require('./_for-of');

module.exports = function (iter, ITERATOR) {
  var result = [];
  forOf(iter, false, result.push, result, ITERATOR);
  return result;
};

},{"./_for-of":74}],55:[function(require,module,exports){
// false -> Array#indexOf
// true  -> Array#includes
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');
var toAbsoluteIndex = require('./_to-absolute-index');
module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {
      if (O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

},{"./_to-absolute-index":124,"./_to-iobject":126,"./_to-length":127}],56:[function(require,module,exports){
// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = require('./_ctx');
var IObject = require('./_iobject');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var asc = require('./_array-species-create');
module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      val = self[index];
      res = f(val, index, O);
      if (TYPE) {
        if (IS_MAP) result[index] = res;   // map
        else if (res) switch (TYPE) {
          case 3: return true;             // some
          case 5: return val;              // find
          case 6: return index;            // findIndex
          case 2: result.push(val);        // filter
        } else if (IS_EVERY) return false; // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

},{"./_array-species-create":58,"./_ctx":66,"./_iobject":81,"./_to-length":127,"./_to-object":128}],57:[function(require,module,exports){
var isObject = require('./_is-object');
var isArray = require('./_is-array');
var SPECIES = require('./_wks')('species');

module.exports = function (original) {
  var C;
  if (isArray(original)) {
    C = original.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return C === undefined ? Array : C;
};

},{"./_is-array":83,"./_is-object":85,"./_wks":134}],58:[function(require,module,exports){
// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = require('./_array-species-constructor');

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

},{"./_array-species-constructor":57}],59:[function(require,module,exports){
// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = require('./_cof');
var TAG = require('./_wks')('toStringTag');
// ES3 wrong here
var ARG = cof(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (e) { /* empty */ }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
    // builtinTag case
    : ARG ? cof(O)
    // ES3 arguments fallback
    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

},{"./_cof":60,"./_wks":134}],60:[function(require,module,exports){
var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

},{}],61:[function(require,module,exports){
'use strict';
var dP = require('./_object-dp').f;
var create = require('./_object-create');
var redefineAll = require('./_redefine-all');
var ctx = require('./_ctx');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var $iterDefine = require('./_iter-define');
var step = require('./_iter-step');
var setSpecies = require('./_set-species');
var DESCRIPTORS = require('./_descriptors');
var fastKey = require('./_meta').fastKey;
var validate = require('./_validate-collection');
var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function (that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index];
  // frozen object case
  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;         // collection type
      that._i = create(null); // index
      that._f = undefined;    // first entry
      that._l = undefined;    // last entry
      that[SIZE] = 0;         // size
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }
        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this);
          // revert to the last existing entry
          while (entry && entry.r) entry = entry.p;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function () {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var entry = getEntry(that, key);
    var prev, index;
    // change existing entry
    if (entry) {
      entry.v = value;
    // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true), // <- index
        k: key,                        // <- key
        v: value,                      // <- value
        p: prev = that._l,             // <- previous entry
        n: undefined,                  // <- next entry
        r: false                       // <- removed
      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++;
      // add to index
      if (index !== 'F') that._i[index] = entry;
    } return that;
  },
  getEntry: getEntry,
  setStrong: function (C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target
      this._k = kind;                     // kind
      this._l = undefined;                // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l;
      // revert to the last existing entry
      while (entry && entry.r) entry = entry.p;
      // get next entry
      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      }
      // return step by kind
      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(NAME);
  }
};

},{"./_an-instance":52,"./_ctx":66,"./_descriptors":68,"./_for-of":74,"./_iter-define":88,"./_iter-step":90,"./_meta":93,"./_object-create":97,"./_object-dp":98,"./_redefine-all":113,"./_set-species":117,"./_validate-collection":131}],62:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var classof = require('./_classof');
var from = require('./_array-from-iterable');
module.exports = function (NAME) {
  return function toJSON() {
    if (classof(this) != NAME) throw TypeError(NAME + "#toJSON isn't generic");
    return from(this);
  };
};

},{"./_array-from-iterable":54,"./_classof":59}],63:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var meta = require('./_meta');
var fails = require('./_fails');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var setToStringTag = require('./_set-to-string-tag');
var dP = require('./_object-dp').f;
var each = require('./_array-methods')(0);
var DESCRIPTORS = require('./_descriptors');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  if (!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    C = wrapper(function (target, iterable) {
      anInstance(target, C, NAME, '_c');
      target._c = new Base();
      if (iterable != undefined) forOf(iterable, IS_MAP, target[ADDER], target);
    });
    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','), function (KEY) {
      var IS_ADDER = KEY == 'add' || KEY == 'set';
      if (KEY in proto && !(IS_WEAK && KEY == 'clear')) hide(C.prototype, KEY, function (a, b) {
        anInstance(this, C, KEY);
        if (!IS_ADDER && IS_WEAK && !isObject(a)) return KEY == 'get' ? undefined : false;
        var result = this._c[KEY](a === 0 ? 0 : a, b);
        return IS_ADDER ? this : result;
      });
    });
    IS_WEAK || dP(C.prototype, 'size', {
      get: function () {
        return this._c.size;
      }
    });
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F, O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":52,"./_array-methods":56,"./_descriptors":68,"./_export":72,"./_fails":73,"./_for-of":74,"./_global":75,"./_hide":77,"./_is-object":85,"./_meta":93,"./_object-dp":98,"./_redefine-all":113,"./_set-to-string-tag":118}],64:[function(require,module,exports){
var core = module.exports = { version: '2.5.3' };
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

},{}],65:[function(require,module,exports){
'use strict';
var $defineProperty = require('./_object-dp');
var createDesc = require('./_property-desc');

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));
  else object[index] = value;
};

},{"./_object-dp":98,"./_property-desc":112}],66:[function(require,module,exports){
// optional / simple context binding
var aFunction = require('./_a-function');
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};

},{"./_a-function":50}],67:[function(require,module,exports){
// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

},{}],68:[function(require,module,exports){
// Thank's IE8 for his funny defineProperty
module.exports = !require('./_fails')(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_fails":73}],69:[function(require,module,exports){
var isObject = require('./_is-object');
var document = require('./_global').document;
// typeof document.createElement is 'object' in old IE
var is = isObject(document) && isObject(document.createElement);
module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

},{"./_global":75,"./_is-object":85}],70:[function(require,module,exports){
// IE 8- don't enum bug keys
module.exports = (
  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
).split(',');

},{}],71:[function(require,module,exports){
// all enumerable object keys, includes symbols
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;
  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;
    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);
  } return result;
};

},{"./_object-gops":103,"./_object-keys":106,"./_object-pie":107}],72:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var ctx = require('./_ctx');
var hide = require('./_hide');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && key in exports) continue;
    // export native or passed
    out = own ? target[key] : source[key];
    // prevent global pollution for namespaces
    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
    // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global)
    // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? (function (C) {
      var F = function (a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0: return new C();
            case 1: return new C(a);
            case 2: return new C(a, b);
          } return new C(a, b, c);
        } return C.apply(this, arguments);
      };
      F[PROTOTYPE] = C[PROTOTYPE];
      return F;
    // make static versions for prototype methods
    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out;
      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
};
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":64,"./_ctx":66,"./_global":75,"./_hide":77}],73:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

},{}],74:[function(require,module,exports){
var ctx = require('./_ctx');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var anObject = require('./_an-object');
var toLength = require('./_to-length');
var getIterFn = require('./core.get-iterator-method');
var BREAK = {};
var RETURN = {};
var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () { return iterable; } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!');
  // fast case for arrays with default iterator
  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};
exports.BREAK = BREAK;
exports.RETURN = RETURN;

},{"./_an-object":53,"./_ctx":66,"./_is-array-iter":82,"./_iter-call":86,"./_to-length":127,"./core.get-iterator-method":135}],75:[function(require,module,exports){
// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self
  // eslint-disable-next-line no-new-func
  : Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

},{}],76:[function(require,module,exports){
var hasOwnProperty = {}.hasOwnProperty;
module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

},{}],77:[function(require,module,exports){
var dP = require('./_object-dp');
var createDesc = require('./_property-desc');
module.exports = require('./_descriptors') ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

},{"./_descriptors":68,"./_object-dp":98,"./_property-desc":112}],78:[function(require,module,exports){
var document = require('./_global').document;
module.exports = document && document.documentElement;

},{"./_global":75}],79:[function(require,module,exports){
module.exports = !require('./_descriptors') && !require('./_fails')(function () {
  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;
});

},{"./_descriptors":68,"./_dom-create":69,"./_fails":73}],80:[function(require,module,exports){
// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;
  switch (args.length) {
    case 0: return un ? fn()
                      : fn.call(that);
    case 1: return un ? fn(args[0])
                      : fn.call(that, args[0]);
    case 2: return un ? fn(args[0], args[1])
                      : fn.call(that, args[0], args[1]);
    case 3: return un ? fn(args[0], args[1], args[2])
                      : fn.call(that, args[0], args[1], args[2]);
    case 4: return un ? fn(args[0], args[1], args[2], args[3])
                      : fn.call(that, args[0], args[1], args[2], args[3]);
  } return fn.apply(that, args);
};

},{}],81:[function(require,module,exports){
// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = require('./_cof');
// eslint-disable-next-line no-prototype-builtins
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

},{"./_cof":60}],82:[function(require,module,exports){
// check on default Array iterator
var Iterators = require('./_iterators');
var ITERATOR = require('./_wks')('iterator');
var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

},{"./_iterators":91,"./_wks":134}],83:[function(require,module,exports){
// 7.2.2 IsArray(argument)
var cof = require('./_cof');
module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

},{"./_cof":60}],84:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var isObject = require('./_is-object');
var floor = Math.floor;
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

},{"./_is-object":85}],85:[function(require,module,exports){
module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

},{}],86:[function(require,module,exports){
// call something on iterator step with safe closing on error
var anObject = require('./_an-object');
module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

},{"./_an-object":53}],87:[function(require,module,exports){
'use strict';
var create = require('./_object-create');
var descriptor = require('./_property-desc');
var setToStringTag = require('./_set-to-string-tag');
var IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
require('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });
  setToStringTag(Constructor, NAME + ' Iterator');
};

},{"./_hide":77,"./_object-create":97,"./_property-desc":112,"./_set-to-string-tag":118,"./_wks":134}],88:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var $export = require('./_export');
var redefine = require('./_redefine');
var hide = require('./_hide');
var has = require('./_has');
var Iterators = require('./_iterators');
var $iterCreate = require('./_iter-create');
var setToStringTag = require('./_set-to-string-tag');
var getPrototypeOf = require('./_object-gpo');
var ITERATOR = require('./_wks')('iterator');
var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`
var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function () { return this; };

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);
  var getMethod = function (kind) {
    if (!BUGGY && kind in proto) return proto[kind];
    switch (kind) {
      case KEYS: return function keys() { return new Constructor(this, kind); };
      case VALUES: return function values() { return new Constructor(this, kind); };
    } return function entries() { return new Constructor(this, kind); };
  };
  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = (!BUGGY && $native) || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype;
  // Fix native
  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));
    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true);
      // fix for some old engines
      if (!LIBRARY && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
    }
  }
  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;
    $default = function values() { return $native.call(this); };
  }
  // Define iterator
  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  }
  // Plug for library
  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;
  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }
  return methods;
};

},{"./_export":72,"./_has":76,"./_hide":77,"./_iter-create":87,"./_iterators":91,"./_library":92,"./_object-gpo":104,"./_redefine":114,"./_set-to-string-tag":118,"./_wks":134}],89:[function(require,module,exports){
var ITERATOR = require('./_wks')('iterator');
var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();
  riter['return'] = function () { SAFE_CLOSING = true; };
  // eslint-disable-next-line no-throw-literal
  Array.from(riter, function () { throw 2; });
} catch (e) { /* empty */ }

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;
  try {
    var arr = [7];
    var iter = arr[ITERATOR]();
    iter.next = function () { return { done: safe = true }; };
    arr[ITERATOR] = function () { return iter; };
    exec(arr);
  } catch (e) { /* empty */ }
  return safe;
};

},{"./_wks":134}],90:[function(require,module,exports){
module.exports = function (done, value) {
  return { value: value, done: !!done };
};

},{}],91:[function(require,module,exports){
module.exports = {};

},{}],92:[function(require,module,exports){
module.exports = true;

},{}],93:[function(require,module,exports){
var META = require('./_uid')('meta');
var isObject = require('./_is-object');
var has = require('./_has');
var setDesc = require('./_object-dp').f;
var id = 0;
var isExtensible = Object.isExtensible || function () {
  return true;
};
var FREEZE = !require('./_fails')(function () {
  return isExtensible(Object.preventExtensions({}));
});
var setMeta = function (it) {
  setDesc(it, META, { value: {
    i: 'O' + ++id, // object ID
    w: {}          // weak collections IDs
  } });
};
var fastKey = function (it, create) {
  // return primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMeta(it);
  // return object ID
  } return it[META].i;
};
var getWeak = function (it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMeta(it);
  // return hash weak collections IDs
  } return it[META].w;
};
// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};
var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

},{"./_fails":73,"./_has":76,"./_is-object":85,"./_object-dp":98,"./_uid":130}],94:[function(require,module,exports){
var global = require('./_global');
var macrotask = require('./_task').set;
var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = require('./_cof')(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function () {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (e) {
        if (head) notify();
        else last = undefined;
        throw e;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (isNode) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339
  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    var promise = Promise.resolve();
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = { fn: fn, next: undefined };
    if (last) last.next = task;
    if (!head) {
      head = task;
      notify();
    } last = task;
  };
};

},{"./_cof":60,"./_global":75,"./_task":123}],95:[function(require,module,exports){
'use strict';
// 25.4.1.5 NewPromiseCapability(C)
var aFunction = require('./_a-function');

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

},{"./_a-function":50}],96:[function(require,module,exports){
'use strict';
// 19.1.2.1 Object.assign(target, source, ...)
var getKeys = require('./_object-keys');
var gOPS = require('./_object-gops');
var pIE = require('./_object-pie');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var $assign = Object.assign;

// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !$assign || require('./_fails')(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) { B[k] = k; });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;
  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];
  } return T;
} : $assign;

},{"./_fails":73,"./_iobject":81,"./_object-gops":103,"./_object-keys":106,"./_object-pie":107,"./_to-object":128}],97:[function(require,module,exports){
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = require('./_an-object');
var dPs = require('./_object-dps');
var enumBugKeys = require('./_enum-bug-keys');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var Empty = function () { /* empty */ };
var PROTOTYPE = 'prototype';

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = require('./_dom-create')('iframe');
  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';
  require('./_html').appendChild(iframe);
  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];
  return createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : dPs(result, Properties);
};

},{"./_an-object":53,"./_dom-create":69,"./_enum-bug-keys":70,"./_html":78,"./_object-dps":99,"./_shared-key":119}],98:[function(require,module,exports){
var anObject = require('./_an-object');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var toPrimitive = require('./_to-primitive');
var dP = Object.defineProperty;

exports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_ie8-dom-define":79,"./_to-primitive":129}],99:[function(require,module,exports){
var dP = require('./_object-dp');
var anObject = require('./_an-object');
var getKeys = require('./_object-keys');

module.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;
  while (length > i) dP.f(O, P = keys[i++], Properties[P]);
  return O;
};

},{"./_an-object":53,"./_descriptors":68,"./_object-dp":98,"./_object-keys":106}],100:[function(require,module,exports){
var pIE = require('./_object-pie');
var createDesc = require('./_property-desc');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var has = require('./_has');
var IE8_DOM_DEFINE = require('./_ie8-dom-define');
var gOPD = Object.getOwnPropertyDescriptor;

exports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) { /* empty */ }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

},{"./_descriptors":68,"./_has":76,"./_ie8-dom-define":79,"./_object-pie":107,"./_property-desc":112,"./_to-iobject":126,"./_to-primitive":129}],101:[function(require,module,exports){
// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = require('./_to-iobject');
var gOPN = require('./_object-gopn').f;
var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

},{"./_object-gopn":102,"./_to-iobject":126}],102:[function(require,module,exports){
// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = require('./_object-keys-internal');
var hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":105}],103:[function(require,module,exports){
exports.f = Object.getOwnPropertySymbols;

},{}],104:[function(require,module,exports){
// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = require('./_has');
var toObject = require('./_to-object');
var IE_PROTO = require('./_shared-key')('IE_PROTO');
var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectProto : null;
};

},{"./_has":76,"./_shared-key":119,"./_to-object":128}],105:[function(require,module,exports){
var has = require('./_has');
var toIObject = require('./_to-iobject');
var arrayIndexOf = require('./_array-includes')(false);
var IE_PROTO = require('./_shared-key')('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~arrayIndexOf(result, key) || result.push(key);
  }
  return result;
};

},{"./_array-includes":55,"./_has":76,"./_shared-key":119,"./_to-iobject":126}],106:[function(require,module,exports){
// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = require('./_object-keys-internal');
var enumBugKeys = require('./_enum-bug-keys');

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

},{"./_enum-bug-keys":70,"./_object-keys-internal":105}],107:[function(require,module,exports){
exports.f = {}.propertyIsEnumerable;

},{}],108:[function(require,module,exports){
// most Object methods by ES6 should accept primitives
var $export = require('./_export');
var core = require('./_core');
var fails = require('./_fails');
module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);
};

},{"./_core":64,"./_export":72,"./_fails":73}],109:[function(require,module,exports){
var getKeys = require('./_object-keys');
var toIObject = require('./_to-iobject');
var isEnum = require('./_object-pie').f;
module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) if (isEnum.call(O, key = keys[i++])) {
      result.push(isEntries ? [key, O[key]] : O[key]);
    } return result;
  };
};

},{"./_object-keys":106,"./_object-pie":107,"./_to-iobject":126}],110:[function(require,module,exports){
module.exports = function (exec) {
  try {
    return { e: false, v: exec() };
  } catch (e) {
    return { e: true, v: e };
  }
};

},{}],111:[function(require,module,exports){
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var newPromiseCapability = require('./_new-promise-capability');

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

},{"./_an-object":53,"./_is-object":85,"./_new-promise-capability":95}],112:[function(require,module,exports){
module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

},{}],113:[function(require,module,exports){
var hide = require('./_hide');
module.exports = function (target, src, safe) {
  for (var key in src) {
    if (safe && target[key]) target[key] = src[key];
    else hide(target, key, src[key]);
  } return target;
};

},{"./_hide":77}],114:[function(require,module,exports){
module.exports = require('./_hide');

},{"./_hide":77}],115:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');
var aFunction = require('./_a-function');
var ctx = require('./_ctx');
var forOf = require('./_for-of');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { from: function from(source /* , mapFn, thisArg */) {
    var mapFn = arguments[1];
    var mapping, A, n, cb;
    aFunction(this);
    mapping = mapFn !== undefined;
    if (mapping) aFunction(mapFn);
    if (source == undefined) return new this();
    A = [];
    if (mapping) {
      n = 0;
      cb = ctx(mapFn, arguments[2], 2);
      forOf(source, false, function (nextItem) {
        A.push(cb(nextItem, n++));
      });
    } else {
      forOf(source, false, A.push, A);
    }
    return new this(A);
  } });
};

},{"./_a-function":50,"./_ctx":66,"./_export":72,"./_for-of":74}],116:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-setmap-offrom/
var $export = require('./_export');

module.exports = function (COLLECTION) {
  $export($export.S, COLLECTION, { of: function of() {
    var length = arguments.length;
    var A = new Array(length);
    while (length--) A[length] = arguments[length];
    return new this(A);
  } });
};

},{"./_export":72}],117:[function(require,module,exports){
'use strict';
var global = require('./_global');
var core = require('./_core');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_core":64,"./_descriptors":68,"./_global":75,"./_object-dp":98,"./_wks":134}],118:[function(require,module,exports){
var def = require('./_object-dp').f;
var has = require('./_has');
var TAG = require('./_wks')('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });
};

},{"./_has":76,"./_object-dp":98,"./_wks":134}],119:[function(require,module,exports){
var shared = require('./_shared')('keys');
var uid = require('./_uid');
module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

},{"./_shared":120,"./_uid":130}],120:[function(require,module,exports){
var global = require('./_global');
var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
module.exports = function (key) {
  return store[key] || (store[key] = {});
};

},{"./_global":75}],121:[function(require,module,exports){
// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var SPECIES = require('./_wks')('species');
module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

},{"./_a-function":50,"./_an-object":53,"./_wks":134}],122:[function(require,module,exports){
var toInteger = require('./_to-integer');
var defined = require('./_defined');
// true  -> String#at
// false -> String#codePointAt
module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
      ? TO_STRING ? s.charAt(i) : a
      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

},{"./_defined":67,"./_to-integer":125}],123:[function(require,module,exports){
var ctx = require('./_ctx');
var invoke = require('./_invoke');
var html = require('./_html');
var cel = require('./_dom-create');
var global = require('./_global');
var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;
var run = function () {
  var id = +this;
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};
var listener = function (event) {
  run.call(event.data);
};
// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };
    defer(counter);
    return counter;
  };
  clearTask = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (require('./_cof')(process) == 'process') {
    defer = function (id) {
      process.nextTick(ctx(run, id, 1));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(ctx(run, id, 1));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function (id) {
      global.postMessage(id + '', '*');
    };
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function (id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}
module.exports = {
  set: setTask,
  clear: clearTask
};

},{"./_cof":60,"./_ctx":66,"./_dom-create":69,"./_global":75,"./_html":78,"./_invoke":80}],124:[function(require,module,exports){
var toInteger = require('./_to-integer');
var max = Math.max;
var min = Math.min;
module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

},{"./_to-integer":125}],125:[function(require,module,exports){
// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;
module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

},{}],126:[function(require,module,exports){
// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = require('./_iobject');
var defined = require('./_defined');
module.exports = function (it) {
  return IObject(defined(it));
};

},{"./_defined":67,"./_iobject":81}],127:[function(require,module,exports){
// 7.1.15 ToLength
var toInteger = require('./_to-integer');
var min = Math.min;
module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

},{"./_to-integer":125}],128:[function(require,module,exports){
// 7.1.13 ToObject(argument)
var defined = require('./_defined');
module.exports = function (it) {
  return Object(defined(it));
};

},{"./_defined":67}],129:[function(require,module,exports){
// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = require('./_is-object');
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

},{"./_is-object":85}],130:[function(require,module,exports){
var id = 0;
var px = Math.random();
module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

},{}],131:[function(require,module,exports){
var isObject = require('./_is-object');
module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

},{"./_is-object":85}],132:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var LIBRARY = require('./_library');
var wksExt = require('./_wks-ext');
var defineProperty = require('./_object-dp').f;
module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });
};

},{"./_core":64,"./_global":75,"./_library":92,"./_object-dp":98,"./_wks-ext":133}],133:[function(require,module,exports){
exports.f = require('./_wks');

},{"./_wks":134}],134:[function(require,module,exports){
var store = require('./_shared')('wks');
var uid = require('./_uid');
var Symbol = require('./_global').Symbol;
var USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

},{"./_global":75,"./_shared":120,"./_uid":130}],135:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};

},{"./_classof":59,"./_core":64,"./_iterators":91,"./_wks":134}],136:[function(require,module,exports){
var anObject = require('./_an-object');
var get = require('./core.get-iterator-method');
module.exports = require('./_core').getIterator = function (it) {
  var iterFn = get(it);
  if (typeof iterFn != 'function') throw TypeError(it + ' is not iterable!');
  return anObject(iterFn.call(it));
};

},{"./_an-object":53,"./_core":64,"./core.get-iterator-method":135}],137:[function(require,module,exports){
var classof = require('./_classof');
var ITERATOR = require('./_wks')('iterator');
var Iterators = require('./_iterators');
module.exports = require('./_core').isIterable = function (it) {
  var O = Object(it);
  return O[ITERATOR] !== undefined
    || '@@iterator' in O
    // eslint-disable-next-line no-prototype-builtins
    || Iterators.hasOwnProperty(classof(O));
};

},{"./_classof":59,"./_core":64,"./_iterators":91,"./_wks":134}],138:[function(require,module,exports){
'use strict';
var ctx = require('./_ctx');
var $export = require('./_export');
var toObject = require('./_to-object');
var call = require('./_iter-call');
var isArrayIter = require('./_is-array-iter');
var toLength = require('./_to-length');
var createProperty = require('./_create-property');
var getIterFn = require('./core.get-iterator-method');

$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
    // if object isn't iterable or it's array with default iterator - use simple case
    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);
      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }
    result.length = index;
    return result;
  }
});

},{"./_create-property":65,"./_ctx":66,"./_export":72,"./_is-array-iter":82,"./_iter-call":86,"./_iter-detect":89,"./_to-length":127,"./_to-object":128,"./core.get-iterator-method":135}],139:[function(require,module,exports){
'use strict';
var addToUnscopables = require('./_add-to-unscopables');
var step = require('./_iter-step');
var Iterators = require('./_iterators');
var toIObject = require('./_to-iobject');

// 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()
module.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target
  this._i = 0;                   // next index
  this._k = kind;                // kind
// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;
  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }
  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
Iterators.Arguments = Iterators.Array;

addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

},{"./_add-to-unscopables":51,"./_iter-define":88,"./_iter-step":90,"./_iterators":91,"./_to-iobject":126}],140:[function(require,module,exports){
// 20.1.2.3 Number.isInteger(number)
var $export = require('./_export');

$export($export.S, 'Number', { isInteger: require('./_is-integer') });

},{"./_export":72,"./_is-integer":84}],141:[function(require,module,exports){
// 20.1.2.4 Number.isNaN(number)
var $export = require('./_export');

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

},{"./_export":72}],142:[function(require,module,exports){
// 20.1.2.5 Number.isSafeInteger(number)
var $export = require('./_export');
var isInteger = require('./_is-integer');
var abs = Math.abs;

$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

},{"./_export":72,"./_is-integer":84}],143:[function(require,module,exports){
// 19.1.3.1 Object.assign(target, source)
var $export = require('./_export');

$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });

},{"./_export":72,"./_object-assign":96}],144:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });

},{"./_descriptors":68,"./_export":72,"./_object-dp":98}],145:[function(require,module,exports){
// 19.1.2.5 Object.freeze(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

},{"./_is-object":85,"./_meta":93,"./_object-sap":108}],146:[function(require,module,exports){
// 19.1.2.14 Object.keys(O)
var toObject = require('./_to-object');
var $keys = require('./_object-keys');

require('./_object-sap')('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

},{"./_object-keys":106,"./_object-sap":108,"./_to-object":128}],147:[function(require,module,exports){
arguments[4][28][0].apply(exports,arguments)
},{"dup":28}],148:[function(require,module,exports){
'use strict';
var LIBRARY = require('./_library');
var global = require('./_global');
var ctx = require('./_ctx');
var classof = require('./_classof');
var $export = require('./_export');
var isObject = require('./_is-object');
var aFunction = require('./_a-function');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var speciesConstructor = require('./_species-constructor');
var task = require('./_task').set;
var microtask = require('./_microtask')();
var newPromiseCapabilityModule = require('./_new-promise-capability');
var perform = require('./_perform');
var promiseResolve = require('./_promise-resolve');
var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';
var empty = function () { /* empty */ };
var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;

var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);
    var FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function (exec) {
      exec(empty, empty);
    };
    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
  } catch (e) { /* empty */ }
}();

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};
var notify = function (promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;
    var run = function (reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then;
      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value);
            if (domain) domain.exit();
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        reject(e);
      }
    };
    while (chain.length > i) run(chain[i++]); // variable length - can't use forEach
    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};
var onUnhandled = function (promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;
    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({ promise: promise, reason: value });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    } promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};
var isUnhandled = function (promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};
var onHandleUnhandled = function (promise) {
  task.call(global, function () {
    var handler;
    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({ promise: promise, reason: promise._v });
    }
  });
};
var $reject = function (value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};
var $resolve = function (value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = { _w: promise, _d: false }; // wrap
        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({ _w: promise, _d: false }, e); // wrap
  }
};

// constructor polyfill
if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);
    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    this._c = [];             // <- awaiting reactions
    this._a = undefined;      // <- checked in isUnhandled reactions
    this._s = 0;              // <- state
    this._d = false;          // <- done
    this._v = undefined;      // <- value
    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
    this._n = false;          // <- notify
  };
  Internal.prototype = require('./_redefine-all')($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;
      this._c.push(reaction);
      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === $Promise || C === Wrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Promise: $Promise });
require('./_set-to-string-tag')($Promise, PROMISE);
require('./_set-species')(PROMISE);
Wrapper = require('./_core')[PROMISE];

// statics
$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

},{"./_a-function":50,"./_an-instance":52,"./_classof":59,"./_core":64,"./_ctx":66,"./_export":72,"./_for-of":74,"./_global":75,"./_is-object":85,"./_iter-detect":89,"./_library":92,"./_microtask":94,"./_new-promise-capability":95,"./_perform":110,"./_promise-resolve":111,"./_redefine-all":113,"./_set-species":117,"./_set-to-string-tag":118,"./_species-constructor":121,"./_task":123,"./_wks":134}],149:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var SET = 'Set';

// 23.2 Set Objects
module.exports = require('./_collection')(SET, function (get) {
  return function Set() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

},{"./_collection":63,"./_collection-strong":61,"./_validate-collection":131}],150:[function(require,module,exports){
'use strict';
var $at = require('./_string-at')(true);

// 21.1.3.27 String.prototype[@@iterator]()
require('./_iter-define')(String, 'String', function (iterated) {
  this._t = String(iterated); // target
  this._i = 0;                // next index
// 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return { value: undefined, done: true };
  point = $at(O, index);
  this._i += point.length;
  return { value: point, done: false };
});

},{"./_iter-define":88,"./_string-at":122}],151:[function(require,module,exports){
'use strict';
// ECMAScript 6 symbols shim
var global = require('./_global');
var has = require('./_has');
var DESCRIPTORS = require('./_descriptors');
var $export = require('./_export');
var redefine = require('./_redefine');
var META = require('./_meta').KEY;
var $fails = require('./_fails');
var shared = require('./_shared');
var setToStringTag = require('./_set-to-string-tag');
var uid = require('./_uid');
var wks = require('./_wks');
var wksExt = require('./_wks-ext');
var wksDefine = require('./_wks-define');
var enumKeys = require('./_enum-keys');
var isArray = require('./_is-array');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var toIObject = require('./_to-iobject');
var toPrimitive = require('./_to-primitive');
var createDesc = require('./_property-desc');
var _create = require('./_object-create');
var gOPNExt = require('./_object-gopn-ext');
var $GOPD = require('./_object-gopd');
var $DP = require('./_object-dp');
var $keys = require('./_object-keys');
var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;
var _stringify = $JSON && $JSON.stringify;
var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function';
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function () { return dP(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function (tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);
  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, { enumerable: createDesc(0, false) });
    } return setSymbolDesc(it, key, D);
  } return dP(it, key, D);
};
var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;
  while (l > i) $defineProperty(it, key = keys[i++], P[key]);
  return it;
};
var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};
var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};
var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};
var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  } return result;
};
var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;
  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  } return result;
};

// 19.4.1.1 Symbol([description])
if (!USE_NATIVE) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
    var $set = function (value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };
    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });
    return wrap(tag);
  };
  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });

  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;
  require('./_object-pie').f = $propertyIsEnumerable;
  require('./_object-gops').f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !require('./_library')) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });

for (var es6Symbols = (
  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function (key) {
    return has(SymbolRegistry, key += '')
      ? SymbolRegistry[key]
      : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');
    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;
  },
  useSetter: function () { setter = true; },
  useSimple: function () { setter = false; }
});

$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// 24.3.2 JSON.stringify(value [, replacer [, space]])
$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols
  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;
    while (arguments.length > i) args.push(arguments[i++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
});

// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// 19.4.3.5 Symbol.prototype[@@toStringTag]
setToStringTag($Symbol, 'Symbol');
// 20.2.1.9 Math[@@toStringTag]
setToStringTag(Math, 'Math', true);
// 24.3.3 JSON[@@toStringTag]
setToStringTag(global.JSON, 'JSON', true);

},{"./_an-object":53,"./_descriptors":68,"./_enum-keys":71,"./_export":72,"./_fails":73,"./_global":75,"./_has":76,"./_hide":77,"./_is-array":83,"./_is-object":85,"./_library":92,"./_meta":93,"./_object-create":97,"./_object-dp":98,"./_object-gopd":100,"./_object-gopn":102,"./_object-gopn-ext":101,"./_object-gops":103,"./_object-keys":106,"./_object-pie":107,"./_property-desc":112,"./_redefine":114,"./_set-to-string-tag":118,"./_shared":120,"./_to-iobject":126,"./_to-primitive":129,"./_uid":130,"./_wks":134,"./_wks-define":132,"./_wks-ext":133}],152:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $entries = require('./_object-to-array')(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

},{"./_export":72,"./_object-to-array":109}],153:[function(require,module,exports){
// https://github.com/tc39/proposal-object-values-entries
var $export = require('./_export');
var $values = require('./_object-to-array')(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

},{"./_export":72,"./_object-to-array":109}],154:[function(require,module,exports){
// https://github.com/tc39/proposal-promise-finally
'use strict';
var $export = require('./_export');
var core = require('./_core');
var global = require('./_global');
var speciesConstructor = require('./_species-constructor');
var promiseResolve = require('./_promise-resolve');

$export($export.P + $export.R, 'Promise', { 'finally': function (onFinally) {
  var C = speciesConstructor(this, core.Promise || global.Promise);
  var isFunction = typeof onFinally == 'function';
  return this.then(
    isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () { return x; });
    } : onFinally,
    isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () { throw e; });
    } : onFinally
  );
} });

},{"./_core":64,"./_export":72,"./_global":75,"./_promise-resolve":111,"./_species-constructor":121}],155:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-promise-try
var $export = require('./_export');
var newPromiseCapability = require('./_new-promise-capability');
var perform = require('./_perform');

$export($export.S, 'Promise', { 'try': function (callbackfn) {
  var promiseCapability = newPromiseCapability.f(this);
  var result = perform(callbackfn);
  (result.e ? promiseCapability.reject : promiseCapability.resolve)(result.v);
  return promiseCapability.promise;
} });

},{"./_export":72,"./_new-promise-capability":95,"./_perform":110}],156:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.from
require('./_set-collection-from')('Set');

},{"./_set-collection-from":115}],157:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-set.of
require('./_set-collection-of')('Set');

},{"./_set-collection-of":116}],158:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Set', { toJSON: require('./_collection-to-json')('Set') });

},{"./_collection-to-json":62,"./_export":72}],159:[function(require,module,exports){
require('./_wks-define')('asyncIterator');

},{"./_wks-define":132}],160:[function(require,module,exports){
require('./_wks-define')('observable');

},{"./_wks-define":132}],161:[function(require,module,exports){
require('./es6.array.iterator');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var TO_STRING_TAG = require('./_wks')('toStringTag');

var DOMIterables = ('CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,' +
  'DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,' +
  'MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,' +
  'SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,' +
  'TextTrackList,TouchList').split(',');

for (var i = 0; i < DOMIterables.length; i++) {
  var NAME = DOMIterables[i];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  if (proto && !proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
  Iterators[NAME] = Iterators.Array;
}

},{"./_global":75,"./_hide":77,"./_iterators":91,"./_wks":134,"./es6.array.iterator":139}],162:[function(require,module,exports){
arguments[4][50][0].apply(exports,arguments)
},{"dup":50}],163:[function(require,module,exports){
var cof = require('./_cof');
module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

},{"./_cof":177}],164:[function(require,module,exports){
// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = require('./_wks')('unscopables');
var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});
module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

},{"./_hide":201,"./_wks":285}],165:[function(require,module,exports){
arguments[4][52][0].apply(exports,arguments)
},{"dup":52}],166:[function(require,module,exports){
arguments[4][53][0].apply(exports,arguments)
},{"./_is-object":210,"dup":53}],167:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');

module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};

},{"./_to-absolute-index":270,"./_to-length":274,"./_to-object":275}],168:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
'use strict';
var toObject = require('./_to-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};

},{"./_to-absolute-index":270,"./_to-length":274,"./_to-object":275}],169:[function(require,module,exports){
arguments[4][54][0].apply(exports,arguments)
},{"./_for-of":198,"dup":54}],170:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"./_to-absolute-index":270,"./_to-iobject":273,"./_to-length":274,"dup":55}],171:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"./_array-species-create":174,"./_ctx":184,"./_iobject":206,"./_to-length":274,"./_to-object":275,"dup":56}],172:[function(require,module,exports){
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var IObject = require('./_iobject');
var toLength = require('./_to-length');

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }
    index += i;
    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }
  for (;isRight ? index >= 0 : length > index; index += i) if (index in self) {
    memo = callbackfn(memo, self[index], index, O);
  }
  return memo;
};

},{"./_a-function":162,"./_iobject":206,"./_to-length":274,"./_to-object":275}],173:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./_is-array":208,"./_is-object":210,"./_wks":285,"dup":57}],174:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"./_array-species-constructor":173,"dup":58}],175:[function(require,module,exports){
'use strict';
var aFunction = require('./_a-function');
var isObject = require('./_is-object');
var invoke = require('./_invoke');
var arraySlice = [].slice;
var factories = {};

var construct = function (F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) n[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  } return factories[len](F, args);
};

module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);
  var bound = function (/* args... */) {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };
  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

},{"./_a-function":162,"./_invoke":205,"./_is-object":210}],176:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"./_cof":177,"./_wks":285,"dup":59}],177:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"dup":60}],178:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"./_an-instance":165,"./_ctx":184,"./_descriptors":188,"./_for-of":198,"./_iter-define":214,"./_iter-step":216,"./_meta":224,"./_object-create":229,"./_object-dp":230,"./_redefine-all":249,"./_set-species":256,"./_validate-collection":282,"dup":61}],179:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"./_array-from-iterable":169,"./_classof":176,"dup":62}],180:[function(require,module,exports){
'use strict';
var redefineAll = require('./_redefine-all');
var getWeak = require('./_meta').getWeak;
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var anInstance = require('./_an-instance');
var forOf = require('./_for-of');
var createArrayMethod = require('./_array-methods');
var $has = require('./_has');
var validate = require('./_validate-collection');
var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};
var UncaughtFrozenStore = function () {
  this.a = [];
};
var findUncaughtFrozen = function (store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};
UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.a.push([key, value]);
  },
  'delete': function (key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME;      // collection type
      that._i = id++;      // collection id
      that._l = undefined; // leak store for uncaught frozen objects
      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function (that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);
    else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

},{"./_an-instance":165,"./_an-object":166,"./_array-methods":171,"./_for-of":198,"./_has":200,"./_is-object":210,"./_meta":224,"./_redefine-all":249,"./_validate-collection":282}],181:[function(require,module,exports){
'use strict';
var global = require('./_global');
var $export = require('./_export');
var redefine = require('./_redefine');
var redefineAll = require('./_redefine-all');
var meta = require('./_meta');
var forOf = require('./_for-of');
var anInstance = require('./_an-instance');
var isObject = require('./_is-object');
var fails = require('./_fails');
var $iterDetect = require('./_iter-detect');
var setToStringTag = require('./_set-to-string-tag');
var inheritIfRequired = require('./_inherit-if-required');

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};
  var fixMethod = function (KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY,
      KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
      } : KEY == 'add' ? function add(a) { fn.call(this, a === 0 ? 0 : a); return this; }
        : function set(a, b) { fn.call(this, a === 0 ? 0 : a, b); return this; }
    );
  };
  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    var ACCEPT_ITERABLES = $iterDetect(function (iter) { new C(iter); }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });
    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }
    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }
    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);
    // weak collections should not contains .clear method
    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);

  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);

  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);

  return C;
};

},{"./_an-instance":165,"./_export":192,"./_fails":194,"./_for-of":198,"./_global":199,"./_inherit-if-required":204,"./_is-object":210,"./_iter-detect":215,"./_meta":224,"./_redefine":250,"./_redefine-all":249,"./_set-to-string-tag":257}],182:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"dup":64}],183:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"./_object-dp":230,"./_property-desc":248,"dup":65}],184:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"./_a-function":162,"dup":66}],185:[function(require,module,exports){
'use strict';
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var fails = require('./_fails');
var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function (num) {
  return num > 9 ? num : '0' + num;
};

// PhantomJS / old WebKit has a broken implementations
module.exports = (fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) +
    '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) +
    'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) +
    ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

},{"./_fails":194}],186:[function(require,module,exports){
'use strict';
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');
var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

},{"./_an-object":166,"./_to-primitive":276}],187:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"dup":67}],188:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"./_fails":194,"dup":68}],189:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./_global":199,"./_is-object":210,"dup":69}],190:[function(require,module,exports){
arguments[4][70][0].apply(exports,arguments)
},{"dup":70}],191:[function(require,module,exports){
arguments[4][71][0].apply(exports,arguments)
},{"./_object-gops":236,"./_object-keys":239,"./_object-pie":240,"dup":71}],192:[function(require,module,exports){
var global = require('./_global');
var core = require('./_core');
var hide = require('./_hide');
var redefine = require('./_redefine');
var ctx = require('./_ctx');
var PROTOTYPE = 'prototype';

var $export = function (type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;
  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if (target) redefine(target, key, out, type & $export.U);
    // export
    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library`
module.exports = $export;

},{"./_core":182,"./_ctx":184,"./_global":199,"./_hide":201,"./_redefine":250}],193:[function(require,module,exports){
var MATCH = require('./_wks')('match');
module.exports = function (KEY) {
  var re = /./;
  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) { /* empty */ }
  } return true;
};

},{"./_wks":285}],194:[function(require,module,exports){
arguments[4][73][0].apply(exports,arguments)
},{"dup":73}],195:[function(require,module,exports){
'use strict';
var hide = require('./_hide');
var redefine = require('./_redefine');
var fails = require('./_fails');
var defined = require('./_defined');
var wks = require('./_wks');

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var fns = exec(defined, SYMBOL, ''[KEY]);
  var strfn = fns[0];
  var rxfn = fns[1];
  if (fails(function () {
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  })) {
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return rxfn.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return rxfn.call(string, this); }
    );
  }
};

},{"./_defined":187,"./_fails":194,"./_hide":201,"./_redefine":250,"./_wks":285}],196:[function(require,module,exports){
'use strict';
// 21.2.5.3 get RegExp.prototype.flags
var anObject = require('./_an-object');
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

},{"./_an-object":166}],197:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var isArray = require('./_is-array');
var isObject = require('./_is-object');
var toLength = require('./_to-length');
var ctx = require('./_ctx');
var IS_CONCAT_SPREADABLE = require('./_wks')('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      spreadable = false;
      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
}

module.exports = flattenIntoArray;

},{"./_ctx":184,"./_is-array":208,"./_is-object":210,"./_to-length":274,"./_wks":285}],198:[function(require,module,exports){
arguments[4][74][0].apply(exports,arguments)
},{"./_an-object":166,"./_ctx":184,"./_is-array-iter":207,"./_iter-call":212,"./_to-length":274,"./core.get-iterator-method":286,"dup":74}],199:[function(require,module,exports){
arguments[4][75][0].apply(exports,arguments)
},{"dup":75}],200:[function(require,module,exports){
arguments[4][76][0].apply(exports,arguments)
},{"dup":76}],201:[function(require,module,exports){
arguments[4][77][0].apply(exports,arguments)
},{"./_descriptors":188,"./_object-dp":230,"./_property-desc":248,"dup":77}],202:[function(require,module,exports){
arguments[4][78][0].apply(exports,arguments)
},{"./_global":199,"dup":78}],203:[function(require,module,exports){
arguments[4][79][0].apply(exports,arguments)
},{"./_descriptors":188,"./_dom-create":189,"./_fails":194,"dup":79}],204:[function(require,module,exports){
var isObject = require('./_is-object');
var setPrototypeOf = require('./_set-proto').set;
module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;
  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  } return that;
};

},{"./_is-object":210,"./_set-proto":255}],205:[function(require,module,exports){
arguments[4][80][0].apply(exports,arguments)
},{"dup":80}],206:[function(require,module,exports){
arguments[4][81][0].apply(exports,arguments)
},{"./_cof":177,"dup":81}],207:[function(require,module,exports){
arguments[4][82][0].apply(exports,arguments)
},{"./_iterators":217,"./_wks":285,"dup":82}],208:[function(require,module,exports){
arguments[4][83][0].apply(exports,arguments)
},{"./_cof":177,"dup":83}],209:[function(require,module,exports){
arguments[4][84][0].apply(exports,arguments)
},{"./_is-object":210,"dup":84}],210:[function(require,module,exports){
arguments[4][85][0].apply(exports,arguments)
},{"dup":85}],211:[function(require,module,exports){
// 7.2.8 IsRegExp(argument)
var isObject = require('./_is-object');
var cof = require('./_cof');
var MATCH = require('./_wks')('match');
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

},{"./_cof":177,"./_is-object":210,"./_wks":285}],212:[function(require,module,exports){
arguments[4][86][0].apply(exports,arguments)
},{"./_an-object":166,"dup":86}],213:[function(require,module,exports){
arguments[4][87][0].apply(exports,arguments)
},{"./_hide":201,"./_object-create":229,"./_property-desc":248,"./_set-to-string-tag":257,"./_wks":285,"dup":87}],214:[function(require,module,exports){
arguments[4][88][0].apply(exports,arguments)
},{"./_export":192,"./_has":200,"./_hide":201,"./_iter-create":213,"./_iterators":217,"./_library":218,"./_object-gpo":237,"./_redefine":250,"./_set-to-string-tag":257,"./_wks":285,"dup":88}],215:[function(require,module,exports){
arguments[4][89][0].apply(exports,arguments)
},{"./_wks":285,"dup":89}],216:[function(require,module,exports){
arguments[4][90][0].apply(exports,arguments)
},{"dup":90}],217:[function(require,module,exports){
arguments[4][91][0].apply(exports,arguments)
},{"dup":91}],218:[function(require,module,exports){
module.exports = false;

},{}],219:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = (!$expm1
  // Old FF bug
  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || $expm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

},{}],220:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var sign = require('./_math-sign');
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

},{"./_math-sign":223}],221:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

},{}],222:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
module.exports = Math.scale || function scale(x, inLow, inHigh, outLow, outHigh) {
  if (
    arguments.length === 0
      // eslint-disable-next-line no-self-compare
      || x != x
      // eslint-disable-next-line no-self-compare
      || inLow != inLow
      // eslint-disable-next-line no-self-compare
      || inHigh != inHigh
      // eslint-disable-next-line no-self-compare
      || outLow != outLow
      // eslint-disable-next-line no-self-compare
      || outHigh != outHigh
  ) return NaN;
  if (x === Infinity || x === -Infinity) return x;
  return (x - inLow) * (outHigh - outLow) / (inHigh - inLow) + outLow;
};

},{}],223:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

},{}],224:[function(require,module,exports){
arguments[4][93][0].apply(exports,arguments)
},{"./_fails":194,"./_has":200,"./_is-object":210,"./_object-dp":230,"./_uid":280,"dup":93}],225:[function(require,module,exports){
var Map = require('./es6.map');
var $export = require('./_export');
var shared = require('./_shared')('metadata');
var store = shared.store || (shared.store = new (require('./es6.weak-map'))());

var getOrCreateMetadataMap = function (target, targetKey, create) {
  var targetMetadata = store.get(target);
  if (!targetMetadata) {
    if (!create) return undefined;
    store.set(target, targetMetadata = new Map());
  }
  var keyMetadata = targetMetadata.get(targetKey);
  if (!keyMetadata) {
    if (!create) return undefined;
    targetMetadata.set(targetKey, keyMetadata = new Map());
  } return keyMetadata;
};
var ordinaryHasOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? false : metadataMap.has(MetadataKey);
};
var ordinaryGetOwnMetadata = function (MetadataKey, O, P) {
  var metadataMap = getOrCreateMetadataMap(O, P, false);
  return metadataMap === undefined ? undefined : metadataMap.get(MetadataKey);
};
var ordinaryDefineOwnMetadata = function (MetadataKey, MetadataValue, O, P) {
  getOrCreateMetadataMap(O, P, true).set(MetadataKey, MetadataValue);
};
var ordinaryOwnMetadataKeys = function (target, targetKey) {
  var metadataMap = getOrCreateMetadataMap(target, targetKey, false);
  var keys = [];
  if (metadataMap) metadataMap.forEach(function (_, key) { keys.push(key); });
  return keys;
};
var toMetaKey = function (it) {
  return it === undefined || typeof it == 'symbol' ? it : String(it);
};
var exp = function (O) {
  $export($export.S, 'Reflect', O);
};

module.exports = {
  store: store,
  map: getOrCreateMetadataMap,
  has: ordinaryHasOwnMetadata,
  get: ordinaryGetOwnMetadata,
  set: ordinaryDefineOwnMetadata,
  keys: ordinaryOwnMetadataKeys,
  key: toMetaKey,
  exp: exp
};

},{"./_export":192,"./_shared":259,"./es6.map":317,"./es6.weak-map":423}],226:[function(require,module,exports){
arguments[4][94][0].apply(exports,arguments)
},{"./_cof":177,"./_global":199,"./_task":269,"dup":94}],227:[function(require,module,exports){
arguments[4][95][0].apply(exports,arguments)
},{"./_a-function":162,"dup":95}],228:[function(require,module,exports){
arguments[4][96][0].apply(exports,arguments)
},{"./_fails":194,"./_iobject":206,"./_object-gops":236,"./_object-keys":239,"./_object-pie":240,"./_to-object":275,"dup":96}],229:[function(require,module,exports){
arguments[4][97][0].apply(exports,arguments)
},{"./_an-object":166,"./_dom-create":189,"./_enum-bug-keys":190,"./_html":202,"./_object-dps":231,"./_shared-key":258,"dup":97}],230:[function(require,module,exports){
arguments[4][98][0].apply(exports,arguments)
},{"./_an-object":166,"./_descriptors":188,"./_ie8-dom-define":203,"./_to-primitive":276,"dup":98}],231:[function(require,module,exports){
arguments[4][99][0].apply(exports,arguments)
},{"./_an-object":166,"./_descriptors":188,"./_object-dp":230,"./_object-keys":239,"dup":99}],232:[function(require,module,exports){
'use strict';
// Forced replacement prototype accessors methods
module.exports = require('./_library') || !require('./_fails')(function () {
  var K = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, K, function () { /* empty */ });
  delete require('./_global')[K];
});

},{"./_fails":194,"./_global":199,"./_library":218}],233:[function(require,module,exports){
arguments[4][100][0].apply(exports,arguments)
},{"./_descriptors":188,"./_has":200,"./_ie8-dom-define":203,"./_object-pie":240,"./_property-desc":248,"./_to-iobject":273,"./_to-primitive":276,"dup":100}],234:[function(require,module,exports){
arguments[4][101][0].apply(exports,arguments)
},{"./_object-gopn":235,"./_to-iobject":273,"dup":101}],235:[function(require,module,exports){
arguments[4][102][0].apply(exports,arguments)
},{"./_enum-bug-keys":190,"./_object-keys-internal":238,"dup":102}],236:[function(require,module,exports){
arguments[4][103][0].apply(exports,arguments)
},{"dup":103}],237:[function(require,module,exports){
arguments[4][104][0].apply(exports,arguments)
},{"./_has":200,"./_shared-key":258,"./_to-object":275,"dup":104}],238:[function(require,module,exports){
arguments[4][105][0].apply(exports,arguments)
},{"./_array-includes":170,"./_has":200,"./_shared-key":258,"./_to-iobject":273,"dup":105}],239:[function(require,module,exports){
arguments[4][106][0].apply(exports,arguments)
},{"./_enum-bug-keys":190,"./_object-keys-internal":238,"dup":106}],240:[function(require,module,exports){
arguments[4][107][0].apply(exports,arguments)
},{"dup":107}],241:[function(require,module,exports){
arguments[4][108][0].apply(exports,arguments)
},{"./_core":182,"./_export":192,"./_fails":194,"dup":108}],242:[function(require,module,exports){
arguments[4][109][0].apply(exports,arguments)
},{"./_object-keys":239,"./_object-pie":240,"./_to-iobject":273,"dup":109}],243:[function(require,module,exports){
// all object keys, includes non-enumerable and symbols
var gOPN = require('./_object-gopn');
var gOPS = require('./_object-gops');
var anObject = require('./_an-object');
var Reflect = require('./_global').Reflect;
module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

},{"./_an-object":166,"./_global":199,"./_object-gopn":235,"./_object-gops":236}],244:[function(require,module,exports){
var $parseFloat = require('./_global').parseFloat;
var $trim = require('./_string-trim').trim;

module.exports = 1 / $parseFloat(require('./_string-ws') + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

},{"./_global":199,"./_string-trim":267,"./_string-ws":268}],245:[function(require,module,exports){
var $parseInt = require('./_global').parseInt;
var $trim = require('./_string-trim').trim;
var ws = require('./_string-ws');
var hex = /^[-+]?0[xX]/;

module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, (radix >>> 0) || (hex.test(string) ? 16 : 10));
} : $parseInt;

},{"./_global":199,"./_string-trim":267,"./_string-ws":268}],246:[function(require,module,exports){
arguments[4][110][0].apply(exports,arguments)
},{"dup":110}],247:[function(require,module,exports){
arguments[4][111][0].apply(exports,arguments)
},{"./_an-object":166,"./_is-object":210,"./_new-promise-capability":227,"dup":111}],248:[function(require,module,exports){
arguments[4][112][0].apply(exports,arguments)
},{"dup":112}],249:[function(require,module,exports){
var redefine = require('./_redefine');
module.exports = function (target, src, safe) {
  for (var key in src) redefine(target, key, src[key], safe);
  return target;
};

},{"./_redefine":250}],250:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var has = require('./_has');
var SRC = require('./_uid')('src');
var TO_STRING = 'toString';
var $toString = Function[TO_STRING];
var TPL = ('' + $toString).split(TO_STRING);

require('./_core').inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

},{"./_core":182,"./_global":199,"./_has":200,"./_hide":201,"./_uid":280}],251:[function(require,module,exports){
module.exports = function (regExp, replace) {
  var replacer = replace === Object(replace) ? function (part) {
    return replace[part];
  } : replace;
  return function (it) {
    return String(it).replace(regExp, replacer);
  };
};

},{}],252:[function(require,module,exports){
// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

},{}],253:[function(require,module,exports){
arguments[4][115][0].apply(exports,arguments)
},{"./_a-function":162,"./_ctx":184,"./_export":192,"./_for-of":198,"dup":115}],254:[function(require,module,exports){
arguments[4][116][0].apply(exports,arguments)
},{"./_export":192,"dup":116}],255:[function(require,module,exports){
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var isObject = require('./_is-object');
var anObject = require('./_an-object');
var check = function (O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};
module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
    function (test, buggy, set) {
      try {
        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) { buggy = true; }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy) O.__proto__ = proto;
        else set(O, proto);
        return O;
      };
    }({}, false) : undefined),
  check: check
};

},{"./_an-object":166,"./_ctx":184,"./_is-object":210,"./_object-gopd":233}],256:[function(require,module,exports){
'use strict';
var global = require('./_global');
var dP = require('./_object-dp');
var DESCRIPTORS = require('./_descriptors');
var SPECIES = require('./_wks')('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function () { return this; }
  });
};

},{"./_descriptors":188,"./_global":199,"./_object-dp":230,"./_wks":285}],257:[function(require,module,exports){
arguments[4][118][0].apply(exports,arguments)
},{"./_has":200,"./_object-dp":230,"./_wks":285,"dup":118}],258:[function(require,module,exports){
arguments[4][119][0].apply(exports,arguments)
},{"./_shared":259,"./_uid":280,"dup":119}],259:[function(require,module,exports){
arguments[4][120][0].apply(exports,arguments)
},{"./_global":199,"dup":120}],260:[function(require,module,exports){
arguments[4][121][0].apply(exports,arguments)
},{"./_a-function":162,"./_an-object":166,"./_wks":285,"dup":121}],261:[function(require,module,exports){
'use strict';
var fails = require('./_fails');

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);
  });
};

},{"./_fails":194}],262:[function(require,module,exports){
arguments[4][122][0].apply(exports,arguments)
},{"./_defined":187,"./_to-integer":272,"dup":122}],263:[function(require,module,exports){
// helper for String#{startsWith, endsWith, includes}
var isRegExp = require('./_is-regexp');
var defined = require('./_defined');

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

},{"./_defined":187,"./_is-regexp":211}],264:[function(require,module,exports){
var $export = require('./_export');
var fails = require('./_fails');
var defined = require('./_defined');
var quot = /"/g;
// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
var createHTML = function (string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};
module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

},{"./_defined":187,"./_export":192,"./_fails":194}],265:[function(require,module,exports){
// https://github.com/tc39/proposal-string-pad-start-end
var toLength = require('./_to-length');
var repeat = require('./_string-repeat');
var defined = require('./_defined');

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

},{"./_defined":187,"./_string-repeat":266,"./_to-length":274}],266:[function(require,module,exports){
'use strict';
var toInteger = require('./_to-integer');
var defined = require('./_defined');

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) res += str;
  return res;
};

},{"./_defined":187,"./_to-integer":272}],267:[function(require,module,exports){
var $export = require('./_export');
var defined = require('./_defined');
var fails = require('./_fails');
var spaces = require('./_string-ws');
var space = '[' + spaces + ']';
var non = '\u200b\u0085';
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function (KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
};

// 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim
var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

},{"./_defined":187,"./_export":192,"./_fails":194,"./_string-ws":268}],268:[function(require,module,exports){
module.exports = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
  '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';

},{}],269:[function(require,module,exports){
arguments[4][123][0].apply(exports,arguments)
},{"./_cof":177,"./_ctx":184,"./_dom-create":189,"./_global":199,"./_html":202,"./_invoke":205,"dup":123}],270:[function(require,module,exports){
arguments[4][124][0].apply(exports,arguments)
},{"./_to-integer":272,"dup":124}],271:[function(require,module,exports){
// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

},{"./_to-integer":272,"./_to-length":274}],272:[function(require,module,exports){
arguments[4][125][0].apply(exports,arguments)
},{"dup":125}],273:[function(require,module,exports){
arguments[4][126][0].apply(exports,arguments)
},{"./_defined":187,"./_iobject":206,"dup":126}],274:[function(require,module,exports){
arguments[4][127][0].apply(exports,arguments)
},{"./_to-integer":272,"dup":127}],275:[function(require,module,exports){
arguments[4][128][0].apply(exports,arguments)
},{"./_defined":187,"dup":128}],276:[function(require,module,exports){
arguments[4][129][0].apply(exports,arguments)
},{"./_is-object":210,"dup":129}],277:[function(require,module,exports){
'use strict';
if (require('./_descriptors')) {
  var LIBRARY = require('./_library');
  var global = require('./_global');
  var fails = require('./_fails');
  var $export = require('./_export');
  var $typed = require('./_typed');
  var $buffer = require('./_typed-buffer');
  var ctx = require('./_ctx');
  var anInstance = require('./_an-instance');
  var propertyDesc = require('./_property-desc');
  var hide = require('./_hide');
  var redefineAll = require('./_redefine-all');
  var toInteger = require('./_to-integer');
  var toLength = require('./_to-length');
  var toIndex = require('./_to-index');
  var toAbsoluteIndex = require('./_to-absolute-index');
  var toPrimitive = require('./_to-primitive');
  var has = require('./_has');
  var classof = require('./_classof');
  var isObject = require('./_is-object');
  var toObject = require('./_to-object');
  var isArrayIter = require('./_is-array-iter');
  var create = require('./_object-create');
  var getPrototypeOf = require('./_object-gpo');
  var gOPN = require('./_object-gopn').f;
  var getIterFn = require('./core.get-iterator-method');
  var uid = require('./_uid');
  var wks = require('./_wks');
  var createArrayMethod = require('./_array-methods');
  var createArrayIncludes = require('./_array-includes');
  var speciesConstructor = require('./_species-constructor');
  var ArrayIterators = require('./es6.array.iterator');
  var Iterators = require('./_iterators');
  var $iterDetect = require('./_iter-detect');
  var setSpecies = require('./_set-species');
  var arrayFill = require('./_array-fill');
  var arrayCopyWithin = require('./_array-copy-within');
  var $DP = require('./_object-dp');
  var $GOPD = require('./_object-gopd');
  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';

  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });

  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });

  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function (it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function (it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function (C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    } return new C(length);
  };

  var speciesFromList = function (O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function (C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);
    while (length > index) result[index] = list[index++];
    return result;
  };

  var addGetter = function (it, key, internal) {
    dP(it, key, { get: function () { return this._d[internal]; } });
  };

  var $from = function from(source /* , mapfn, thisArg */) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;
    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      } O = values;
    }
    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);
    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
  };

  var $of = function of(/* ...items */) {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);
    while (length > index) result[index] = arguments[index++];
    return result;
  };

  // iOS Safari 6.x fails here
  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start /* , end */) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn /* , thisArg */) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn /* , thisArg */) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn,
        arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate /* , thisArg */) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate /* , thisArg */) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn /* , thisArg */) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement /* , fromIndex */) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement /* , fromIndex */) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) { // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn /* , thisArg */) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;
      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      } return that;
    },
    some: function some(callbackfn /* , thisArg */) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(
        O.buffer,
        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,
        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)
      );
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike /* , offset */) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);
    while (index < len) this[offset + index] = src[index++];
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function (target, key) {
    return isObject(target)
      && target[TYPED_ARRAY]
      && typeof key != 'symbol'
      && key in target
      && String(+key) == String(key);
  };
  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true))
      ? propertyDesc(2, target[key])
      : gOPD(target, key);
  };
  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true))
      && isObject(desc)
      && has(desc, 'value')
      && !has(desc, 'get')
      && !has(desc, 'set')
      // TODO: add validation descriptor w/o calling accessors
      && !desc.configurable
      && (!has(desc, 'writable') || desc.writable)
      && (!has(desc, 'enumerable') || desc.enumerable)
    ) {
      target[key] = desc.value;
      return target;
    } return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () { arrayToString.call({}); })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function () { /* noop */ },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function () { return this[TYPED_ARRAY]; }
  });

  // eslint-disable-next-line max-statements
  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];
    var getter = function (that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };
    var setter = function (that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };
    var addElement = function (that, index) {
      dP(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };
    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }
        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new
      new TypedArray(null); // eslint-disable-line no-new
      new TypedArray(1.5); // eslint-disable-line no-new
      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass;
        // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645
        if (!isObject(data)) return new Base(toIndex(data));
        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined
            ? new Base(data, toOffset($offset, BYTES), $length)
            : $offset !== undefined
              ? new Base(data, toOffset($offset, BYTES))
              : new Base(data);
        }
        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }
    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator
      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function () { return NAME; }
      });
    }

    O[NAME] = TypedArray;

    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);

    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });

    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {
      from: $from,
      of: $of
    });

    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);

    $export($export.P, NAME, proto);

    setSpecies(NAME);

    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });

    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);

    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;

    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, { slice: $slice });

    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, { toLocaleString: $toLocaleString });

    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () { /* empty */ };

},{"./_an-instance":165,"./_array-copy-within":167,"./_array-fill":168,"./_array-includes":170,"./_array-methods":171,"./_classof":176,"./_ctx":184,"./_descriptors":188,"./_export":192,"./_fails":194,"./_global":199,"./_has":200,"./_hide":201,"./_is-array-iter":207,"./_is-object":210,"./_iter-detect":215,"./_iterators":217,"./_library":218,"./_object-create":229,"./_object-dp":230,"./_object-gopd":233,"./_object-gopn":235,"./_object-gpo":237,"./_property-desc":248,"./_redefine-all":249,"./_set-species":256,"./_species-constructor":260,"./_to-absolute-index":270,"./_to-index":271,"./_to-integer":272,"./_to-length":274,"./_to-object":275,"./_to-primitive":276,"./_typed":279,"./_typed-buffer":278,"./_uid":280,"./_wks":285,"./core.get-iterator-method":286,"./es6.array.iterator":298}],278:[function(require,module,exports){
'use strict';
var global = require('./_global');
var DESCRIPTORS = require('./_descriptors');
var LIBRARY = require('./_library');
var $typed = require('./_typed');
var hide = require('./_hide');
var redefineAll = require('./_redefine-all');
var fails = require('./_fails');
var anInstance = require('./_an-instance');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var toIndex = require('./_to-index');
var gOPN = require('./_object-gopn').f;
var dP = require('./_object-dp').f;
var arrayFill = require('./_array-fill');
var setToStringTag = require('./_set-to-string-tag');
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;

// IEEE754 conversions based on https://github.com/feross/ieee754
function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value);
  // eslint-disable-next-line no-self-compare
  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);
    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }
    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }
  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);
  e = e << mLen | m;
  eLen += mLen;
  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);
  buffer[--i] |= s * 128;
  return buffer;
}
function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;
  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);
  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);
  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  } return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}
function packI8(it) {
  return [it & 0xff];
}
function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}
function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}
function packF64(it) {
  return packIEEE754(it, 52, 8);
}
function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}
function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);
  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new
    new $ArrayBuffer(1.5); // eslint-disable-line no-new
    new $ArrayBuffer(NaN); // eslint-disable-line no-new
    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };
    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];
    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }
    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}
setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

},{"./_an-instance":165,"./_array-fill":168,"./_descriptors":188,"./_fails":194,"./_global":199,"./_hide":201,"./_library":218,"./_object-dp":230,"./_object-gopn":235,"./_redefine-all":249,"./_set-to-string-tag":257,"./_to-index":271,"./_to-integer":272,"./_to-length":274,"./_typed":279}],279:[function(require,module,exports){
var global = require('./_global');
var hide = require('./_hide');
var uid = require('./_uid');
var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;

var TypedArrayConstructors = (
  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'
).split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

},{"./_global":199,"./_hide":201,"./_uid":280}],280:[function(require,module,exports){
arguments[4][130][0].apply(exports,arguments)
},{"dup":130}],281:[function(require,module,exports){
var global = require('./_global');
var navigator = global.navigator;

module.exports = navigator && navigator.userAgent || '';

},{"./_global":199}],282:[function(require,module,exports){
arguments[4][131][0].apply(exports,arguments)
},{"./_is-object":210,"dup":131}],283:[function(require,module,exports){
arguments[4][132][0].apply(exports,arguments)
},{"./_core":182,"./_global":199,"./_library":218,"./_object-dp":230,"./_wks-ext":284,"dup":132}],284:[function(require,module,exports){
arguments[4][133][0].apply(exports,arguments)
},{"./_wks":285,"dup":133}],285:[function(require,module,exports){
arguments[4][134][0].apply(exports,arguments)
},{"./_global":199,"./_shared":259,"./_uid":280,"dup":134}],286:[function(require,module,exports){
arguments[4][135][0].apply(exports,arguments)
},{"./_classof":176,"./_core":182,"./_iterators":217,"./_wks":285,"dup":135}],287:[function(require,module,exports){
// https://github.com/benjamingr/RexExp.escape
var $export = require('./_export');
var $re = require('./_replacer')(/[\\^$*+?.()|[\]{}]/g, '\\$&');

$export($export.S, 'RegExp', { escape: function escape(it) { return $re(it); } });

},{"./_export":192,"./_replacer":251}],288:[function(require,module,exports){
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { copyWithin: require('./_array-copy-within') });

require('./_add-to-unscopables')('copyWithin');

},{"./_add-to-unscopables":164,"./_array-copy-within":167,"./_export":192}],289:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $every = require('./_array-methods')(4);

$export($export.P + $export.F * !require('./_strict-method')([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":171,"./_export":192,"./_strict-method":261}],290:[function(require,module,exports){
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = require('./_export');

$export($export.P, 'Array', { fill: require('./_array-fill') });

require('./_add-to-unscopables')('fill');

},{"./_add-to-unscopables":164,"./_array-fill":168,"./_export":192}],291:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $filter = require('./_array-methods')(2);

$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":171,"./_export":192,"./_strict-method":261}],292:[function(require,module,exports){
'use strict';
// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(6);
var KEY = 'findIndex';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":164,"./_array-methods":171,"./_export":192}],293:[function(require,module,exports){
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = require('./_export');
var $find = require('./_array-methods')(5);
var KEY = 'find';
var forced = true;
// Shouldn't skip holes
if (KEY in []) Array(1)[KEY](function () { forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
require('./_add-to-unscopables')(KEY);

},{"./_add-to-unscopables":164,"./_array-methods":171,"./_export":192}],294:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $forEach = require('./_array-methods')(0);
var STRICT = require('./_strict-method')([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn /* , thisArg */) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":171,"./_export":192,"./_strict-method":261}],295:[function(require,module,exports){
arguments[4][138][0].apply(exports,arguments)
},{"./_create-property":183,"./_ctx":184,"./_export":192,"./_is-array-iter":207,"./_iter-call":212,"./_iter-detect":215,"./_to-length":274,"./_to-object":275,"./core.get-iterator-method":286,"dup":138}],296:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $indexOf = require('./_array-includes')(false);
var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? $native.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments[1]);
  }
});

},{"./_array-includes":170,"./_export":192,"./_strict-method":261}],297:[function(require,module,exports){
// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = require('./_export');

$export($export.S, 'Array', { isArray: require('./_is-array') });

},{"./_export":192,"./_is-array":208}],298:[function(require,module,exports){
arguments[4][139][0].apply(exports,arguments)
},{"./_add-to-unscopables":164,"./_iter-define":214,"./_iter-step":216,"./_iterators":217,"./_to-iobject":273,"dup":139}],299:[function(require,module,exports){
'use strict';
// 22.1.3.13 Array.prototype.join(separator)
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var arrayJoin = [].join;

// fallback for not array-like strings
$export($export.P + $export.F * (require('./_iobject') != Object || !require('./_strict-method')(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

},{"./_export":192,"./_iobject":206,"./_strict-method":261,"./_to-iobject":273}],300:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toInteger = require('./_to-integer');
var toLength = require('./_to-length');
var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;

$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;
    for (;index >= 0; index--) if (index in O) if (O[index] === searchElement) return index || 0;
    return -1;
  }
});

},{"./_export":192,"./_strict-method":261,"./_to-integer":272,"./_to-iobject":273,"./_to-length":274}],301:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $map = require('./_array-methods')(1);

$export($export.P + $export.F * !require('./_strict-method')([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":171,"./_export":192,"./_strict-method":261}],302:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var createProperty = require('./_create-property');

// WebKit Array.of isn't generic
$export($export.S + $export.F * require('./_fails')(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of(/* ...args */) {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);
    while (aLen > index) createProperty(result, index, arguments[index++]);
    result.length = aLen;
    return result;
  }
});

},{"./_create-property":183,"./_export":192,"./_fails":194}],303:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

},{"./_array-reduce":172,"./_export":192,"./_strict-method":261}],304:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $reduce = require('./_array-reduce');

$export($export.P + $export.F * !require('./_strict-method')([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

},{"./_array-reduce":172,"./_export":192,"./_strict-method":261}],305:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var html = require('./_html');
var cof = require('./_cof');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var arraySlice = [].slice;

// fallback for not array-like ES3 strings and DOM objects
$export($export.P + $export.F * require('./_fails')(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;
    for (; i < size; i++) cloned[i] = klass == 'String'
      ? this.charAt(start + i)
      : this[start + i];
    return cloned;
  }
});

},{"./_cof":177,"./_export":192,"./_fails":194,"./_html":202,"./_to-absolute-index":270,"./_to-length":274}],306:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $some = require('./_array-methods')(3);

$export($export.P + $export.F * !require('./_strict-method')([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments[1]);
  }
});

},{"./_array-methods":171,"./_export":192,"./_strict-method":261}],307:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var aFunction = require('./_a-function');
var toObject = require('./_to-object');
var fails = require('./_fails');
var $sort = [].sort;
var test = [1, 2, 3];

$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null);
  // Old WebKit
}) || !require('./_strict-method')($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? $sort.call(toObject(this))
      : $sort.call(toObject(this), aFunction(comparefn));
  }
});

},{"./_a-function":162,"./_export":192,"./_fails":194,"./_strict-method":261,"./_to-object":275}],308:[function(require,module,exports){
require('./_set-species')('Array');

},{"./_set-species":256}],309:[function(require,module,exports){
// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = require('./_export');

$export($export.S, 'Date', { now: function () { return new Date().getTime(); } });

},{"./_export":192}],310:[function(require,module,exports){
// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = require('./_export');
var toISOString = require('./_date-to-iso-string');

// PhantomJS / old WebKit has a broken implementations
$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

},{"./_date-to-iso-string":185,"./_export":192}],311:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');

$export($export.P + $export.F * require('./_fails')(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

},{"./_export":192,"./_fails":194,"./_to-object":275,"./_to-primitive":276}],312:[function(require,module,exports){
var TO_PRIMITIVE = require('./_wks')('toPrimitive');
var proto = Date.prototype;

if (!(TO_PRIMITIVE in proto)) require('./_hide')(proto, TO_PRIMITIVE, require('./_date-to-primitive'));

},{"./_date-to-primitive":186,"./_hide":201,"./_wks":285}],313:[function(require,module,exports){
var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;
if (new Date(NaN) + '' != INVALID_DATE) {
  require('./_redefine')(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

},{"./_redefine":250}],314:[function(require,module,exports){
// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = require('./_export');

$export($export.P, 'Function', { bind: require('./_bind') });

},{"./_bind":175,"./_export":192}],315:[function(require,module,exports){
'use strict';
var isObject = require('./_is-object');
var getPrototypeOf = require('./_object-gpo');
var HAS_INSTANCE = require('./_wks')('hasInstance');
var FunctionProto = Function.prototype;
// 19.2.3.6 Function.prototype[@@hasInstance](V)
if (!(HAS_INSTANCE in FunctionProto)) require('./_object-dp').f(FunctionProto, HAS_INSTANCE, { value: function (O) {
  if (typeof this != 'function' || !isObject(O)) return false;
  if (!isObject(this.prototype)) return O instanceof this;
  // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
  while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
  return false;
} });

},{"./_is-object":210,"./_object-dp":230,"./_object-gpo":237,"./_wks":285}],316:[function(require,module,exports){
var dP = require('./_object-dp').f;
var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// 19.2.4.2 name
NAME in FProto || require('./_descriptors') && dP(FProto, NAME, {
  configurable: true,
  get: function () {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

},{"./_descriptors":188,"./_object-dp":230}],317:[function(require,module,exports){
'use strict';
var strong = require('./_collection-strong');
var validate = require('./_validate-collection');
var MAP = 'Map';

// 23.1 Map Objects
module.exports = require('./_collection')(MAP, function (get) {
  return function Map() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

},{"./_collection":181,"./_collection-strong":178,"./_validate-collection":282}],318:[function(require,module,exports){
// 20.2.2.3 Math.acosh(x)
var $export = require('./_export');
var log1p = require('./_math-log1p');
var sqrt = Math.sqrt;
var $acosh = Math.acosh;

$export($export.S + $export.F * !($acosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  && Math.floor($acosh(Number.MAX_VALUE)) == 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  && $acosh(Infinity) == Infinity
), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? Math.log(x) + Math.LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

},{"./_export":192,"./_math-log1p":221}],319:[function(require,module,exports){
// 20.2.2.5 Math.asinh(x)
var $export = require('./_export');
var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
}

// Tor Browser bug: Math.asinh(0) -> -0
$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', { asinh: asinh });

},{"./_export":192}],320:[function(require,module,exports){
// 20.2.2.7 Math.atanh(x)
var $export = require('./_export');
var $atanh = Math.atanh;

// Tor Browser bug: Math.atanh(-0) -> 0
$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

},{"./_export":192}],321:[function(require,module,exports){
// 20.2.2.9 Math.cbrt(x)
var $export = require('./_export');
var sign = require('./_math-sign');

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

},{"./_export":192,"./_math-sign":223}],322:[function(require,module,exports){
// 20.2.2.11 Math.clz32(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

},{"./_export":192}],323:[function(require,module,exports){
// 20.2.2.12 Math.cosh(x)
var $export = require('./_export');
var exp = Math.exp;

$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

},{"./_export":192}],324:[function(require,module,exports){
// 20.2.2.14 Math.expm1(x)
var $export = require('./_export');
var $expm1 = require('./_math-expm1');

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', { expm1: $expm1 });

},{"./_export":192,"./_math-expm1":219}],325:[function(require,module,exports){
// 20.2.2.16 Math.fround(x)
var $export = require('./_export');

$export($export.S, 'Math', { fround: require('./_math-fround') });

},{"./_export":192,"./_math-fround":220}],326:[function(require,module,exports){
// 20.2.2.17 Math.hypot([value1[, value2[,  ]]])
var $export = require('./_export');
var abs = Math.abs;

$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

},{"./_export":192}],327:[function(require,module,exports){
// 20.2.2.18 Math.imul(x, y)
var $export = require('./_export');
var $imul = Math.imul;

// some WebKit versions fails with big numbers, some has wrong arity
$export($export.S + $export.F * require('./_fails')(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

},{"./_export":192,"./_fails":194}],328:[function(require,module,exports){
// 20.2.2.21 Math.log10(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

},{"./_export":192}],329:[function(require,module,exports){
// 20.2.2.20 Math.log1p(x)
var $export = require('./_export');

$export($export.S, 'Math', { log1p: require('./_math-log1p') });

},{"./_export":192,"./_math-log1p":221}],330:[function(require,module,exports){
// 20.2.2.22 Math.log2(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

},{"./_export":192}],331:[function(require,module,exports){
// 20.2.2.28 Math.sign(x)
var $export = require('./_export');

$export($export.S, 'Math', { sign: require('./_math-sign') });

},{"./_export":192,"./_math-sign":223}],332:[function(require,module,exports){
// 20.2.2.30 Math.sinh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

// V8 near Chromium 38 has a problem with very small numbers
$export($export.S + $export.F * require('./_fails')(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1
      ? (expm1(x) - expm1(-x)) / 2
      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

},{"./_export":192,"./_fails":194,"./_math-expm1":219}],333:[function(require,module,exports){
// 20.2.2.33 Math.tanh(x)
var $export = require('./_export');
var expm1 = require('./_math-expm1');
var exp = Math.exp;

$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

},{"./_export":192,"./_math-expm1":219}],334:[function(require,module,exports){
// 20.2.2.34 Math.trunc(x)
var $export = require('./_export');

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

},{"./_export":192}],335:[function(require,module,exports){
'use strict';
var global = require('./_global');
var has = require('./_has');
var cof = require('./_cof');
var inheritIfRequired = require('./_inherit-if-required');
var toPrimitive = require('./_to-primitive');
var fails = require('./_fails');
var gOPN = require('./_object-gopn').f;
var gOPD = require('./_object-gopd').f;
var dP = require('./_object-dp').f;
var $trim = require('./_string-trim').trim;
var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype;
// Opera ~12 has broken Object#toString
var BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype;

// 7.1.3 ToNumber(argument)
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i
        default: return +it;
      }
      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number
      // check on 1..constructor(foo) case
      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)
        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };
  for (var keys = require('./_descriptors') ? gOPN(Base) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES6 (in case, if modules with ES6 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }
  $Number.prototype = proto;
  proto.constructor = $Number;
  require('./_redefine')(global, NUMBER, $Number);
}

},{"./_cof":177,"./_descriptors":188,"./_fails":194,"./_global":199,"./_has":200,"./_inherit-if-required":204,"./_object-create":229,"./_object-dp":230,"./_object-gopd":233,"./_object-gopn":235,"./_redefine":250,"./_string-trim":267,"./_to-primitive":276}],336:[function(require,module,exports){
// 20.1.2.1 Number.EPSILON
var $export = require('./_export');

$export($export.S, 'Number', { EPSILON: Math.pow(2, -52) });

},{"./_export":192}],337:[function(require,module,exports){
// 20.1.2.2 Number.isFinite(number)
var $export = require('./_export');
var _isFinite = require('./_global').isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

},{"./_export":192,"./_global":199}],338:[function(require,module,exports){
arguments[4][140][0].apply(exports,arguments)
},{"./_export":192,"./_is-integer":209,"dup":140}],339:[function(require,module,exports){
arguments[4][141][0].apply(exports,arguments)
},{"./_export":192,"dup":141}],340:[function(require,module,exports){
arguments[4][142][0].apply(exports,arguments)
},{"./_export":192,"./_is-integer":209,"dup":142}],341:[function(require,module,exports){
// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MAX_SAFE_INTEGER: 0x1fffffffffffff });

},{"./_export":192}],342:[function(require,module,exports){
// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = require('./_export');

$export($export.S, 'Number', { MIN_SAFE_INTEGER: -0x1fffffffffffff });

},{"./_export":192}],343:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 20.1.2.12 Number.parseFloat(string)
$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', { parseFloat: $parseFloat });

},{"./_export":192,"./_parse-float":244}],344:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 20.1.2.13 Number.parseInt(string, radix)
$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', { parseInt: $parseInt });

},{"./_export":192,"./_parse-int":245}],345:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toInteger = require('./_to-integer');
var aNumberValue = require('./_a-number-value');
var repeat = require('./_string-repeat');
var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function (n, c) {
  var i = -1;
  var c2 = c;
  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};
var divide = function (n) {
  var i = 6;
  var c = 0;
  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = (c % n) * 1e7;
  }
};
var numToString = function () {
  var i = 6;
  var s = '';
  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  } return s;
};
var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};
var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

$export($export.P + $export.F * (!!$toFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !require('./_fails')(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR);
    // eslint-disable-next-line no-self-compare
    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);
    if (x < 0) {
      s = '-';
      x = -x;
    }
    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = f;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }
    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    } return m;
  }
});

},{"./_a-number-value":163,"./_export":192,"./_fails":194,"./_string-repeat":266,"./_to-integer":272}],346:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $fails = require('./_fails');
var aNumberValue = require('./_a-number-value');
var $toPrecision = 1.0.toPrecision;

$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

},{"./_a-number-value":163,"./_export":192,"./_fails":194}],347:[function(require,module,exports){
arguments[4][143][0].apply(exports,arguments)
},{"./_export":192,"./_object-assign":228,"dup":143}],348:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
$export($export.S, 'Object', { create: require('./_object-create') });

},{"./_export":192,"./_object-create":229}],349:[function(require,module,exports){
var $export = require('./_export');
// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)
$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });

},{"./_descriptors":188,"./_export":192,"./_object-dps":231}],350:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"./_descriptors":188,"./_export":192,"./_object-dp":230,"dup":144}],351:[function(require,module,exports){
arguments[4][145][0].apply(exports,arguments)
},{"./_is-object":210,"./_meta":224,"./_object-sap":241,"dup":145}],352:[function(require,module,exports){
// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = require('./_to-iobject');
var $getOwnPropertyDescriptor = require('./_object-gopd').f;

require('./_object-sap')('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

},{"./_object-gopd":233,"./_object-sap":241,"./_to-iobject":273}],353:[function(require,module,exports){
// 19.1.2.7 Object.getOwnPropertyNames(O)
require('./_object-sap')('getOwnPropertyNames', function () {
  return require('./_object-gopn-ext').f;
});

},{"./_object-gopn-ext":234,"./_object-sap":241}],354:[function(require,module,exports){
// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = require('./_to-object');
var $getPrototypeOf = require('./_object-gpo');

require('./_object-sap')('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

},{"./_object-gpo":237,"./_object-sap":241,"./_to-object":275}],355:[function(require,module,exports){
// 19.1.2.11 Object.isExtensible(O)
var isObject = require('./_is-object');

require('./_object-sap')('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

},{"./_is-object":210,"./_object-sap":241}],356:[function(require,module,exports){
// 19.1.2.12 Object.isFrozen(O)
var isObject = require('./_is-object');

require('./_object-sap')('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

},{"./_is-object":210,"./_object-sap":241}],357:[function(require,module,exports){
// 19.1.2.13 Object.isSealed(O)
var isObject = require('./_is-object');

require('./_object-sap')('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

},{"./_is-object":210,"./_object-sap":241}],358:[function(require,module,exports){
// 19.1.3.10 Object.is(value1, value2)
var $export = require('./_export');
$export($export.S, 'Object', { is: require('./_same-value') });

},{"./_export":192,"./_same-value":252}],359:[function(require,module,exports){
arguments[4][146][0].apply(exports,arguments)
},{"./_object-keys":239,"./_object-sap":241,"./_to-object":275,"dup":146}],360:[function(require,module,exports){
// 19.1.2.15 Object.preventExtensions(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

},{"./_is-object":210,"./_meta":224,"./_object-sap":241}],361:[function(require,module,exports){
// 19.1.2.17 Object.seal(O)
var isObject = require('./_is-object');
var meta = require('./_meta').onFreeze;

require('./_object-sap')('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

},{"./_is-object":210,"./_meta":224,"./_object-sap":241}],362:[function(require,module,exports){
// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = require('./_export');
$export($export.S, 'Object', { setPrototypeOf: require('./_set-proto').set });

},{"./_export":192,"./_set-proto":255}],363:[function(require,module,exports){
'use strict';
// 19.1.3.6 Object.prototype.toString()
var classof = require('./_classof');
var test = {};
test[require('./_wks')('toStringTag')] = 'z';
if (test + '' != '[object z]') {
  require('./_redefine')(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

},{"./_classof":176,"./_redefine":250,"./_wks":285}],364:[function(require,module,exports){
var $export = require('./_export');
var $parseFloat = require('./_parse-float');
// 18.2.4 parseFloat(string)
$export($export.G + $export.F * (parseFloat != $parseFloat), { parseFloat: $parseFloat });

},{"./_export":192,"./_parse-float":244}],365:[function(require,module,exports){
var $export = require('./_export');
var $parseInt = require('./_parse-int');
// 18.2.5 parseInt(string, radix)
$export($export.G + $export.F * (parseInt != $parseInt), { parseInt: $parseInt });

},{"./_export":192,"./_parse-int":245}],366:[function(require,module,exports){
arguments[4][148][0].apply(exports,arguments)
},{"./_a-function":162,"./_an-instance":165,"./_classof":176,"./_core":182,"./_ctx":184,"./_export":192,"./_for-of":198,"./_global":199,"./_is-object":210,"./_iter-detect":215,"./_library":218,"./_microtask":226,"./_new-promise-capability":227,"./_perform":246,"./_promise-resolve":247,"./_redefine-all":249,"./_set-species":256,"./_set-to-string-tag":257,"./_species-constructor":260,"./_task":269,"./_wks":285,"dup":148}],367:[function(require,module,exports){
// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = require('./_export');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var rApply = (require('./_global').Reflect || {}).apply;
var fApply = Function.apply;
// MS Edge argumentsList argument is optional
$export($export.S + $export.F * !require('./_fails')(function () {
  rApply(function () { /* empty */ });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

},{"./_a-function":162,"./_an-object":166,"./_export":192,"./_fails":194,"./_global":199}],368:[function(require,module,exports){
// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = require('./_export');
var create = require('./_object-create');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var isObject = require('./_is-object');
var fails = require('./_fails');
var bind = require('./_bind');
var rConstruct = (require('./_global').Reflect || {}).construct;

// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(rConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () { /* empty */ });
});

$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

},{"./_a-function":162,"./_an-object":166,"./_bind":175,"./_export":192,"./_fails":194,"./_global":199,"./_is-object":210,"./_object-create":229}],369:[function(require,module,exports){
// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = require('./_object-dp');
var $export = require('./_export');
var anObject = require('./_an-object');
var toPrimitive = require('./_to-primitive');

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
$export($export.S + $export.F * require('./_fails')(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, { value: 1 }), 1, { value: 2 });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":166,"./_export":192,"./_fails":194,"./_object-dp":230,"./_to-primitive":276}],370:[function(require,module,exports){
// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = require('./_export');
var gOPD = require('./_object-gopd').f;
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

},{"./_an-object":166,"./_export":192,"./_object-gopd":233}],371:[function(require,module,exports){
'use strict';
// 26.1.5 Reflect.enumerate(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var Enumerate = function (iterated) {
  this._t = anObject(iterated); // target
  this._i = 0;                  // next index
  var keys = this._k = [];      // keys
  var key;
  for (key in iterated) keys.push(key);
};
require('./_iter-create')(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;
  do {
    if (that._i >= keys.length) return { value: undefined, done: true };
  } while (!((key = keys[that._i++]) in that._t));
  return { value: key, done: false };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

},{"./_an-object":166,"./_export":192,"./_iter-create":213}],372:[function(require,module,exports){
// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = require('./_object-gopd');
var $export = require('./_export');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

},{"./_an-object":166,"./_export":192,"./_object-gopd":233}],373:[function(require,module,exports){
// 26.1.8 Reflect.getPrototypeOf(target)
var $export = require('./_export');
var getProto = require('./_object-gpo');
var anObject = require('./_an-object');

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

},{"./_an-object":166,"./_export":192,"./_object-gpo":237}],374:[function(require,module,exports){
// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var isObject = require('./_is-object');
var anObject = require('./_an-object');

function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value')
    ? desc.value
    : desc.get !== undefined
      ? desc.get.call(receiver)
      : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', { get: get });

},{"./_an-object":166,"./_export":192,"./_has":200,"./_is-object":210,"./_object-gopd":233,"./_object-gpo":237}],375:[function(require,module,exports){
// 26.1.9 Reflect.has(target, propertyKey)
var $export = require('./_export');

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

},{"./_export":192}],376:[function(require,module,exports){
// 26.1.10 Reflect.isExtensible(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $isExtensible = Object.isExtensible;

$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

},{"./_an-object":166,"./_export":192}],377:[function(require,module,exports){
// 26.1.11 Reflect.ownKeys(target)
var $export = require('./_export');

$export($export.S, 'Reflect', { ownKeys: require('./_own-keys') });

},{"./_export":192,"./_own-keys":243}],378:[function(require,module,exports){
// 26.1.12 Reflect.preventExtensions(target)
var $export = require('./_export');
var anObject = require('./_an-object');
var $preventExtensions = Object.preventExtensions;

$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_an-object":166,"./_export":192}],379:[function(require,module,exports){
// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = require('./_export');
var setProto = require('./_set-proto');

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);
    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

},{"./_export":192,"./_set-proto":255}],380:[function(require,module,exports){
// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = require('./_object-dp');
var gOPD = require('./_object-gopd');
var getPrototypeOf = require('./_object-gpo');
var has = require('./_has');
var $export = require('./_export');
var createDesc = require('./_property-desc');
var anObject = require('./_an-object');
var isObject = require('./_is-object');

function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;
  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }
    ownDesc = createDesc(0);
  }
  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;
    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);
    existingDescriptor.value = V;
    dP.f(receiver, propertyKey, existingDescriptor);
    return true;
  }
  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', { set: set });

},{"./_an-object":166,"./_export":192,"./_has":200,"./_is-object":210,"./_object-dp":230,"./_object-gopd":233,"./_object-gpo":237,"./_property-desc":248}],381:[function(require,module,exports){
var global = require('./_global');
var inheritIfRequired = require('./_inherit-if-required');
var dP = require('./_object-dp').f;
var gOPN = require('./_object-gopn').f;
var isRegExp = require('./_is-regexp');
var $flags = require('./_flags');
var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;
// "new" creates a new object, old webkit buggy here
var CORRECT_NEW = new $RegExp(re1) !== re1;

if (require('./_descriptors') && (!CORRECT_NEW || require('./_fails')(function () {
  re2[require('./_wks')('match')] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p
      : inheritIfRequired(CORRECT_NEW
        ? new Base(piRE && !fiU ? p.source : p, f)
        : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f)
      , tiRE ? this : proto, $RegExp);
  };
  var proxy = function (key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function () { return Base[key]; },
      set: function (it) { Base[key] = it; }
    });
  };
  for (var keys = gOPN(Base), i = 0; keys.length > i;) proxy(keys[i++]);
  proto.constructor = $RegExp;
  $RegExp.prototype = proto;
  require('./_redefine')(global, 'RegExp', $RegExp);
}

require('./_set-species')('RegExp');

},{"./_descriptors":188,"./_fails":194,"./_flags":196,"./_global":199,"./_inherit-if-required":204,"./_is-regexp":211,"./_object-dp":230,"./_object-gopn":235,"./_redefine":250,"./_set-species":256,"./_wks":285}],382:[function(require,module,exports){
// 21.2.5.3 get RegExp.prototype.flags()
if (require('./_descriptors') && /./g.flags != 'g') require('./_object-dp').f(RegExp.prototype, 'flags', {
  configurable: true,
  get: require('./_flags')
});

},{"./_descriptors":188,"./_flags":196,"./_object-dp":230}],383:[function(require,module,exports){
// @@match logic
require('./_fix-re-wks')('match', 1, function (defined, MATCH, $match) {
  // 21.1.3.11 String.prototype.match(regexp)
  return [function match(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, $match];
});

},{"./_fix-re-wks":195}],384:[function(require,module,exports){
// @@replace logic
require('./_fix-re-wks')('replace', 2, function (defined, REPLACE, $replace) {
  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)
  return [function replace(searchValue, replaceValue) {
    'use strict';
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined
      ? fn.call(searchValue, O, replaceValue)
      : $replace.call(String(O), searchValue, replaceValue);
  }, $replace];
});

},{"./_fix-re-wks":195}],385:[function(require,module,exports){
// @@search logic
require('./_fix-re-wks')('search', 1, function (defined, SEARCH, $search) {
  // 21.1.3.15 String.prototype.search(regexp)
  return [function search(regexp) {
    'use strict';
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, $search];
});

},{"./_fix-re-wks":195}],386:[function(require,module,exports){
// @@split logic
require('./_fix-re-wks')('split', 2, function (defined, SPLIT, $split) {
  'use strict';
  var isRegExp = require('./_is-regexp');
  var _split = $split;
  var $push = [].push;
  var $SPLIT = 'split';
  var LENGTH = 'length';
  var LAST_INDEX = 'lastIndex';
  if (
    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||
    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||
    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||
    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||
    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||
    ''[$SPLIT](/.?/)[LENGTH]
  ) {
    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group
    // based on es5-shim implementation, need to rework it
    $split = function (separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return [];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) return _split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var separator2, match, lastIndex, lastLength, i;
      // Doesn't need flags gy, but they don't hurt
      if (!NPCG) separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\s)', flags);
      while (match = separatorCopy.exec(string)) {
        // `separatorCopy.lastIndex` is not reliable cross-browser
        lastIndex = match.index + match[0][LENGTH];
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG
          // eslint-disable-next-line no-loop-func
          if (!NPCG && match[LENGTH] > 1) match[0].replace(separator2, function () {
            for (i = 1; i < arguments[LENGTH] - 2; i++) if (arguments[i] === undefined) match[i] = undefined;
          });
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }
        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }
      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    };
  // Chakra, V8
  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    $split = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);
    };
  }
  // 21.1.3.17 String.prototype.split(separator, limit)
  return [function split(separator, limit) {
    var O = defined(this);
    var fn = separator == undefined ? undefined : separator[SPLIT];
    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);
  }, $split];
});

},{"./_fix-re-wks":195,"./_is-regexp":211}],387:[function(require,module,exports){
'use strict';
require('./es6.regexp.flags');
var anObject = require('./_an-object');
var $flags = require('./_flags');
var DESCRIPTORS = require('./_descriptors');
var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function (fn) {
  require('./_redefine')(RegExp.prototype, TO_STRING, fn, true);
};

// 21.2.5.14 RegExp.prototype.toString()
if (require('./_fails')(function () { return $toString.call({ source: 'a', flags: 'b' }) != '/a/b'; })) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/',
      'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  });
// FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

},{"./_an-object":166,"./_descriptors":188,"./_fails":194,"./_flags":196,"./_redefine":250,"./es6.regexp.flags":382}],388:[function(require,module,exports){
arguments[4][149][0].apply(exports,arguments)
},{"./_collection":181,"./_collection-strong":178,"./_validate-collection":282,"dup":149}],389:[function(require,module,exports){
'use strict';
// B.2.3.2 String.prototype.anchor(name)
require('./_string-html')('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

},{"./_string-html":264}],390:[function(require,module,exports){
'use strict';
// B.2.3.3 String.prototype.big()
require('./_string-html')('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

},{"./_string-html":264}],391:[function(require,module,exports){
'use strict';
// B.2.3.4 String.prototype.blink()
require('./_string-html')('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

},{"./_string-html":264}],392:[function(require,module,exports){
'use strict';
// B.2.3.5 String.prototype.bold()
require('./_string-html')('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

},{"./_string-html":264}],393:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $at = require('./_string-at')(false);
$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

},{"./_export":192,"./_string-at":262}],394:[function(require,module,exports){
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith
      ? $endsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});

},{"./_export":192,"./_fails-is-regexp":193,"./_string-context":263,"./_to-length":274}],395:[function(require,module,exports){
'use strict';
// B.2.3.6 String.prototype.fixed()
require('./_string-html')('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

},{"./_string-html":264}],396:[function(require,module,exports){
'use strict';
// B.2.3.7 String.prototype.fontcolor(color)
require('./_string-html')('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

},{"./_string-html":264}],397:[function(require,module,exports){
'use strict';
// B.2.3.8 String.prototype.fontsize(size)
require('./_string-html')('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

},{"./_string-html":264}],398:[function(require,module,exports){
var $export = require('./_export');
var toAbsoluteIndex = require('./_to-absolute-index');
var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;
    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)
      );
    } return res.join('');
  }
});

},{"./_export":192,"./_to-absolute-index":270}],399:[function(require,module,exports){
// 21.1.3.7 String.prototype.includes(searchString, position = 0)
'use strict';
var $export = require('./_export');
var context = require('./_string-context');
var INCLUDES = 'includes';

$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~context(this, searchString, INCLUDES)
      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

},{"./_export":192,"./_fails-is-regexp":193,"./_string-context":263}],400:[function(require,module,exports){
'use strict';
// B.2.3.9 String.prototype.italics()
require('./_string-html')('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

},{"./_string-html":264}],401:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"./_iter-define":214,"./_string-at":262,"dup":150}],402:[function(require,module,exports){
'use strict';
// B.2.3.10 String.prototype.link(url)
require('./_string-html')('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

},{"./_string-html":264}],403:[function(require,module,exports){
var $export = require('./_export');
var toIObject = require('./_to-iobject');
var toLength = require('./_to-length');

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;
    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    } return res.join('');
  }
});

},{"./_export":192,"./_to-iobject":273,"./_to-length":274}],404:[function(require,module,exports){
var $export = require('./_export');

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: require('./_string-repeat')
});

},{"./_export":192,"./_string-repeat":266}],405:[function(require,module,exports){
'use strict';
// B.2.3.11 String.prototype.small()
require('./_string-html')('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

},{"./_string-html":264}],406:[function(require,module,exports){
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])
'use strict';
var $export = require('./_export');
var toLength = require('./_to-length');
var context = require('./_string-context');
var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];

$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith
      ? $startsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});

},{"./_export":192,"./_fails-is-regexp":193,"./_string-context":263,"./_to-length":274}],407:[function(require,module,exports){
'use strict';
// B.2.3.12 String.prototype.strike()
require('./_string-html')('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

},{"./_string-html":264}],408:[function(require,module,exports){
'use strict';
// B.2.3.13 String.prototype.sub()
require('./_string-html')('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

},{"./_string-html":264}],409:[function(require,module,exports){
'use strict';
// B.2.3.14 String.prototype.sup()
require('./_string-html')('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

},{"./_string-html":264}],410:[function(require,module,exports){
'use strict';
// 21.1.3.25 String.prototype.trim()
require('./_string-trim')('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

},{"./_string-trim":267}],411:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"./_an-object":166,"./_descriptors":188,"./_enum-keys":191,"./_export":192,"./_fails":194,"./_global":199,"./_has":200,"./_hide":201,"./_is-array":208,"./_is-object":210,"./_library":218,"./_meta":224,"./_object-create":229,"./_object-dp":230,"./_object-gopd":233,"./_object-gopn":235,"./_object-gopn-ext":234,"./_object-gops":236,"./_object-keys":239,"./_object-pie":240,"./_property-desc":248,"./_redefine":250,"./_set-to-string-tag":257,"./_shared":259,"./_to-iobject":273,"./_to-primitive":276,"./_uid":280,"./_wks":285,"./_wks-define":283,"./_wks-ext":284,"dup":151}],412:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var $typed = require('./_typed');
var buffer = require('./_typed-buffer');
var anObject = require('./_an-object');
var toAbsoluteIndex = require('./_to-absolute-index');
var toLength = require('./_to-length');
var isObject = require('./_is-object');
var ArrayBuffer = require('./_global').ArrayBuffer;
var speciesConstructor = require('./_species-constructor');
var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';

$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), { ArrayBuffer: $ArrayBuffer });

$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});

$export($export.P + $export.U + $export.F * require('./_fails')(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix
    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var final = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(final - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;
    while (first < final) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    } return result;
  }
});

require('./_set-species')(ARRAY_BUFFER);

},{"./_an-object":166,"./_export":192,"./_fails":194,"./_global":199,"./_is-object":210,"./_set-species":256,"./_species-constructor":260,"./_to-absolute-index":270,"./_to-length":274,"./_typed":279,"./_typed-buffer":278}],413:[function(require,module,exports){
var $export = require('./_export');
$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {
  DataView: require('./_typed-buffer').DataView
});

},{"./_export":192,"./_typed":279,"./_typed-buffer":278}],414:[function(require,module,exports){
require('./_typed-array')('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],415:[function(require,module,exports){
require('./_typed-array')('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],416:[function(require,module,exports){
require('./_typed-array')('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],417:[function(require,module,exports){
require('./_typed-array')('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],418:[function(require,module,exports){
require('./_typed-array')('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],419:[function(require,module,exports){
require('./_typed-array')('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],420:[function(require,module,exports){
require('./_typed-array')('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],421:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

},{"./_typed-array":277}],422:[function(require,module,exports){
require('./_typed-array')('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

},{"./_typed-array":277}],423:[function(require,module,exports){
'use strict';
var each = require('./_array-methods')(0);
var redefine = require('./_redefine');
var meta = require('./_meta');
var assign = require('./_object-assign');
var weak = require('./_collection-weak');
var isObject = require('./_is-object');
var fails = require('./_fails');
var validate = require('./_validate-collection');
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var tmp = {};
var InternalMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
};

// 23.3 WeakMap Objects
var $WeakMap = module.exports = require('./_collection')(WEAK_MAP, wrapper, methods, weak, true, true);

// IE11 WeakMap frozen keys fix
if (fails(function () { return new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7; })) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();
        var result = this._f[key](a, b);
        return key == 'set' ? this : result;
      // store all the rest on native weakmap
      } return method.call(this, a, b);
    });
  });
}

},{"./_array-methods":171,"./_collection":181,"./_collection-weak":180,"./_fails":194,"./_is-object":210,"./_meta":224,"./_object-assign":228,"./_redefine":250,"./_validate-collection":282}],424:[function(require,module,exports){
'use strict';
var weak = require('./_collection-weak');
var validate = require('./_validate-collection');
var WEAK_SET = 'WeakSet';

// 23.4 WeakSet Objects
require('./_collection')(WEAK_SET, function (get) {
  return function WeakSet() { return get(this, arguments.length > 0 ? arguments[0] : undefined); };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

},{"./_collection":181,"./_collection-weak":180,"./_validate-collection":282}],425:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var aFunction = require('./_a-function');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

require('./_add-to-unscopables')('flatMap');

},{"./_a-function":162,"./_add-to-unscopables":164,"./_array-species-create":174,"./_export":192,"./_flatten-into-array":197,"./_to-length":274,"./_to-object":275}],426:[function(require,module,exports){
'use strict';
// https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatten
var $export = require('./_export');
var flattenIntoArray = require('./_flatten-into-array');
var toObject = require('./_to-object');
var toLength = require('./_to-length');
var toInteger = require('./_to-integer');
var arraySpeciesCreate = require('./_array-species-create');

$export($export.P, 'Array', {
  flatten: function flatten(/* depthArg = 1 */) {
    var depthArg = arguments[0];
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});

require('./_add-to-unscopables')('flatten');

},{"./_add-to-unscopables":164,"./_array-species-create":174,"./_export":192,"./_flatten-into-array":197,"./_to-integer":272,"./_to-length":274,"./_to-object":275}],427:[function(require,module,exports){
'use strict';
// https://github.com/tc39/Array.prototype.includes
var $export = require('./_export');
var $includes = require('./_array-includes')(true);

$export($export.P, 'Array', {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

require('./_add-to-unscopables')('includes');

},{"./_add-to-unscopables":164,"./_array-includes":170,"./_export":192}],428:[function(require,module,exports){
// https://github.com/rwaldron/tc39-notes/blob/master/es6/2014-09/sept-25.md#510-globalasap-for-enqueuing-a-microtask
var $export = require('./_export');
var microtask = require('./_microtask')();
var process = require('./_global').process;
var isNode = require('./_cof')(process) == 'process';

$export($export.G, {
  asap: function asap(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});

},{"./_cof":177,"./_export":192,"./_global":199,"./_microtask":226}],429:[function(require,module,exports){
// https://github.com/ljharb/proposal-is-error
var $export = require('./_export');
var cof = require('./_cof');

$export($export.S, 'Error', {
  isError: function isError(it) {
    return cof(it) === 'Error';
  }
});

},{"./_cof":177,"./_export":192}],430:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.G, { global: require('./_global') });

},{"./_export":192,"./_global":199}],431:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.from
require('./_set-collection-from')('Map');

},{"./_set-collection-from":253}],432:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-map.of
require('./_set-collection-of')('Map');

},{"./_set-collection-of":254}],433:[function(require,module,exports){
// https://github.com/DavidBruant/Map-Set.prototype.toJSON
var $export = require('./_export');

$export($export.P + $export.R, 'Map', { toJSON: require('./_collection-to-json')('Map') });

},{"./_collection-to-json":179,"./_export":192}],434:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', {
  clamp: function clamp(x, lower, upper) {
    return Math.min(upper, Math.max(lower, x));
  }
});

},{"./_export":192}],435:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { DEG_PER_RAD: Math.PI / 180 });

},{"./_export":192}],436:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var RAD_PER_DEG = 180 / Math.PI;

$export($export.S, 'Math', {
  degrees: function degrees(radians) {
    return radians * RAD_PER_DEG;
  }
});

},{"./_export":192}],437:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var scale = require('./_math-scale');
var fround = require('./_math-fround');

$export($export.S, 'Math', {
  fscale: function fscale(x, inLow, inHigh, outLow, outHigh) {
    return fround(scale(x, inLow, inHigh, outLow, outHigh));
  }
});

},{"./_export":192,"./_math-fround":220,"./_math-scale":222}],438:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  iaddh: function iaddh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 + (y1 >>> 0) + (($x0 & $y0 | ($x0 | $y0) & ~($x0 + $y0 >>> 0)) >>> 31) | 0;
  }
});

},{"./_export":192}],439:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  imulh: function imulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >> 16;
    var v1 = $v >> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >> 16);
  }
});

},{"./_export":192}],440:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  isubh: function isubh(x0, x1, y0, y1) {
    var $x0 = x0 >>> 0;
    var $x1 = x1 >>> 0;
    var $y0 = y0 >>> 0;
    return $x1 - (y1 >>> 0) - ((~$x0 & $y0 | ~($x0 ^ $y0) & $x0 - $y0 >>> 0) >>> 31) | 0;
  }
});

},{"./_export":192}],441:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { RAD_PER_DEG: 180 / Math.PI });

},{"./_export":192}],442:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');
var DEG_PER_RAD = Math.PI / 180;

$export($export.S, 'Math', {
  radians: function radians(degrees) {
    return degrees * DEG_PER_RAD;
  }
});

},{"./_export":192}],443:[function(require,module,exports){
// https://rwaldron.github.io/proposal-math-extensions/
var $export = require('./_export');

$export($export.S, 'Math', { scale: require('./_math-scale') });

},{"./_export":192,"./_math-scale":222}],444:[function(require,module,exports){
// http://jfbastien.github.io/papers/Math.signbit.html
var $export = require('./_export');

$export($export.S, 'Math', { signbit: function signbit(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) != x ? x : x == 0 ? 1 / x == Infinity : x > 0;
} });

},{"./_export":192}],445:[function(require,module,exports){
// https://gist.github.com/BrendanEich/4294d5c212a6d2254703
var $export = require('./_export');

$export($export.S, 'Math', {
  umulh: function umulh(u, v) {
    var UINT16 = 0xffff;
    var $u = +u;
    var $v = +v;
    var u0 = $u & UINT16;
    var v0 = $v & UINT16;
    var u1 = $u >>> 16;
    var v1 = $v >>> 16;
    var t = (u1 * v0 >>> 0) + (u0 * v0 >>> 16);
    return u1 * v1 + (t >>> 16) + ((u0 * v1 >>> 0) + (t & UINT16) >>> 16);
  }
});

},{"./_export":192}],446:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.2 Object.prototype.__defineGetter__(P, getter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineGetter__: function __defineGetter__(P, getter) {
    $defineProperty.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":162,"./_descriptors":188,"./_export":192,"./_object-dp":230,"./_object-forced-pam":232,"./_to-object":275}],447:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var aFunction = require('./_a-function');
var $defineProperty = require('./_object-dp');

// B.2.2.3 Object.prototype.__defineSetter__(P, setter)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __defineSetter__: function __defineSetter__(P, setter) {
    $defineProperty.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
  }
});

},{"./_a-function":162,"./_descriptors":188,"./_export":192,"./_object-dp":230,"./_object-forced-pam":232,"./_to-object":275}],448:[function(require,module,exports){
arguments[4][152][0].apply(exports,arguments)
},{"./_export":192,"./_object-to-array":242,"dup":152}],449:[function(require,module,exports){
// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = require('./_export');
var ownKeys = require('./_own-keys');
var toIObject = require('./_to-iobject');
var gOPD = require('./_object-gopd');
var createProperty = require('./_create-property');

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;
    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }
    return result;
  }
});

},{"./_create-property":183,"./_export":192,"./_object-gopd":233,"./_own-keys":243,"./_to-iobject":273}],450:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.4 Object.prototype.__lookupGetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupGetter__: function __lookupGetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.get;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":188,"./_export":192,"./_object-forced-pam":232,"./_object-gopd":233,"./_object-gpo":237,"./_to-object":275,"./_to-primitive":276}],451:[function(require,module,exports){
'use strict';
var $export = require('./_export');
var toObject = require('./_to-object');
var toPrimitive = require('./_to-primitive');
var getPrototypeOf = require('./_object-gpo');
var getOwnPropertyDescriptor = require('./_object-gopd').f;

// B.2.2.5 Object.prototype.__lookupSetter__(P)
require('./_descriptors') && $export($export.P + require('./_object-forced-pam'), 'Object', {
  __lookupSetter__: function __lookupSetter__(P) {
    var O = toObject(this);
    var K = toPrimitive(P, true);
    var D;
    do {
      if (D = getOwnPropertyDescriptor(O, K)) return D.set;
    } while (O = getPrototypeOf(O));
  }
});

},{"./_descriptors":188,"./_export":192,"./_object-forced-pam":232,"./_object-gopd":233,"./_object-gpo":237,"./_to-object":275,"./_to-primitive":276}],452:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"./_export":192,"./_object-to-array":242,"dup":153}],453:[function(require,module,exports){
'use strict';
// https://github.com/zenparsing/es-observable
var $export = require('./_export');
var global = require('./_global');
var core = require('./_core');
var microtask = require('./_microtask')();
var OBSERVABLE = require('./_wks')('observable');
var aFunction = require('./_a-function');
var anObject = require('./_an-object');
var anInstance = require('./_an-instance');
var redefineAll = require('./_redefine-all');
var hide = require('./_hide');
var forOf = require('./_for-of');
var RETURN = forOf.RETURN;

var getMethod = function (fn) {
  return fn == null ? undefined : aFunction(fn);
};

var cleanupSubscription = function (subscription) {
  var cleanup = subscription._c;
  if (cleanup) {
    subscription._c = undefined;
    cleanup();
  }
};

var subscriptionClosed = function (subscription) {
  return subscription._o === undefined;
};

var closeSubscription = function (subscription) {
  if (!subscriptionClosed(subscription)) {
    subscription._o = undefined;
    cleanupSubscription(subscription);
  }
};

var Subscription = function (observer, subscriber) {
  anObject(observer);
  this._c = undefined;
  this._o = observer;
  observer = new SubscriptionObserver(this);
  try {
    var cleanup = subscriber(observer);
    var subscription = cleanup;
    if (cleanup != null) {
      if (typeof cleanup.unsubscribe === 'function') cleanup = function () { subscription.unsubscribe(); };
      else aFunction(cleanup);
      this._c = cleanup;
    }
  } catch (e) {
    observer.error(e);
    return;
  } if (subscriptionClosed(this)) cleanupSubscription(this);
};

Subscription.prototype = redefineAll({}, {
  unsubscribe: function unsubscribe() { closeSubscription(this); }
});

var SubscriptionObserver = function (subscription) {
  this._s = subscription;
};

SubscriptionObserver.prototype = redefineAll({}, {
  next: function next(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      try {
        var m = getMethod(observer.next);
        if (m) return m.call(observer, value);
      } catch (e) {
        try {
          closeSubscription(subscription);
        } finally {
          throw e;
        }
      }
    }
  },
  error: function error(value) {
    var subscription = this._s;
    if (subscriptionClosed(subscription)) throw value;
    var observer = subscription._o;
    subscription._o = undefined;
    try {
      var m = getMethod(observer.error);
      if (!m) throw value;
      value = m.call(observer, value);
    } catch (e) {
      try {
        cleanupSubscription(subscription);
      } finally {
        throw e;
      }
    } cleanupSubscription(subscription);
    return value;
  },
  complete: function complete(value) {
    var subscription = this._s;
    if (!subscriptionClosed(subscription)) {
      var observer = subscription._o;
      subscription._o = undefined;
      try {
        var m = getMethod(observer.complete);
        value = m ? m.call(observer, value) : undefined;
      } catch (e) {
        try {
          cleanupSubscription(subscription);
        } finally {
          throw e;
        }
      } cleanupSubscription(subscription);
      return value;
    }
  }
});

var $Observable = function Observable(subscriber) {
  anInstance(this, $Observable, 'Observable', '_f')._f = aFunction(subscriber);
};

redefineAll($Observable.prototype, {
  subscribe: function subscribe(observer) {
    return new Subscription(observer, this._f);
  },
  forEach: function forEach(fn) {
    var that = this;
    return new (core.Promise || global.Promise)(function (resolve, reject) {
      aFunction(fn);
      var subscription = that.subscribe({
        next: function (value) {
          try {
            return fn(value);
          } catch (e) {
            reject(e);
            subscription.unsubscribe();
          }
        },
        error: reject,
        complete: resolve
      });
    });
  }
});

redefineAll($Observable, {
  from: function from(x) {
    var C = typeof this === 'function' ? this : $Observable;
    var method = getMethod(anObject(x)[OBSERVABLE]);
    if (method) {
      var observable = anObject(method.call(x));
      return observable.constructor === C ? observable : new C(function (observer) {
        return observable.subscribe(observer);
      });
    }
    return new C(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          try {
            if (forOf(x, false, function (it) {
              observer.next(it);
              if (done) return RETURN;
            }) === RETURN) return;
          } catch (e) {
            if (done) throw e;
            observer.error(e);
            return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  },
  of: function of() {
    for (var i = 0, l = arguments.length, items = new Array(l); i < l;) items[i] = arguments[i++];
    return new (typeof this === 'function' ? this : $Observable)(function (observer) {
      var done = false;
      microtask(function () {
        if (!done) {
          for (var j = 0; j < items.length; ++j) {
            observer.next(items[j]);
            if (done) return;
          } observer.complete();
        }
      });
      return function () { done = true; };
    });
  }
});

hide($Observable.prototype, OBSERVABLE, function () { return this; });

$export($export.G, { Observable: $Observable });

require('./_set-species')('Observable');

},{"./_a-function":162,"./_an-instance":165,"./_an-object":166,"./_core":182,"./_export":192,"./_for-of":198,"./_global":199,"./_hide":201,"./_microtask":226,"./_redefine-all":249,"./_set-species":256,"./_wks":285}],454:[function(require,module,exports){
arguments[4][154][0].apply(exports,arguments)
},{"./_core":182,"./_export":192,"./_global":199,"./_promise-resolve":247,"./_species-constructor":260,"dup":154}],455:[function(require,module,exports){
arguments[4][155][0].apply(exports,arguments)
},{"./_export":192,"./_new-promise-capability":227,"./_perform":246,"dup":155}],456:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var ordinaryDefineOwnMetadata = metadata.set;

metadata.exp({ defineMetadata: function defineMetadata(metadataKey, metadataValue, target, targetKey) {
  ordinaryDefineOwnMetadata(metadataKey, metadataValue, anObject(target), toMetaKey(targetKey));
} });

},{"./_an-object":166,"./_metadata":225}],457:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var toMetaKey = metadata.key;
var getOrCreateMetadataMap = metadata.map;
var store = metadata.store;

metadata.exp({ deleteMetadata: function deleteMetadata(metadataKey, target /* , targetKey */) {
  var targetKey = arguments.length < 3 ? undefined : toMetaKey(arguments[2]);
  var metadataMap = getOrCreateMetadataMap(anObject(target), targetKey, false);
  if (metadataMap === undefined || !metadataMap['delete'](metadataKey)) return false;
  if (metadataMap.size) return true;
  var targetMetadata = store.get(target);
  targetMetadata['delete'](targetKey);
  return !!targetMetadata.size || store['delete'](target);
} });

},{"./_an-object":166,"./_metadata":225}],458:[function(require,module,exports){
var Set = require('./es6.set');
var from = require('./_array-from-iterable');
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

var ordinaryMetadataKeys = function (O, P) {
  var oKeys = ordinaryOwnMetadataKeys(O, P);
  var parent = getPrototypeOf(O);
  if (parent === null) return oKeys;
  var pKeys = ordinaryMetadataKeys(parent, P);
  return pKeys.length ? oKeys.length ? from(new Set(oKeys.concat(pKeys))) : pKeys : oKeys;
};

metadata.exp({ getMetadataKeys: function getMetadataKeys(target /* , targetKey */) {
  return ordinaryMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":166,"./_array-from-iterable":169,"./_metadata":225,"./_object-gpo":237,"./es6.set":388}],459:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

var ordinaryGetMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return ordinaryGetOwnMetadata(MetadataKey, O, P);
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryGetMetadata(MetadataKey, parent, P) : undefined;
};

metadata.exp({ getMetadata: function getMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":166,"./_metadata":225,"./_object-gpo":237}],460:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryOwnMetadataKeys = metadata.keys;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadataKeys: function getOwnMetadataKeys(target /* , targetKey */) {
  return ordinaryOwnMetadataKeys(anObject(target), arguments.length < 2 ? undefined : toMetaKey(arguments[1]));
} });

},{"./_an-object":166,"./_metadata":225}],461:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryGetOwnMetadata = metadata.get;
var toMetaKey = metadata.key;

metadata.exp({ getOwnMetadata: function getOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryGetOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":166,"./_metadata":225}],462:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var getPrototypeOf = require('./_object-gpo');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

var ordinaryHasMetadata = function (MetadataKey, O, P) {
  var hasOwn = ordinaryHasOwnMetadata(MetadataKey, O, P);
  if (hasOwn) return true;
  var parent = getPrototypeOf(O);
  return parent !== null ? ordinaryHasMetadata(MetadataKey, parent, P) : false;
};

metadata.exp({ hasMetadata: function hasMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasMetadata(metadataKey, anObject(target), arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":166,"./_metadata":225,"./_object-gpo":237}],463:[function(require,module,exports){
var metadata = require('./_metadata');
var anObject = require('./_an-object');
var ordinaryHasOwnMetadata = metadata.has;
var toMetaKey = metadata.key;

metadata.exp({ hasOwnMetadata: function hasOwnMetadata(metadataKey, target /* , targetKey */) {
  return ordinaryHasOwnMetadata(metadataKey, anObject(target)
    , arguments.length < 3 ? undefined : toMetaKey(arguments[2]));
} });

},{"./_an-object":166,"./_metadata":225}],464:[function(require,module,exports){
var $metadata = require('./_metadata');
var anObject = require('./_an-object');
var aFunction = require('./_a-function');
var toMetaKey = $metadata.key;
var ordinaryDefineOwnMetadata = $metadata.set;

$metadata.exp({ metadata: function metadata(metadataKey, metadataValue) {
  return function decorator(target, targetKey) {
    ordinaryDefineOwnMetadata(
      metadataKey, metadataValue,
      (targetKey !== undefined ? anObject : aFunction)(target),
      toMetaKey(targetKey)
    );
  };
} });

},{"./_a-function":162,"./_an-object":166,"./_metadata":225}],465:[function(require,module,exports){
arguments[4][156][0].apply(exports,arguments)
},{"./_set-collection-from":253,"dup":156}],466:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"./_set-collection-of":254,"dup":157}],467:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"./_collection-to-json":179,"./_export":192,"dup":158}],468:[function(require,module,exports){
'use strict';
// https://github.com/mathiasbynens/String.prototype.at
var $export = require('./_export');
var $at = require('./_string-at')(true);

$export($export.P, 'String', {
  at: function at(pos) {
    return $at(this, pos);
  }
});

},{"./_export":192,"./_string-at":262}],469:[function(require,module,exports){
'use strict';
// https://tc39.github.io/String.prototype.matchAll/
var $export = require('./_export');
var defined = require('./_defined');
var toLength = require('./_to-length');
var isRegExp = require('./_is-regexp');
var getFlags = require('./_flags');
var RegExpProto = RegExp.prototype;

var $RegExpStringIterator = function (regexp, string) {
  this._r = regexp;
  this._s = string;
};

require('./_iter-create')($RegExpStringIterator, 'RegExp String', function next() {
  var match = this._r.exec(this._s);
  return { value: match, done: match === null };
});

$export($export.P, 'String', {
  matchAll: function matchAll(regexp) {
    defined(this);
    if (!isRegExp(regexp)) throw TypeError(regexp + ' is not a regexp!');
    var S = String(this);
    var flags = 'flags' in RegExpProto ? String(regexp.flags) : getFlags.call(regexp);
    var rx = new RegExp(regexp.source, ~flags.indexOf('g') ? flags : 'g' + flags);
    rx.lastIndex = toLength(regexp.lastIndex);
    return new $RegExpStringIterator(rx, S);
  }
});

},{"./_defined":187,"./_export":192,"./_flags":196,"./_is-regexp":211,"./_iter-create":213,"./_to-length":274}],470:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

},{"./_export":192,"./_string-pad":265,"./_user-agent":281}],471:[function(require,module,exports){
'use strict';
// https://github.com/tc39/proposal-string-pad-start-end
var $export = require('./_export');
var $pad = require('./_string-pad');
var userAgent = require('./_user-agent');

// https://github.com/zloirock/core-js/issues/280
$export($export.P + $export.F * /Version\/10\.\d+(\.\d+)? Safari\//.test(userAgent), 'String', {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

},{"./_export":192,"./_string-pad":265,"./_user-agent":281}],472:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

},{"./_string-trim":267}],473:[function(require,module,exports){
'use strict';
// https://github.com/sebmarkbage/ecmascript-string-left-right-trim
require('./_string-trim')('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

},{"./_string-trim":267}],474:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"./_wks-define":283,"dup":159}],475:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"./_wks-define":283,"dup":160}],476:[function(require,module,exports){
// https://github.com/tc39/proposal-global
var $export = require('./_export');

$export($export.S, 'System', { global: require('./_global') });

},{"./_export":192,"./_global":199}],477:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.from
require('./_set-collection-from')('WeakMap');

},{"./_set-collection-from":253}],478:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakmap.of
require('./_set-collection-of')('WeakMap');

},{"./_set-collection-of":254}],479:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.from
require('./_set-collection-from')('WeakSet');

},{"./_set-collection-from":253}],480:[function(require,module,exports){
// https://tc39.github.io/proposal-setmap-offrom/#sec-weakset.of
require('./_set-collection-of')('WeakSet');

},{"./_set-collection-of":254}],481:[function(require,module,exports){
var $iterators = require('./es6.array.iterator');
var getKeys = require('./_object-keys');
var redefine = require('./_redefine');
var global = require('./_global');
var hide = require('./_hide');
var Iterators = require('./_iterators');
var wks = require('./_wks');
var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;

var DOMIterables = {
  CSSRuleList: true, // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true, // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true, // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;
  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);
  }
}

},{"./_global":199,"./_hide":201,"./_iterators":217,"./_object-keys":239,"./_redefine":250,"./_wks":285,"./es6.array.iterator":298}],482:[function(require,module,exports){
var $export = require('./_export');
var $task = require('./_task');
$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

},{"./_export":192,"./_task":269}],483:[function(require,module,exports){
// ie9- setTimeout & setInterval additional parameters fix
var global = require('./_global');
var $export = require('./_export');
var userAgent = require('./_user-agent');
var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check
var wrap = function (set) {
  return function (fn, time /* , ...args */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};
$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

},{"./_export":192,"./_global":199,"./_user-agent":281}],484:[function(require,module,exports){
require('./modules/es6.symbol');
require('./modules/es6.object.create');
require('./modules/es6.object.define-property');
require('./modules/es6.object.define-properties');
require('./modules/es6.object.get-own-property-descriptor');
require('./modules/es6.object.get-prototype-of');
require('./modules/es6.object.keys');
require('./modules/es6.object.get-own-property-names');
require('./modules/es6.object.freeze');
require('./modules/es6.object.seal');
require('./modules/es6.object.prevent-extensions');
require('./modules/es6.object.is-frozen');
require('./modules/es6.object.is-sealed');
require('./modules/es6.object.is-extensible');
require('./modules/es6.object.assign');
require('./modules/es6.object.is');
require('./modules/es6.object.set-prototype-of');
require('./modules/es6.object.to-string');
require('./modules/es6.function.bind');
require('./modules/es6.function.name');
require('./modules/es6.function.has-instance');
require('./modules/es6.parse-int');
require('./modules/es6.parse-float');
require('./modules/es6.number.constructor');
require('./modules/es6.number.to-fixed');
require('./modules/es6.number.to-precision');
require('./modules/es6.number.epsilon');
require('./modules/es6.number.is-finite');
require('./modules/es6.number.is-integer');
require('./modules/es6.number.is-nan');
require('./modules/es6.number.is-safe-integer');
require('./modules/es6.number.max-safe-integer');
require('./modules/es6.number.min-safe-integer');
require('./modules/es6.number.parse-float');
require('./modules/es6.number.parse-int');
require('./modules/es6.math.acosh');
require('./modules/es6.math.asinh');
require('./modules/es6.math.atanh');
require('./modules/es6.math.cbrt');
require('./modules/es6.math.clz32');
require('./modules/es6.math.cosh');
require('./modules/es6.math.expm1');
require('./modules/es6.math.fround');
require('./modules/es6.math.hypot');
require('./modules/es6.math.imul');
require('./modules/es6.math.log10');
require('./modules/es6.math.log1p');
require('./modules/es6.math.log2');
require('./modules/es6.math.sign');
require('./modules/es6.math.sinh');
require('./modules/es6.math.tanh');
require('./modules/es6.math.trunc');
require('./modules/es6.string.from-code-point');
require('./modules/es6.string.raw');
require('./modules/es6.string.trim');
require('./modules/es6.string.iterator');
require('./modules/es6.string.code-point-at');
require('./modules/es6.string.ends-with');
require('./modules/es6.string.includes');
require('./modules/es6.string.repeat');
require('./modules/es6.string.starts-with');
require('./modules/es6.string.anchor');
require('./modules/es6.string.big');
require('./modules/es6.string.blink');
require('./modules/es6.string.bold');
require('./modules/es6.string.fixed');
require('./modules/es6.string.fontcolor');
require('./modules/es6.string.fontsize');
require('./modules/es6.string.italics');
require('./modules/es6.string.link');
require('./modules/es6.string.small');
require('./modules/es6.string.strike');
require('./modules/es6.string.sub');
require('./modules/es6.string.sup');
require('./modules/es6.date.now');
require('./modules/es6.date.to-json');
require('./modules/es6.date.to-iso-string');
require('./modules/es6.date.to-string');
require('./modules/es6.date.to-primitive');
require('./modules/es6.array.is-array');
require('./modules/es6.array.from');
require('./modules/es6.array.of');
require('./modules/es6.array.join');
require('./modules/es6.array.slice');
require('./modules/es6.array.sort');
require('./modules/es6.array.for-each');
require('./modules/es6.array.map');
require('./modules/es6.array.filter');
require('./modules/es6.array.some');
require('./modules/es6.array.every');
require('./modules/es6.array.reduce');
require('./modules/es6.array.reduce-right');
require('./modules/es6.array.index-of');
require('./modules/es6.array.last-index-of');
require('./modules/es6.array.copy-within');
require('./modules/es6.array.fill');
require('./modules/es6.array.find');
require('./modules/es6.array.find-index');
require('./modules/es6.array.species');
require('./modules/es6.array.iterator');
require('./modules/es6.regexp.constructor');
require('./modules/es6.regexp.to-string');
require('./modules/es6.regexp.flags');
require('./modules/es6.regexp.match');
require('./modules/es6.regexp.replace');
require('./modules/es6.regexp.search');
require('./modules/es6.regexp.split');
require('./modules/es6.promise');
require('./modules/es6.map');
require('./modules/es6.set');
require('./modules/es6.weak-map');
require('./modules/es6.weak-set');
require('./modules/es6.typed.array-buffer');
require('./modules/es6.typed.data-view');
require('./modules/es6.typed.int8-array');
require('./modules/es6.typed.uint8-array');
require('./modules/es6.typed.uint8-clamped-array');
require('./modules/es6.typed.int16-array');
require('./modules/es6.typed.uint16-array');
require('./modules/es6.typed.int32-array');
require('./modules/es6.typed.uint32-array');
require('./modules/es6.typed.float32-array');
require('./modules/es6.typed.float64-array');
require('./modules/es6.reflect.apply');
require('./modules/es6.reflect.construct');
require('./modules/es6.reflect.define-property');
require('./modules/es6.reflect.delete-property');
require('./modules/es6.reflect.enumerate');
require('./modules/es6.reflect.get');
require('./modules/es6.reflect.get-own-property-descriptor');
require('./modules/es6.reflect.get-prototype-of');
require('./modules/es6.reflect.has');
require('./modules/es6.reflect.is-extensible');
require('./modules/es6.reflect.own-keys');
require('./modules/es6.reflect.prevent-extensions');
require('./modules/es6.reflect.set');
require('./modules/es6.reflect.set-prototype-of');
require('./modules/es7.array.includes');
require('./modules/es7.array.flat-map');
require('./modules/es7.array.flatten');
require('./modules/es7.string.at');
require('./modules/es7.string.pad-start');
require('./modules/es7.string.pad-end');
require('./modules/es7.string.trim-left');
require('./modules/es7.string.trim-right');
require('./modules/es7.string.match-all');
require('./modules/es7.symbol.async-iterator');
require('./modules/es7.symbol.observable');
require('./modules/es7.object.get-own-property-descriptors');
require('./modules/es7.object.values');
require('./modules/es7.object.entries');
require('./modules/es7.object.define-getter');
require('./modules/es7.object.define-setter');
require('./modules/es7.object.lookup-getter');
require('./modules/es7.object.lookup-setter');
require('./modules/es7.map.to-json');
require('./modules/es7.set.to-json');
require('./modules/es7.map.of');
require('./modules/es7.set.of');
require('./modules/es7.weak-map.of');
require('./modules/es7.weak-set.of');
require('./modules/es7.map.from');
require('./modules/es7.set.from');
require('./modules/es7.weak-map.from');
require('./modules/es7.weak-set.from');
require('./modules/es7.global');
require('./modules/es7.system.global');
require('./modules/es7.error.is-error');
require('./modules/es7.math.clamp');
require('./modules/es7.math.deg-per-rad');
require('./modules/es7.math.degrees');
require('./modules/es7.math.fscale');
require('./modules/es7.math.iaddh');
require('./modules/es7.math.isubh');
require('./modules/es7.math.imulh');
require('./modules/es7.math.rad-per-deg');
require('./modules/es7.math.radians');
require('./modules/es7.math.scale');
require('./modules/es7.math.umulh');
require('./modules/es7.math.signbit');
require('./modules/es7.promise.finally');
require('./modules/es7.promise.try');
require('./modules/es7.reflect.define-metadata');
require('./modules/es7.reflect.delete-metadata');
require('./modules/es7.reflect.get-metadata');
require('./modules/es7.reflect.get-metadata-keys');
require('./modules/es7.reflect.get-own-metadata');
require('./modules/es7.reflect.get-own-metadata-keys');
require('./modules/es7.reflect.has-metadata');
require('./modules/es7.reflect.has-own-metadata');
require('./modules/es7.reflect.metadata');
require('./modules/es7.asap');
require('./modules/es7.observable');
require('./modules/web.timers');
require('./modules/web.immediate');
require('./modules/web.dom.iterable');
module.exports = require('./modules/_core');

},{"./modules/_core":182,"./modules/es6.array.copy-within":288,"./modules/es6.array.every":289,"./modules/es6.array.fill":290,"./modules/es6.array.filter":291,"./modules/es6.array.find":293,"./modules/es6.array.find-index":292,"./modules/es6.array.for-each":294,"./modules/es6.array.from":295,"./modules/es6.array.index-of":296,"./modules/es6.array.is-array":297,"./modules/es6.array.iterator":298,"./modules/es6.array.join":299,"./modules/es6.array.last-index-of":300,"./modules/es6.array.map":301,"./modules/es6.array.of":302,"./modules/es6.array.reduce":304,"./modules/es6.array.reduce-right":303,"./modules/es6.array.slice":305,"./modules/es6.array.some":306,"./modules/es6.array.sort":307,"./modules/es6.array.species":308,"./modules/es6.date.now":309,"./modules/es6.date.to-iso-string":310,"./modules/es6.date.to-json":311,"./modules/es6.date.to-primitive":312,"./modules/es6.date.to-string":313,"./modules/es6.function.bind":314,"./modules/es6.function.has-instance":315,"./modules/es6.function.name":316,"./modules/es6.map":317,"./modules/es6.math.acosh":318,"./modules/es6.math.asinh":319,"./modules/es6.math.atanh":320,"./modules/es6.math.cbrt":321,"./modules/es6.math.clz32":322,"./modules/es6.math.cosh":323,"./modules/es6.math.expm1":324,"./modules/es6.math.fround":325,"./modules/es6.math.hypot":326,"./modules/es6.math.imul":327,"./modules/es6.math.log10":328,"./modules/es6.math.log1p":329,"./modules/es6.math.log2":330,"./modules/es6.math.sign":331,"./modules/es6.math.sinh":332,"./modules/es6.math.tanh":333,"./modules/es6.math.trunc":334,"./modules/es6.number.constructor":335,"./modules/es6.number.epsilon":336,"./modules/es6.number.is-finite":337,"./modules/es6.number.is-integer":338,"./modules/es6.number.is-nan":339,"./modules/es6.number.is-safe-integer":340,"./modules/es6.number.max-safe-integer":341,"./modules/es6.number.min-safe-integer":342,"./modules/es6.number.parse-float":343,"./modules/es6.number.parse-int":344,"./modules/es6.number.to-fixed":345,"./modules/es6.number.to-precision":346,"./modules/es6.object.assign":347,"./modules/es6.object.create":348,"./modules/es6.object.define-properties":349,"./modules/es6.object.define-property":350,"./modules/es6.object.freeze":351,"./modules/es6.object.get-own-property-descriptor":352,"./modules/es6.object.get-own-property-names":353,"./modules/es6.object.get-prototype-of":354,"./modules/es6.object.is":358,"./modules/es6.object.is-extensible":355,"./modules/es6.object.is-frozen":356,"./modules/es6.object.is-sealed":357,"./modules/es6.object.keys":359,"./modules/es6.object.prevent-extensions":360,"./modules/es6.object.seal":361,"./modules/es6.object.set-prototype-of":362,"./modules/es6.object.to-string":363,"./modules/es6.parse-float":364,"./modules/es6.parse-int":365,"./modules/es6.promise":366,"./modules/es6.reflect.apply":367,"./modules/es6.reflect.construct":368,"./modules/es6.reflect.define-property":369,"./modules/es6.reflect.delete-property":370,"./modules/es6.reflect.enumerate":371,"./modules/es6.reflect.get":374,"./modules/es6.reflect.get-own-property-descriptor":372,"./modules/es6.reflect.get-prototype-of":373,"./modules/es6.reflect.has":375,"./modules/es6.reflect.is-extensible":376,"./modules/es6.reflect.own-keys":377,"./modules/es6.reflect.prevent-extensions":378,"./modules/es6.reflect.set":380,"./modules/es6.reflect.set-prototype-of":379,"./modules/es6.regexp.constructor":381,"./modules/es6.regexp.flags":382,"./modules/es6.regexp.match":383,"./modules/es6.regexp.replace":384,"./modules/es6.regexp.search":385,"./modules/es6.regexp.split":386,"./modules/es6.regexp.to-string":387,"./modules/es6.set":388,"./modules/es6.string.anchor":389,"./modules/es6.string.big":390,"./modules/es6.string.blink":391,"./modules/es6.string.bold":392,"./modules/es6.string.code-point-at":393,"./modules/es6.string.ends-with":394,"./modules/es6.string.fixed":395,"./modules/es6.string.fontcolor":396,"./modules/es6.string.fontsize":397,"./modules/es6.string.from-code-point":398,"./modules/es6.string.includes":399,"./modules/es6.string.italics":400,"./modules/es6.string.iterator":401,"./modules/es6.string.link":402,"./modules/es6.string.raw":403,"./modules/es6.string.repeat":404,"./modules/es6.string.small":405,"./modules/es6.string.starts-with":406,"./modules/es6.string.strike":407,"./modules/es6.string.sub":408,"./modules/es6.string.sup":409,"./modules/es6.string.trim":410,"./modules/es6.symbol":411,"./modules/es6.typed.array-buffer":412,"./modules/es6.typed.data-view":413,"./modules/es6.typed.float32-array":414,"./modules/es6.typed.float64-array":415,"./modules/es6.typed.int16-array":416,"./modules/es6.typed.int32-array":417,"./modules/es6.typed.int8-array":418,"./modules/es6.typed.uint16-array":419,"./modules/es6.typed.uint32-array":420,"./modules/es6.typed.uint8-array":421,"./modules/es6.typed.uint8-clamped-array":422,"./modules/es6.weak-map":423,"./modules/es6.weak-set":424,"./modules/es7.array.flat-map":425,"./modules/es7.array.flatten":426,"./modules/es7.array.includes":427,"./modules/es7.asap":428,"./modules/es7.error.is-error":429,"./modules/es7.global":430,"./modules/es7.map.from":431,"./modules/es7.map.of":432,"./modules/es7.map.to-json":433,"./modules/es7.math.clamp":434,"./modules/es7.math.deg-per-rad":435,"./modules/es7.math.degrees":436,"./modules/es7.math.fscale":437,"./modules/es7.math.iaddh":438,"./modules/es7.math.imulh":439,"./modules/es7.math.isubh":440,"./modules/es7.math.rad-per-deg":441,"./modules/es7.math.radians":442,"./modules/es7.math.scale":443,"./modules/es7.math.signbit":444,"./modules/es7.math.umulh":445,"./modules/es7.object.define-getter":446,"./modules/es7.object.define-setter":447,"./modules/es7.object.entries":448,"./modules/es7.object.get-own-property-descriptors":449,"./modules/es7.object.lookup-getter":450,"./modules/es7.object.lookup-setter":451,"./modules/es7.object.values":452,"./modules/es7.observable":453,"./modules/es7.promise.finally":454,"./modules/es7.promise.try":455,"./modules/es7.reflect.define-metadata":456,"./modules/es7.reflect.delete-metadata":457,"./modules/es7.reflect.get-metadata":459,"./modules/es7.reflect.get-metadata-keys":458,"./modules/es7.reflect.get-own-metadata":461,"./modules/es7.reflect.get-own-metadata-keys":460,"./modules/es7.reflect.has-metadata":462,"./modules/es7.reflect.has-own-metadata":463,"./modules/es7.reflect.metadata":464,"./modules/es7.set.from":465,"./modules/es7.set.of":466,"./modules/es7.set.to-json":467,"./modules/es7.string.at":468,"./modules/es7.string.match-all":469,"./modules/es7.string.pad-end":470,"./modules/es7.string.pad-start":471,"./modules/es7.string.trim-left":472,"./modules/es7.string.trim-right":473,"./modules/es7.symbol.async-iterator":474,"./modules/es7.symbol.observable":475,"./modules/es7.system.global":476,"./modules/es7.weak-map.from":477,"./modules/es7.weak-map.of":478,"./modules/es7.weak-set.from":479,"./modules/es7.weak-set.of":480,"./modules/web.dom.iterable":481,"./modules/web.immediate":482,"./modules/web.timers":483}],485:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":489}],486:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],487:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],488:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],489:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],490:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":491}],491:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],492:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":493}],493:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":495,"./_stream_writable":497,"core-util-is":485,"inherits":488,"process-nextick-args":490}],494:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":496,"core-util-is":485,"inherits":488}],495:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":493,"./internal/streams/BufferList":498,"./internal/streams/destroy":499,"./internal/streams/stream":500,"_process":491,"core-util-is":485,"events":486,"inherits":488,"isarray":501,"process-nextick-args":490,"safe-buffer":508,"string_decoder/":511,"util":28}],496:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":493,"core-util-is":485,"inherits":488}],497:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":493,"./internal/streams/destroy":499,"./internal/streams/stream":500,"_process":491,"core-util-is":485,"inherits":488,"process-nextick-args":490,"safe-buffer":508,"util-deprecate":512}],498:[function(require,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":508}],499:[function(require,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":490}],500:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":486}],501:[function(require,module,exports){
arguments[4][31][0].apply(exports,arguments)
},{"dup":31}],502:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":503}],503:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":493,"./lib/_stream_passthrough.js":494,"./lib/_stream_readable.js":495,"./lib/_stream_transform.js":496,"./lib/_stream_writable.js":497}],504:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":503}],505:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":497}],506:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() { return this })() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = require("./runtime");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}

},{"./runtime":507}],507:[function(require,module,exports){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration. If the Promise is rejected, however, the
          // result for this iteration will be rejected with the same
          // reason. Note that rejections of yielded Promises are not
          // thrown back into the generator function, as is the case
          // when an awaited Promise is rejected. This difference in
          // behavior between yield and await is important, because it
          // allows the consumer to decide what to do with the yielded
          // rejection (swallow it and continue, manually .throw it back
          // into the generator, abandon iteration, whatever). With
          // await, by contrast, there is no opportunity to examine the
          // rejection reason outside the generator function, so the
          // only option is to throw it from the await expression, and
          // let the generator function handle the exception.
          result.value = unwrapped;
          resolve(result);
        }, reject);
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() { return this })() || Function("return this")()
);

},{}],508:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":30}],509:[function(require,module,exports){
(function (Buffer){
;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = require('stream').Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = require('string_decoder').StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})(typeof exports === 'undefined' ? this.sax = {} : exports)

}).call(this,require("buffer").Buffer)

},{"buffer":30,"stream":510,"string_decoder":29}],510:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":486,"inherits":488,"readable-stream/duplex.js":492,"readable-stream/passthrough.js":502,"readable-stream/readable.js":503,"readable-stream/transform.js":504,"readable-stream/writable.js":505}],511:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":508}],512:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],513:[function(require,module,exports){
var Vue // late bind
var version
var map = Object.create(null)
if (typeof window !== 'undefined') {
  window.__VUE_HOT_MAP__ = map
}
var installed = false
var isBrowserify = false
var initHookName = 'beforeCreate'

exports.install = function (vue, browserify) {
  if (installed) { return }
  installed = true

  Vue = vue.__esModule ? vue.default : vue
  version = Vue.version.split('.').map(Number)
  isBrowserify = browserify

  // compat with < 2.0.0-alpha.7
  if (Vue.config._lifecycleHooks.indexOf('init') > -1) {
    initHookName = 'init'
  }

  exports.compatible = version[0] >= 2
  if (!exports.compatible) {
    console.warn(
      '[HMR] You are using a version of vue-hot-reload-api that is ' +
        'only compatible with Vue.js core ^2.0.0.'
    )
    return
  }
}

/**
 * Create a record for a hot module, which keeps track of its constructor
 * and instances
 *
 * @param {String} id
 * @param {Object} options
 */

exports.createRecord = function (id, options) {
  if(map[id]) { return }

  var Ctor = null
  if (typeof options === 'function') {
    Ctor = options
    options = Ctor.options
  }
  makeOptionsHot(id, options)
  map[id] = {
    Ctor: Ctor,
    options: options,
    instances: []
  }
}

/**
 * Check if module is recorded
 *
 * @param {String} id
 */

exports.isRecorded = function (id) {
  return typeof map[id] !== 'undefined'
}

/**
 * Make a Component options object hot.
 *
 * @param {String} id
 * @param {Object} options
 */

function makeOptionsHot(id, options) {
  if (options.functional) {
    var render = options.render
    options.render = function (h, ctx) {
      var instances = map[id].instances
      if (ctx && instances.indexOf(ctx.parent) < 0) {
        instances.push(ctx.parent)
      }
      return render(h, ctx)
    }
  } else {
    injectHook(options, initHookName, function() {
      var record = map[id]
      if (!record.Ctor) {
        record.Ctor = this.constructor
      }
      record.instances.push(this)
    })
    injectHook(options, 'beforeDestroy', function() {
      var instances = map[id].instances
      instances.splice(instances.indexOf(this), 1)
    })
  }
}

/**
 * Inject a hook to a hot reloadable component so that
 * we can keep track of it.
 *
 * @param {Object} options
 * @param {String} name
 * @param {Function} hook
 */

function injectHook(options, name, hook) {
  var existing = options[name]
  options[name] = existing
    ? Array.isArray(existing) ? existing.concat(hook) : [existing, hook]
    : [hook]
}

function tryWrap(fn) {
  return function (id, arg) {
    try {
      fn(id, arg)
    } catch (e) {
      console.error(e)
      console.warn(
        'Something went wrong during Vue component hot-reload. Full reload required.'
      )
    }
  }
}

function updateOptions (oldOptions, newOptions) {
  for (var key in oldOptions) {
    if (!(key in newOptions)) {
      delete oldOptions[key]
    }
  }
  for (var key$1 in newOptions) {
    oldOptions[key$1] = newOptions[key$1]
  }
}

exports.rerender = tryWrap(function (id, options) {
  var record = map[id]
  if (!options) {
    record.instances.slice().forEach(function (instance) {
      instance.$forceUpdate()
    })
    return
  }
  if (typeof options === 'function') {
    options = options.options
  }
  if (record.Ctor) {
    record.Ctor.options.render = options.render
    record.Ctor.options.staticRenderFns = options.staticRenderFns
    record.instances.slice().forEach(function (instance) {
      instance.$options.render = options.render
      instance.$options.staticRenderFns = options.staticRenderFns
      // reset static trees
      // pre 2.5, all static trees are cached together on the instance
      if (instance._staticTrees) {
        instance._staticTrees = []
      }
      // 2.5.0
      if (Array.isArray(record.Ctor.options.cached)) {
        record.Ctor.options.cached = []
      }
      // 2.5.3
      if (Array.isArray(instance.$options.cached)) {
        instance.$options.cached = []
      }

      // post 2.5.4: v-once trees are cached on instance._staticTrees.
      // Pure static trees are cached on the staticRenderFns array
      // (both already reset above)

      // 2.6: temporarily mark rendered scoped slots as unstable so that
      // child components can be forced to update
      var restore = patchScopedSlots(instance)
      instance.$forceUpdate()
      instance.$nextTick(restore)
    })
  } else {
    // functional or no instance created yet
    record.options.render = options.render
    record.options.staticRenderFns = options.staticRenderFns

    // handle functional component re-render
    if (record.options.functional) {
      // rerender with full options
      if (Object.keys(options).length > 2) {
        updateOptions(record.options, options)
      } else {
        // template-only rerender.
        // need to inject the style injection code for CSS modules
        // to work properly.
        var injectStyles = record.options._injectStyles
        if (injectStyles) {
          var render = options.render
          record.options.render = function (h, ctx) {
            injectStyles.call(ctx)
            return render(h, ctx)
          }
        }
      }
      record.options._Ctor = null
      // 2.5.3
      if (Array.isArray(record.options.cached)) {
        record.options.cached = []
      }
      record.instances.slice().forEach(function (instance) {
        instance.$forceUpdate()
      })
    }
  }
})

exports.reload = tryWrap(function (id, options) {
  var record = map[id]
  if (options) {
    if (typeof options === 'function') {
      options = options.options
    }
    makeOptionsHot(id, options)
    if (record.Ctor) {
      if (version[1] < 2) {
        // preserve pre 2.2 behavior for global mixin handling
        record.Ctor.extendOptions = options
      }
      var newCtor = record.Ctor.super.extend(options)
      // prevent record.options._Ctor from being overwritten accidentally
      newCtor.options._Ctor = record.options._Ctor
      record.Ctor.options = newCtor.options
      record.Ctor.cid = newCtor.cid
      record.Ctor.prototype = newCtor.prototype
      if (newCtor.release) {
        // temporary global mixin strategy used in < 2.0.0-alpha.6
        newCtor.release()
      }
    } else {
      updateOptions(record.options, options)
    }
  }
  record.instances.slice().forEach(function (instance) {
    if (instance.$vnode && instance.$vnode.context) {
      instance.$vnode.context.$forceUpdate()
    } else {
      console.warn(
        'Root or manually mounted instance modified. Full reload required.'
      )
    }
  })
})

// 2.6 optimizes template-compiled scoped slots and skips updates if child
// only uses scoped slots. We need to patch the scoped slots resolving helper
// to temporarily mark all scoped slots as unstable in order to force child
// updates.
function patchScopedSlots (instance) {
  if (!instance._u) { return }
  // https://github.com/vuejs/vue/blob/dev/src/core/instance/render-helpers/resolve-scoped-slots.js
  var original = instance._u
  instance._u = function (slots) {
    try {
      // 2.6.4 ~ 2.6.6
      return original(slots, true)
    } catch (e) {
      // 2.5 / >= 2.6.7
      return original(slots, null, true)
    }
  }
  return function () {
    instance._u = original
  }
}

},{}],514:[function(require,module,exports){
(function (global){
/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
'use strict';

/*  */

var emptyObject = Object.freeze({});

// These helpers produce better VM code in JS engines due to their
// explicitness and function inlining.
function isUndef (v) {
  return v === undefined || v === null
}

function isDef (v) {
  return v !== undefined && v !== null
}

function isTrue (v) {
  return v === true
}

function isFalse (v) {
  return v === false
}

/**
 * Check if value is primitive.
 */
function isPrimitive (value) {
  return (
    typeof value === 'string' ||
    typeof value === 'number' ||
    // $flow-disable-line
    typeof value === 'symbol' ||
    typeof value === 'boolean'
  )
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject (obj) {
  return obj !== null && typeof obj === 'object'
}

/**
 * Get the raw type string of a value, e.g., [object Object].
 */
var _toString = Object.prototype.toString;

function toRawType (value) {
  return _toString.call(value).slice(8, -1)
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject (obj) {
  return _toString.call(obj) === '[object Object]'
}

function isRegExp (v) {
  return _toString.call(v) === '[object RegExp]'
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex (val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val)
}

function isPromise (val) {
  return (
    isDef(val) &&
    typeof val.then === 'function' &&
    typeof val.catch === 'function'
  )
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString (val) {
  return val == null
    ? ''
    : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)
      ? JSON.stringify(val, null, 2)
      : String(val)
}

/**
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber (val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap (
  str,
  expectsLowerCase
) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase
    ? function (val) { return map[val.toLowerCase()]; }
    : function (val) { return map[val]; }
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if an attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array.
 */
function remove (arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1)
    }
  }
}

/**
 * Check whether an object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn (obj, key) {
  return hasOwnProperty.call(obj, key)
}

/**
 * Create a cached version of a pure function.
 */
function cached (fn) {
  var cache = Object.create(null);
  return (function cachedFn (str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str))
  })
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase()
});

/**
 * Simple bind polyfill for environments that do not support it,
 * e.g., PhantomJS 1.x. Technically, we don't need this anymore
 * since native bind is now performant enough in most browsers.
 * But removing it would mean breaking code that was able to run in
 * PhantomJS 1.x, so this must be kept for backward compatibility.
 */

/* istanbul ignore next */
function polyfillBind (fn, ctx) {
  function boundFn (a) {
    var l = arguments.length;
    return l
      ? l > 1
        ? fn.apply(ctx, arguments)
        : fn.call(ctx, a)
      : fn.call(ctx)
  }

  boundFn._length = fn.length;
  return boundFn
}

function nativeBind (fn, ctx) {
  return fn.bind(ctx)
}

var bind = Function.prototype.bind
  ? nativeBind
  : polyfillBind;

/**
 * Convert an Array-like object to a real Array.
 */
function toArray (list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret
}

/**
 * Mix properties into target object.
 */
function extend (to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject (arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res
}

/* eslint-disable no-unused-vars */

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 */
function noop (a, b, c) {}

/**
 * Always return false.
 */
var no = function (a, b, c) { return false; };

/* eslint-enable no-unused-vars */

/**
 * Return the same value.
 */
var identity = function (_) { return _; };

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual (a, b) {
  if (a === b) { return true }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i])
        })
      } else if (a instanceof Date && b instanceof Date) {
        return a.getTime() === b.getTime()
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key])
        })
      } else {
        /* istanbul ignore next */
        return false
      }
    } catch (e) {
      /* istanbul ignore next */
      return false
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b)
  } else {
    return false
  }
}

/**
 * Return the first index at which a loosely equal value can be
 * found in the array (if value is a plain object, the array must
 * contain an object of the same shape), or -1 if it is not present.
 */
function looseIndexOf (arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) { return i }
  }
  return -1
}

/**
 * Ensure a function is called only once.
 */
function once (fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  }
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = [
  'component',
  'directive',
  'filter'
];

var LIFECYCLE_HOOKS = [
  'beforeCreate',
  'created',
  'beforeMount',
  'mounted',
  'beforeUpdate',
  'updated',
  'beforeDestroy',
  'destroyed',
  'activated',
  'deactivated',
  'errorCaptured',
  'serverPrefetch'
];

/*  */



var config = ({
  /**
   * Option merge strategies (used in core/util/options)
   */
  // $flow-disable-line
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  // $flow-disable-line
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Perform updates asynchronously. Intended to be used by Vue Test Utils
   * This will significantly reduce performance if set to false.
   */
  async: true,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
});

/*  */

/**
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
 */
var unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;

/**
 * Check if a string starts with $ or _
 */
function isReserved (str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F
}

/**
 * Define a property.
 */
function def (obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = new RegExp(("[^" + (unicodeRegExp.source) + ".$_\\d]"));
function parsePath (path) {
  if (bailRE.test(path)) {
    return
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) { return }
      obj = obj[segments[i]];
    }
    return obj
  }
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');
var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;
var isPhantomJS = UA && /phantomjs/.test(UA);
var isFF = UA && UA.match(/firefox\/(\d+)/);

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = ({}).watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', ({
      get: function get () {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    })); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function () {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && !inWeex && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative (Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())
}

var hasSymbol =
  typeof Symbol !== 'undefined' && isNative(Symbol) &&
  typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = /*@__PURE__*/(function () {
    function Set () {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has (key) {
      return this.set[key] === true
    };
    Set.prototype.add = function add (key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear () {
      this.set = Object.create(null);
    };

    return Set;
  }());
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = (noop); // work around flow check
var formatComponentName = (noop);

{
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function (str) { return str
    .replace(classifyRE, function (c) { return c.toUpperCase(); })
    .replace(/[-_]/g, ''); };

  warn = function (msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && (!config.silent)) {
      console.error(("[Vue warn]: " + msg + trace));
    }
  };

  tip = function (msg, vm) {
    if (hasConsole && (!config.silent)) {
      console.warn("[Vue tip]: " + msg + (
        vm ? generateComponentTrace(vm) : ''
      ));
    }
  };

  formatComponentName = function (vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>'
    }
    var options = typeof vm === 'function' && vm.cid != null
      ? vm.options
      : vm._isVue
        ? vm.$options || vm.constructor.options
        : vm;
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (
      (name ? ("<" + (classify(name)) + ">") : "<Anonymous>") +
      (file && includeFile !== false ? (" at " + file) : '')
    )
  };

  var repeat = function (str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) { res += str; }
      if (n > 1) { str += str; }
      n >>= 1;
    }
    return res
  };

  generateComponentTrace = function (vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree
        .map(function (vm, i) { return ("" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)
            ? ((formatComponentName(vm[0])) + "... (" + (vm[1]) + " recursive calls)")
            : formatComponentName(vm))); })
        .join('\n')
    } else {
      return ("\n\n(found in " + (formatComponentName(vm)) + ")")
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep () {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub (sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub (sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend () {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify () {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  if (!config.async) {
    // subs aren't sorted in scheduler if not running async
    // we need to sort them now to make sure they fire in correct
    // order
    subs.sort(function (a, b) { return a.id - b.id; });
  }
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// The current target watcher being evaluated.
// This is globally unique because only one watcher
// can be evaluated at a time.
Dep.target = null;
var targetStack = [];

function pushTarget (target) {
  targetStack.push(target);
  Dep.target = target;
}

function popTarget () {
  targetStack.pop();
  Dep.target = targetStack[targetStack.length - 1];
}

/*  */

var VNode = function VNode (
  tag,
  data,
  children,
  text,
  elm,
  context,
  componentOptions,
  asyncFactory
) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance
};

Object.defineProperties( VNode.prototype, prototypeAccessors );

var createEmptyVNode = function (text) {
  if ( text === void 0 ) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node
};

function createTextVNode (val) {
  return new VNode(undefined, undefined, undefined, String(val))
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode (vnode) {
  var cloned = new VNode(
    vnode.tag,
    vnode.data,
    // #7975
    // clone children array to avoid mutating original in case of cloning
    // a child.
    vnode.children && vnode.children.slice(),
    vnode.text,
    vnode.elm,
    vnode.context,
    vnode.componentOptions,
    vnode.asyncFactory
  );
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.asyncMeta = vnode.asyncMeta;
  cloned.isCloned = true;
  return cloned
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);

var methodsToPatch = [
  'push',
  'pop',
  'shift',
  'unshift',
  'splice',
  'sort',
  'reverse'
];

/**
 * Intercept mutating methods and emit events
 */
methodsToPatch.forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator () {
    var args = [], len = arguments.length;
    while ( len-- ) args[ len ] = arguments[ len ];

    var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break
      case 'splice':
        inserted = args.slice(2);
        break
    }
    if (inserted) { ob.observeArray(inserted); }
    // notify change
    ob.dep.notify();
    return result
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * In some cases we may want to disable observation inside a component's
 * update computation.
 */
var shouldObserve = true;

function toggleObserving (value) {
  shouldObserve = value;
}

/**
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
 */
var Observer = function Observer (value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    if (hasProto) {
      protoAugment(value, arrayMethods);
    } else {
      copyAugment(value, arrayMethods, arrayKeys);
    }
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through all properties and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk (obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive$$1(obj, keys[i]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray (items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment a target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment (target, src) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment a target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment (target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe (value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (
    shouldObserve &&
    !isServerRendering() &&
    (Array.isArray(value) || isPlainObject(value)) &&
    Object.isExtensible(value) &&
    !value._isVue
  ) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive$$1 (
  obj,
  key,
  val,
  customSetter,
  shallow
) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;
  if ((!getter || setter) && arguments.length === 2) {
    val = obj[key];
  }

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter () {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value
    },
    set: function reactiveSetter (newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || (newVal !== newVal && value !== value)) {
        return
      }
      /* eslint-enable no-self-compare */
      if (customSetter) {
        customSetter();
      }
      // #7981: for accessor properties without setter
      if (getter && !setter) { return }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set (target, key, val) {
  if (isUndef(target) || isPrimitive(target)
  ) {
    warn(("Cannot set reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    );
    return val
  }
  if (!ob) {
    target[key] = val;
    return val
  }
  defineReactive$$1(ob.value, key, val);
  ob.dep.notify();
  return val
}

/**
 * Delete a property and trigger change if necessary.
 */
function del (target, key) {
  if (isUndef(target) || isPrimitive(target)
  ) {
    warn(("Cannot delete reactive property on undefined, null, or primitive value: " + ((target))));
  }
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return
  }
  var ob = (target).__ob__;
  if (target._isVue || (ob && ob.vmCount)) {
    warn(
      'Avoid deleting properties on a Vue instance or its root $data ' +
      '- just set it to null.'
    );
    return
  }
  if (!hasOwn(target, key)) {
    return
  }
  delete target[key];
  if (!ob) {
    return
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray (value) {
  for (var e = (void 0), i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
{
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn(
        "option \"" + key + "\" can only be used during instance " +
        'creation with the `new` keyword.'
      );
    }
    return defaultStrat(parent, child)
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData (to, from) {
  if (!from) { return to }
  var key, toVal, fromVal;

  var keys = hasSymbol
    ? Reflect.ownKeys(from)
    : Object.keys(from);

  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    // in case the object is already observed...
    if (key === '__ob__') { continue }
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (
      toVal !== fromVal &&
      isPlainObject(toVal) &&
      isPlainObject(fromVal)
    ) {
      mergeData(toVal, fromVal);
    }
  }
  return to
}

/**
 * Data
 */
function mergeDataOrFn (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal
    }
    if (!parentVal) {
      return childVal
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn () {
      return mergeData(
        typeof childVal === 'function' ? childVal.call(this, this) : childVal,
        typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal
      )
    }
  } else {
    return function mergedInstanceDataFn () {
      // instance merge
      var instanceData = typeof childVal === 'function'
        ? childVal.call(vm, vm)
        : childVal;
      var defaultData = typeof parentVal === 'function'
        ? parentVal.call(vm, vm)
        : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData)
      } else {
        return defaultData
      }
    }
  }
}

strats.data = function (
  parentVal,
  childVal,
  vm
) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      warn(
        'The "data" option should be a function ' +
        'that returns a per-instance value in component ' +
        'definitions.',
        vm
      );

      return parentVal
    }
    return mergeDataOrFn(parentVal, childVal)
  }

  return mergeDataOrFn(parentVal, childVal, vm)
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal,
  childVal
) {
  var res = childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal;
  return res
    ? dedupeHooks(res)
    : res
}

function dedupeHooks (hooks) {
  var res = [];
  for (var i = 0; i < hooks.length; i++) {
    if (res.indexOf(hooks[i]) === -1) {
      res.push(hooks[i]);
    }
  }
  return res
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets (
  parentVal,
  childVal,
  vm,
  key
) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    assertObjectType(key, childVal, vm);
    return extend(res, childVal)
  } else {
    return res
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (
  parentVal,
  childVal,
  vm,
  key
) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) { parentVal = undefined; }
  if (childVal === nativeWatch) { childVal = undefined; }
  /* istanbul ignore if */
  if (!childVal) { return Object.create(parentVal || null) }
  {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent
      ? parent.concat(child)
      : Array.isArray(child) ? child : [child];
  }
  return ret
};

/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal,
  childVal,
  vm,
  key
) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) { return childVal }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) { extend(ret, childVal); }
  return ret
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function (parentVal, childVal) {
  return childVal === undefined
    ? parentVal
    : childVal
};

/**
 * Validate component names
 */
function checkComponents (options) {
  for (var key in options.components) {
    validateComponentName(key);
  }
}

function validateComponentName (name) {
  if (!new RegExp(("^[a-zA-Z][\\-\\.0-9_" + (unicodeRegExp.source) + "]*$")).test(name)) {
    warn(
      'Invalid component name: "' + name + '". Component names ' +
      'should conform to valid custom element name in html5 specification.'
    );
  }
  if (isBuiltInTag(name) || config.isReservedTag(name)) {
    warn(
      'Do not use built-in or reserved HTML elements as component ' +
      'id: ' + name
    );
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps (options, vm) {
  var props = options.props;
  if (!props) { return }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val)
        ? val
        : { type: val };
    }
  } else {
    warn(
      "Invalid value for option \"props\": expected an Array or an Object, " +
      "but got " + (toRawType(props)) + ".",
      vm
    );
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject (options, vm) {
  var inject = options.inject;
  if (!inject) { return }
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val)
        ? extend({ from: key }, val)
        : { from: val };
    }
  } else {
    warn(
      "Invalid value for option \"inject\": expected an Array or an Object, " +
      "but got " + (toRawType(inject)) + ".",
      vm
    );
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives (options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def$$1 = dirs[key];
      if (typeof def$$1 === 'function') {
        dirs[key] = { bind: def$$1, update: def$$1 };
      }
    }
  }
}

function assertObjectType (name, value, vm) {
  if (!isPlainObject(value)) {
    warn(
      "Invalid value for option \"" + name + "\": expected an Object, " +
      "but got " + (toRawType(value)) + ".",
      vm
    );
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions (
  parent,
  child,
  vm
) {
  {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);

  // Apply extends and mixins on the child options,
  // but only if it is a raw options object that isn't
  // the result of another mergeOptions call.
  // Only merged options has the _base property.
  if (!child._base) {
    if (child.extends) {
      parent = mergeOptions(parent, child.extends, vm);
    }
    if (child.mixins) {
      for (var i = 0, l = child.mixins.length; i < l; i++) {
        parent = mergeOptions(parent, child.mixins[i], vm);
      }
    }
  }

  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField (key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset (
  options,
  type,
  id,
  warnMissing
) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) { return assets[id] }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if (warnMissing && !res) {
    warn(
      'Failed to resolve ' + type.slice(0, -1) + ': ' + id,
      options
    );
  }
  return res
}

/*  */



function validateProp (
  key,
  propOptions,
  propsData,
  vm
) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // boolean casting
  var booleanIndex = getTypeIndex(Boolean, prop.type);
  if (booleanIndex > -1) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (value === '' || value === hyphenate(key)) {
      // only cast empty string / same name to boolean if
      // boolean has higher priority
      var stringIndex = getTypeIndex(String, prop.type);
      if (stringIndex < 0 || booleanIndex < stringIndex) {
        value = true;
      }
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldObserve = shouldObserve;
    toggleObserving(true);
    observe(value);
    toggleObserving(prevShouldObserve);
  }
  {
    assertProp(prop, key, value, vm, absent);
  }
  return value
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue (vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if (isObject(def)) {
    warn(
      'Invalid default value for prop "' + key + '": ' +
      'Props with type Object/Array must use a factory function ' +
      'to return the default value.',
      vm
    );
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData &&
    vm.$options.propsData[key] === undefined &&
    vm._props[key] !== undefined
  ) {
    return vm._props[key]
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function'
    ? def.call(vm)
    : def
}

/**
 * Assert whether a prop is valid.
 */
function assertProp (
  prop,
  name,
  value,
  vm,
  absent
) {
  if (prop.required && absent) {
    warn(
      'Missing required prop: "' + name + '"',
      vm
    );
    return
  }
  if (value == null && !prop.required) {
    return
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }

  if (!valid) {
    warn(
      getInvalidTypeMessage(name, value, expectedTypes),
      vm
    );
    return
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn(
        'Invalid prop: custom validator check failed for prop "' + name + '".',
        vm
      );
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType (value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value;
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  }
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType (fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : ''
}

function isSameType (a, b) {
  return getType(a) === getType(b)
}

function getTypeIndex (type, expectedTypes) {
  if (!Array.isArray(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1
  }
  for (var i = 0, len = expectedTypes.length; i < len; i++) {
    if (isSameType(expectedTypes[i], type)) {
      return i
    }
  }
  return -1
}

function getInvalidTypeMessage (name, value, expectedTypes) {
  var message = "Invalid prop: type check failed for prop \"" + name + "\"." +
    " Expected " + (expectedTypes.map(capitalize).join(', '));
  var expectedType = expectedTypes[0];
  var receivedType = toRawType(value);
  var expectedValue = styleValue(value, expectedType);
  var receivedValue = styleValue(value, receivedType);
  // check if we need to specify expected value
  if (expectedTypes.length === 1 &&
      isExplicable(expectedType) &&
      !isBoolean(expectedType, receivedType)) {
    message += " with value " + expectedValue;
  }
  message += ", got " + receivedType + " ";
  // check if we need to specify received value
  if (isExplicable(receivedType)) {
    message += "with value " + receivedValue + ".";
  }
  return message
}

function styleValue (value, type) {
  if (type === 'String') {
    return ("\"" + value + "\"")
  } else if (type === 'Number') {
    return ("" + (Number(value)))
  } else {
    return ("" + value)
  }
}

function isExplicable (value) {
  var explicitTypes = ['string', 'number', 'boolean'];
  return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })
}

function isBoolean () {
  var args = [], len = arguments.length;
  while ( len-- ) args[ len ] = arguments[ len ];

  return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })
}

/*  */

function handleError (err, vm, info) {
  // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.
  // See: https://github.com/vuejs/vuex/issues/1505
  pushTarget();
  try {
    if (vm) {
      var cur = vm;
      while ((cur = cur.$parent)) {
        var hooks = cur.$options.errorCaptured;
        if (hooks) {
          for (var i = 0; i < hooks.length; i++) {
            try {
              var capture = hooks[i].call(cur, err, vm, info) === false;
              if (capture) { return }
            } catch (e) {
              globalHandleError(e, cur, 'errorCaptured hook');
            }
          }
        }
      }
    }
    globalHandleError(err, vm, info);
  } finally {
    popTarget();
  }
}

function invokeWithErrorHandling (
  handler,
  context,
  args,
  vm,
  info
) {
  var res;
  try {
    res = args ? handler.apply(context, args) : handler.call(context);
    if (res && !res._isVue && isPromise(res) && !res._handled) {
      res.catch(function (e) { return handleError(e, vm, info + " (Promise/async)"); });
      // issue #9511
      // avoid catch triggering multiple times when nested calls
      res._handled = true;
    }
  } catch (e) {
    handleError(e, vm, info);
  }
  return res
}

function globalHandleError (err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info)
    } catch (e) {
      // if the user intentionally throws the original error in the handler,
      // do not log it twice
      if (e !== err) {
        logError(e, null, 'config.errorHandler');
      }
    }
  }
  logError(err, vm, info);
}

function logError (err, vm, info) {
  {
    warn(("Error in " + info + ": \"" + (err.toString()) + "\""), vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err
  }
}

/*  */

var isUsingMicroTask = false;

var callbacks = [];
var pending = false;

function flushCallbacks () {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using microtasks.
// In 2.5 we used (macro) tasks (in combination with microtasks).
// However, it has subtle problems when state is changed right before repaint
// (e.g. #6813, out-in transitions).
// Also, using (macro) tasks in event handler would cause some weird behaviors
// that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).
// So we now use microtasks everywhere, again.
// A major drawback of this tradeoff is that there are some scenarios
// where microtasks have too high a priority and fire in between supposedly
// sequential events (e.g. #4521, #6690, which have workarounds)
// or even between bubbling of the same event (#6566).
var timerFunc;

// The nextTick behavior leverages the microtask queue, which can be accessed
// via either native Promise.then or MutationObserver.
// MutationObserver has wider support, however it is seriously bugged in
// UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
// completely stops working after triggering a few times... so, if native
// Promise is available, we will use it:
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  timerFunc = function () {
    p.then(flushCallbacks);
    // In problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) { setTimeout(noop); }
  };
  isUsingMicroTask = true;
} else if (!isIE && typeof MutationObserver !== 'undefined' && (
  isNative(MutationObserver) ||
  // PhantomJS and iOS 7.x
  MutationObserver.toString() === '[object MutationObserverConstructor]'
)) {
  // Use MutationObserver where native Promise is not available,
  // e.g. PhantomJS, iOS7, Android 4.4
  // (#6466 MutationObserver is unreliable in IE11)
  var counter = 1;
  var observer = new MutationObserver(flushCallbacks);
  var textNode = document.createTextNode(String(counter));
  observer.observe(textNode, {
    characterData: true
  });
  timerFunc = function () {
    counter = (counter + 1) % 2;
    textNode.data = String(counter);
  };
  isUsingMicroTask = true;
} else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  // Fallback to setImmediate.
  // Techinically it leverages the (macro) task queue,
  // but it is still a better choice than setTimeout.
  timerFunc = function () {
    setImmediate(flushCallbacks);
  };
} else {
  // Fallback to setTimeout.
  timerFunc = function () {
    setTimeout(flushCallbacks, 0);
  };
}

function nextTick (cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    timerFunc();
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    })
  }
}

/*  */

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

{
  var allowedGlobals = makeMap(
    'Infinity,undefined,NaN,isFinite,isNaN,' +
    'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +
    'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +
    'require' // for Webpack/Browserify
  );

  var warnNonPresent = function (target, key) {
    warn(
      "Property or method \"" + key + "\" is not defined on the instance but " +
      'referenced during render. Make sure that this property is reactive, ' +
      'either in the data option, or for class-based components, by ' +
      'initializing the property. ' +
      'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',
      target
    );
  };

  var warnReservedPrefix = function (target, key) {
    warn(
      "Property \"" + key + "\" must be accessed with \"$data." + key + "\" because " +
      'properties starting with "$" or "_" are not proxied in the Vue instance to ' +
      'prevent conflicts with Vue internals' +
      'See: https://vuejs.org/v2/api/#data',
      target
    );
  };

  var hasProxy =
    typeof Proxy !== 'undefined' && isNative(Proxy);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set (target, key, value) {
        if (isBuiltInModifier(key)) {
          warn(("Avoid overwriting built-in modifier in config.keyCodes: ." + key));
          return false
        } else {
          target[key] = value;
          return true
        }
      }
    });
  }

  var hasHandler = {
    has: function has (target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) ||
        (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));
      if (!has && !isAllowed) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return has || !isAllowed
    }
  };

  var getHandler = {
    get: function get (target, key) {
      if (typeof key === 'string' && !(key in target)) {
        if (key in target.$data) { warnReservedPrefix(target, key); }
        else { warnNonPresent(target, key); }
      }
      return target[key]
    }
  };

  initProxy = function initProxy (vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped
        ? getHandler
        : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse (val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse (val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) { _traverse(val[i], seen); }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) { _traverse(val[keys[i]], seen); }
  }
}

var mark;
var measure;

{
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (
    perf &&
    perf.mark &&
    perf.measure &&
    perf.clearMarks &&
    perf.clearMeasures
  ) {
    mark = function (tag) { return perf.mark(tag); };
    measure = function (name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      // perf.clearMeasures(name)
    };
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  }
});

function createFnInvoker (fns, vm) {
  function invoker () {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        invokeWithErrorHandling(cloned[i], null, arguments$1, vm, "v-on handler");
      }
    } else {
      // return handler return value for single handlers
      return invokeWithErrorHandling(fns, null, arguments, vm, "v-on handler")
    }
  }
  invoker.fns = fns;
  return invoker
}

function updateListeners (
  on,
  oldOn,
  add,
  remove$$1,
  createOnceHandler,
  vm
) {
  var name, def$$1, cur, old, event;
  for (name in on) {
    def$$1 = cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      warn(
        "Invalid handler for event \"" + (event.name) + "\": got " + String(cur),
        vm
      );
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur, vm);
      }
      if (isTrue(event.once)) {
        cur = on[name] = createOnceHandler(event.name, cur, event.capture);
      }
      add(event.name, cur, event.capture, event.passive, event.params);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook (def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook () {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData (
  data,
  Ctor,
  tag
) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      {
        var keyInLowerCase = key.toLowerCase();
        if (
          key !== keyInLowerCase &&
          attrs && hasOwn(attrs, keyInLowerCase)
        ) {
          tip(
            "Prop \"" + keyInLowerCase + "\" is passed to component " +
            (formatComponentName(tag || Ctor)) + ", but the declared prop name is" +
            " \"" + key + "\". " +
            "Note that HTML attributes are case-insensitive and camelCased " +
            "props need to use their kebab-case equivalents when using in-DOM " +
            "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\"."
          );
        }
      }
      checkProp(res, props, key, altKey, true) ||
      checkProp(res, attrs, key, altKey, false);
    }
  }
  return res
}

function checkProp (
  res,
  hash,
  key,
  altKey,
  preserve
) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true
    }
  }
  return false
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren (children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children)
    }
  }
  return children
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren (children) {
  return isPrimitive(children)
    ? [createTextVNode(children)]
    : Array.isArray(children)
      ? normalizeArrayChildren(children)
      : undefined
}

function isTextNode (node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment)
}

function normalizeArrayChildren (children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') { continue }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, ((nestedIndex || '') + "_" + i));
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + (c[0]).text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) &&
          isDef(c.tag) &&
          isUndef(c.key) &&
          isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res
}

/*  */

function initProvide (vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function'
      ? provide.call(vm)
      : provide;
  }
}

function initInjections (vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    toggleObserving(false);
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      {
        defineReactive$$1(vm, key, result[key], function () {
          warn(
            "Avoid mutating an injected value directly since the changes will be " +
            "overwritten whenever the provided component re-renders. " +
            "injection being mutated: \"" + key + "\"",
            vm
          );
        });
      }
    });
    toggleObserving(true);
  }
}

function resolveInject (inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol
      ? Reflect.ownKeys(inject)
      : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      // #6574 in case the inject object is observed...
      if (key === '__ob__') { continue }
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && hasOwn(source._provided, provideKey)) {
          result[key] = source._provided[provideKey];
          break
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function'
            ? provideDefault.call(vm)
            : provideDefault;
        } else {
          warn(("Injection \"" + key + "\" not found"), vm);
        }
      }
    }
    return result
  }
}

/*  */



/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots (
  children,
  context
) {
  if (!children || !children.length) {
    return {}
  }
  var slots = {};
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) &&
      data && data.slot != null
    ) {
      var name = data.slot;
      var slot = (slots[name] || (slots[name] = []));
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children || []);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots
}

function isWhitespace (node) {
  return (node.isComment && !node.asyncFactory) || node.text === ' '
}

/*  */

function normalizeScopedSlots (
  slots,
  normalSlots,
  prevSlots
) {
  var res;
  var hasNormalSlots = Object.keys(normalSlots).length > 0;
  var isStable = slots ? !!slots.$stable : !hasNormalSlots;
  var key = slots && slots.$key;
  if (!slots) {
    res = {};
  } else if (slots._normalized) {
    // fast path 1: child component re-render only, parent did not change
    return slots._normalized
  } else if (
    isStable &&
    prevSlots &&
    prevSlots !== emptyObject &&
    key === prevSlots.$key &&
    !hasNormalSlots &&
    !prevSlots.$hasNormal
  ) {
    // fast path 2: stable scoped slots w/ no normal slots to proxy,
    // only need to normalize once
    return prevSlots
  } else {
    res = {};
    for (var key$1 in slots) {
      if (slots[key$1] && key$1[0] !== '$') {
        res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);
      }
    }
  }
  // expose normal slots on scopedSlots
  for (var key$2 in normalSlots) {
    if (!(key$2 in res)) {
      res[key$2] = proxyNormalSlot(normalSlots, key$2);
    }
  }
  // avoriaz seems to mock a non-extensible $scopedSlots object
  // and when that is passed down this would cause an error
  if (slots && Object.isExtensible(slots)) {
    (slots)._normalized = res;
  }
  def(res, '$stable', isStable);
  def(res, '$key', key);
  def(res, '$hasNormal', hasNormalSlots);
  return res
}

function normalizeScopedSlot(normalSlots, key, fn) {
  var normalized = function () {
    var res = arguments.length ? fn.apply(null, arguments) : fn({});
    res = res && typeof res === 'object' && !Array.isArray(res)
      ? [res] // single vnode
      : normalizeChildren(res);
    return res && (
      res.length === 0 ||
      (res.length === 1 && res[0].isComment) // #9658
    ) ? undefined
      : res
  };
  // this is a slot using the new v-slot syntax without scope. although it is
  // compiled as a scoped slot, render fn users would expect it to be present
  // on this.$slots because the usage is semantically a normal slot.
  if (fn.proxy) {
    Object.defineProperty(normalSlots, key, {
      get: normalized,
      enumerable: true,
      configurable: true
    });
  }
  return normalized
}

function proxyNormalSlot(slots, key) {
  return function () { return slots[key]; }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList (
  val,
  render
) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    if (hasSymbol && val[Symbol.iterator]) {
      ret = [];
      var iterator = val[Symbol.iterator]();
      var result = iterator.next();
      while (!result.done) {
        ret.push(render(result.value, ret.length));
        result = iterator.next();
      }
    } else {
      keys = Object.keys(val);
      ret = new Array(keys.length);
      for (i = 0, l = keys.length; i < l; i++) {
        key = keys[i];
        ret[i] = render(val[key], key, i);
      }
    }
  }
  if (!isDef(ret)) {
    ret = [];
  }
  (ret)._isVList = true;
  return ret
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot (
  name,
  fallback,
  props,
  bindObject
) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) { // scoped slot
    props = props || {};
    if (bindObject) {
      if (!isObject(bindObject)) {
        warn(
          'slot v-bind without argument expects an Object',
          this
        );
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    nodes = this.$slots[name] || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes)
  } else {
    return nodes
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter (id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity
}

/*  */

function isKeyNotMatch (expect, actual) {
  if (Array.isArray(expect)) {
    return expect.indexOf(actual) === -1
  } else {
    return expect !== actual
  }
}

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes (
  eventKeyCode,
  key,
  builtInKeyCode,
  eventKeyName,
  builtInKeyName
) {
  var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;
  if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {
    return isKeyNotMatch(builtInKeyName, eventKeyName)
  } else if (mappedKeyCode) {
    return isKeyNotMatch(mappedKeyCode, eventKeyCode)
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps (
  data,
  tag,
  value,
  asProp,
  isSync
) {
  if (value) {
    if (!isObject(value)) {
      warn(
        'v-bind without argument expects an Object or Array value',
        this
      );
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function ( key ) {
        if (
          key === 'class' ||
          key === 'style' ||
          isReservedAttribute(key)
        ) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key)
            ? data.domProps || (data.domProps = {})
            : data.attrs || (data.attrs = {});
        }
        var camelizedKey = camelize(key);
        var hyphenatedKey = hyphenate(key);
        if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on[("update:" + key)] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) loop( key );
    }
  }
  return data
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic (
  index,
  isInFor
) {
  var cached = this._staticTrees || (this._staticTrees = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree.
  if (tree && !isInFor) {
    return tree
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = this.$options.staticRenderFns[index].call(
    this._renderProxy,
    null,
    this // for render fns generated for functional component templates
  );
  markStatic(tree, ("__static__" + index), false);
  return tree
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce (
  tree,
  index,
  key
) {
  markStatic(tree, ("__once__" + index + (key ? ("_" + key) : "")), true);
  return tree
}

function markStatic (
  tree,
  key,
  isOnce
) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], (key + "_" + i), isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode (node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners (data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      warn(
        'v-on without argument expects an Object value',
        this
      );
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data
}

/*  */

function resolveScopedSlots (
  fns, // see flow/vnode
  res,
  // the following are added in 2.6
  hasDynamicKeys,
  contentHashKey
) {
  res = res || { $stable: !hasDynamicKeys };
  for (var i = 0; i < fns.length; i++) {
    var slot = fns[i];
    if (Array.isArray(slot)) {
      resolveScopedSlots(slot, res, hasDynamicKeys);
    } else if (slot) {
      // marker for reverse proxying v-slot without scope on this.$slots
      if (slot.proxy) {
        slot.fn.proxy = true;
      }
      res[slot.key] = slot.fn;
    }
  }
  if (contentHashKey) {
    (res).$key = contentHashKey;
  }
  return res
}

/*  */

function bindDynamicKeys (baseObj, values) {
  for (var i = 0; i < values.length; i += 2) {
    var key = values[i];
    if (typeof key === 'string' && key) {
      baseObj[values[i]] = values[i + 1];
    } else if (key !== '' && key !== null) {
      // null is a speical value for explicitly removing a binding
      warn(
        ("Invalid value for dynamic directive argument (expected string or null): " + key),
        this
      );
    }
  }
  return baseObj
}

// helper to dynamically append modifier runtime markers to event names.
// ensure only append when value is already string, otherwise it will be cast
// to string and cause the type check to miss.
function prependModifier (value, symbol) {
  return typeof value === 'string' ? symbol + value : value
}

/*  */

function installRenderHelpers (target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
  target._d = bindDynamicKeys;
  target._p = prependModifier;
}

/*  */

function FunctionalRenderContext (
  data,
  props,
  children,
  parent,
  Ctor
) {
  var this$1 = this;

  var options = Ctor.options;
  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm;
  if (hasOwn(parent, '_uid')) {
    contextVm = Object.create(parent);
    // $flow-disable-line
    contextVm._original = parent;
  } else {
    // the context vm passed in is a functional context as well.
    // in this case we want to make sure we are able to get a hold to the
    // real context instance.
    contextVm = parent;
    // $flow-disable-line
    parent = parent._original;
  }
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    if (!this$1.$slots) {
      normalizeScopedSlots(
        data.scopedSlots,
        this$1.$slots = resolveSlots(children, parent)
      );
    }
    return this$1.$slots
  };

  Object.defineProperty(this, 'scopedSlots', ({
    enumerable: true,
    get: function get () {
      return normalizeScopedSlots(data.scopedSlots, this.slots())
    }
  }));

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode && !Array.isArray(vnode)) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode
    };
  } else {
    this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent (
  Ctor,
  propsData,
  data,
  contextVm,
  children
) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) { mergeProps(props, data.attrs); }
    if (isDef(data.props)) { mergeProps(props, data.props); }
  }

  var renderContext = new FunctionalRenderContext(
    data,
    props,
    children,
    contextVm,
    Ctor
  );

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)
  } else if (Array.isArray(vnode)) {
    var vnodes = normalizeChildren(vnode) || [];
    var res = new Array(vnodes.length);
    for (var i = 0; i < vnodes.length; i++) {
      res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);
    }
    return res
  }
}

function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {
  // #7817 clone node before setting fnContext, otherwise if the node is reused
  // (e.g. it was from a cached normal slot) the fnContext causes named slots
  // that should not be matched to match.
  var clone = cloneVNode(vnode);
  clone.fnContext = contextVm;
  clone.fnOptions = options;
  {
    (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;
  }
  if (data.slot) {
    (clone.data || (clone.data = {})).slot = data.slot;
  }
  return clone
}

function mergeProps (to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

/*  */

/*  */

/*  */

// inline hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init (vnode, hydrating) {
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    } else {
      var child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      );
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    }
  },

  prepatch: function prepatch (oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    );
  },

  insert: function insert (vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy (vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent (
  Ctor,
  data,
  context,
  children,
  tag
) {
  if (isUndef(Ctor)) {
    return
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    {
      warn(("Invalid Component definition: " + (String(Ctor))), context);
    }
    return
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // install component management hooks onto the placeholder node
  installComponentHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode(
    ("vue-component-" + (Ctor.cid) + (name ? ("-" + name) : '')),
    data, undefined, undefined, undefined, context,
    { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },
    asyncFactory
  );

  return vnode
}

function createComponentInstanceForVnode (
  vnode, // we know it's MountedComponentVNode but flow doesn't
  parent // activeInstance in lifecycle state
) {
  var options = {
    _isComponent: true,
    _parentVnode: vnode,
    parent: parent
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnode.componentOptions.Ctor(options)
}

function installComponentHooks (data) {
  var hooks = data.hook || (data.hook = {});
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var existing = hooks[key];
    var toMerge = componentVNodeHooks[key];
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;
    }
  }
}

function mergeHook$1 (f1, f2) {
  var merged = function (a, b) {
    // flow complains about extra args which is why we use any
    f1(a, b);
    f2(a, b);
  };
  merged._merged = true;
  return merged
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel (options, data) {
  var prop = (options.model && options.model.prop) || 'value';
  var event = (options.model && options.model.event) || 'input'
  ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  var existing = on[event];
  var callback = data.model.callback;
  if (isDef(existing)) {
    if (
      Array.isArray(existing)
        ? existing.indexOf(callback) === -1
        : existing !== callback
    ) {
      on[event] = [callback].concat(existing);
    }
  } else {
    on[event] = callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement (
  context,
  tag,
  data,
  children,
  normalizationType,
  alwaysNormalize
) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType)
}

function _createElement (
  context,
  tag,
  data,
  children,
  normalizationType
) {
  if (isDef(data) && isDef((data).__ob__)) {
    warn(
      "Avoid using observed data object as vnode data: " + (JSON.stringify(data)) + "\n" +
      'Always create fresh vnode data objects in each render!',
      context
    );
    return createEmptyVNode()
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode()
  }
  // warn against non-primitive key
  if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)
  ) {
    {
      warn(
        'Avoid using non-primitive value as key, ' +
        'use string/number value instead.',
        context
      );
    }
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) &&
    typeof children[0] === 'function'
  ) {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(
        config.parsePlatformTagName(tag), data, children,
        undefined, undefined, context
      );
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(
        tag, data, children,
        undefined, undefined, context
      );
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) { applyNS(vnode, ns); }
    if (isDef(data)) { registerDeepBindings(data); }
    return vnode
  } else {
    return createEmptyVNode()
  }
}

function applyNS (vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (
        isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {
        applyNS(child, ns, force);
      }
    }
  }
}

// ref #5318
// necessary to ensure parent re-render when deep bindings like :style and
// :class are used on slot nodes
function registerDeepBindings (data) {
  if (isObject(data.style)) {
    traverse(data.style);
  }
  if (isObject(data.class)) {
    traverse(data.class);
  }
}

/*  */

function initRender (vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  {
    defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  }
}

var currentRenderingInstance = null;

function renderMixin (Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this)
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (_parentVnode) {
      vm.$scopedSlots = normalizeScopedSlots(
        _parentVnode.data.scopedSlots,
        vm.$slots,
        vm.$scopedSlots
      );
    }

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      // There's no need to maintain a stack becaues all render fns are called
      // separately from one another. Nested component's render fns are called
      // when parent component is patched.
      currentRenderingInstance = vm;
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (vm.$options.renderError) {
        try {
          vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
        } catch (e) {
          handleError(e, vm, "renderError");
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    } finally {
      currentRenderingInstance = null;
    }
    // if the returned array contains only a single node, allow it
    if (Array.isArray(vnode) && vnode.length === 1) {
      vnode = vnode[0];
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if (Array.isArray(vnode)) {
        warn(
          'Multiple root nodes returned from render function. Render function ' +
          'should return a single root node.',
          vm
        );
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode
  };
}

/*  */

function ensureCtor (comp, base) {
  if (
    comp.__esModule ||
    (hasSymbol && comp[Symbol.toStringTag] === 'Module')
  ) {
    comp = comp.default;
  }
  return isObject(comp)
    ? base.extend(comp)
    : comp
}

function createAsyncPlaceholder (
  factory,
  data,
  context,
  children,
  tag
) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node
}

function resolveAsyncComponent (
  factory,
  baseCtor
) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp
  }

  if (isDef(factory.resolved)) {
    return factory.resolved
  }

  var owner = currentRenderingInstance;
  if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {
    // already pending
    factory.owners.push(owner);
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp
  }

  if (owner && !isDef(factory.owners)) {
    var owners = factory.owners = [owner];
    var sync = true;
    var timerLoading = null;
    var timerTimeout = null

    ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });

    var forceRender = function (renderCompleted) {
      for (var i = 0, l = owners.length; i < l; i++) {
        (owners[i]).$forceUpdate();
      }

      if (renderCompleted) {
        owners.length = 0;
        if (timerLoading !== null) {
          clearTimeout(timerLoading);
          timerLoading = null;
        }
        if (timerTimeout !== null) {
          clearTimeout(timerTimeout);
          timerTimeout = null;
        }
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender(true);
      } else {
        owners.length = 0;
      }
    });

    var reject = once(function (reason) {
      warn(
        "Failed to resolve async component: " + (String(factory)) +
        (reason ? ("\nReason: " + reason) : '')
      );
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender(true);
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (isPromise(res)) {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isPromise(res.component)) {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            timerLoading = setTimeout(function () {
              timerLoading = null;
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender(false);
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          timerTimeout = setTimeout(function () {
            timerTimeout = null;
            if (isUndef(factory.resolved)) {
              reject(
                "timeout (" + (res.timeout) + "ms)"
              );
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading
      ? factory.loadingComp
      : factory.resolved
  }
}

/*  */

function isAsyncPlaceholder (node) {
  return node.isComment && node.asyncFactory
}

/*  */

function getFirstComponentChild (children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c
      }
    }
  }
}

/*  */

/*  */

function initEvents (vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add (event, fn) {
  target.$on(event, fn);
}

function remove$1 (event, fn) {
  target.$off(event, fn);
}

function createOnceHandler (event, fn) {
  var _target = target;
  return function onceHandler () {
    var res = fn.apply(null, arguments);
    if (res !== null) {
      _target.$off(event, onceHandler);
    }
  }
}

function updateComponentListeners (
  vm,
  listeners,
  oldListeners
) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);
  target = undefined;
}

function eventsMixin (Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        vm.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on () {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm
  };

  Vue.prototype.$off = function (event, fn) {
    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {
        vm.$off(event[i$1], fn);
      }
      return vm
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm
    }
    if (!fn) {
      vm._events[event] = null;
      return vm
    }
    // specific handler
    var cb;
    var i = cbs.length;
    while (i--) {
      cb = cbs[i];
      if (cb === fn || cb.fn === fn) {
        cbs.splice(i, 1);
        break
      }
    }
    return vm
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip(
          "Event \"" + lowerCaseEvent + "\" is emitted in component " +
          (formatComponentName(vm)) + " but the handler is registered for \"" + event + "\". " +
          "Note that HTML attributes are case-insensitive and you cannot use " +
          "v-on to listen to camelCase events when using in-DOM templates. " +
          "You should probably use \"" + (hyphenate(event)) + "\" instead of \"" + event + "\"."
        );
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      var info = "event handler for \"" + event + "\"";
      for (var i = 0, l = cbs.length; i < l; i++) {
        invokeWithErrorHandling(cbs[i], vm, args, vm, info);
      }
    }
    return vm
  };
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function setActiveInstance(vm) {
  var prevActiveInstance = activeInstance;
  activeInstance = vm;
  return function () {
    activeInstance = prevActiveInstance;
  }
}

function initLifecycle (vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin (Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var restoreActiveInstance = setActiveInstance(vm);
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    restoreActiveInstance();
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent (
  vm,
  el,
  hydrating
) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    {
      /* istanbul ignore if */
      if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||
        vm.$options.el || el) {
        warn(
          'You are using the runtime-only build of Vue where the template ' +
          'compiler is not available. Either pre-compile the templates into ' +
          'render functions, or use the compiler-included build.',
          vm
        );
      } else {
        warn(
          'Failed to mount component: template or render function not defined.',
          vm
        );
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if (config.performance && mark) {
    updateComponent = function () {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure(("vue " + name + " render"), startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure(("vue " + name + " patch"), startTag, endTag);
    };
  } else {
    updateComponent = function () {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, {
    before: function before () {
      if (vm._isMounted && !vm._isDestroyed) {
        callHook(vm, 'beforeUpdate');
      }
    }
  }, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm
}

function updateChildComponent (
  vm,
  propsData,
  listeners,
  parentVnode,
  renderChildren
) {
  {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren.

  // check if there are dynamic scopedSlots (hand-written or compiled but with
  // dynamic slot names). Static scoped slots compiled from template has the
  // "$stable" marker.
  var newScopedSlots = parentVnode.data.scopedSlots;
  var oldScopedSlots = vm.$scopedSlots;
  var hasDynamicScopedSlot = !!(
    (newScopedSlots && !newScopedSlots.$stable) ||
    (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||
    (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)
  );

  // Any static slot children from the parent may have changed during parent's
  // update. Dynamic scoped slots may also have changed. In such cases, a forced
  // update is necessary to ensure correctness.
  var needsForceUpdate = !!(
    renderChildren ||               // has new static slots
    vm.$options._renderChildren ||  // has old static slots
    hasDynamicScopedSlot
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) { // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    toggleObserving(false);
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      var propOptions = vm.$options.props; // wtf flow?
      props[key] = validateProp(key, propOptions, propsData, vm);
    }
    toggleObserving(true);
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  listeners = listeners || emptyObject;
  var oldListeners = vm.$options._parentListeners;
  vm.$options._parentListeners = listeners;
  updateComponentListeners(vm, listeners, oldListeners);

  // resolve slots + force update if has children
  if (needsForceUpdate) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree (vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) { return true }
  }
  return false
}

function activateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return
    }
  } else if (vm._directInactive) {
    return
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent (vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook (vm, hook) {
  // #7573 disable dep collection when invoking lifecycle hooks
  pushTarget();
  var handlers = vm.$options[hook];
  var info = hook + " hook";
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      invokeWithErrorHandling(handlers[i], vm, null, vm, info);
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
  popTarget();
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState () {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  {
    circular = {};
  }
  waiting = flushing = false;
}

// Async edge case #6566 requires saving the timestamp when event listeners are
// attached. However, calling performance.now() has a perf overhead especially
// if the page has thousands of event listeners. Instead, we take a timestamp
// every time the scheduler flushes and use that for all event listeners
// attached during that flush.
var currentFlushTimestamp = 0;

// Async edge case fix requires storing an event listener's attach timestamp.
var getNow = Date.now;

// Determine what event timestamp the browser is using. Annoyingly, the
// timestamp can either be hi-res (relative to page load) or low-res
// (relative to UNIX epoch), so in order to compare time we have to use the
// same timestamp type when saving the flush timestamp.
// All IE versions use low-res event timestamps, and have problematic clock
// implementations (#9632)
if (inBrowser && !isIE) {
  var performance = window.performance;
  if (
    performance &&
    typeof performance.now === 'function' &&
    getNow() > document.createEvent('Event').timeStamp
  ) {
    // if the event timestamp, although evaluated AFTER the Date.now(), is
    // smaller than it, it means the event is using a hi-res timestamp,
    // and we need to use the hi-res version for event listener timestamps as
    // well.
    getNow = function () { return performance.now(); };
  }
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue () {
  currentFlushTimestamp = getNow();
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) { return a.id - b.id; });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    if (watcher.before) {
      watcher.before();
    }
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if (has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn(
          'You may have an infinite update loop ' + (
            watcher.user
              ? ("in watcher with expression \"" + (watcher.expression) + "\"")
              : "in a component render function."
          ),
          watcher.vm
        );
        break
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks (queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent (vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks (queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher (watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;

      if (!config.async) {
        flushSchedulerQueue();
        return
      }
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */



var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher (
  vm,
  expOrFn,
  cb,
  options,
  isRenderWatcher
) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
    this.before = options.before;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression = expOrFn.toString();
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = noop;
      warn(
        "Failed watching path: \"" + expOrFn + "\" " +
        'Watcher only accepts simple dot-delimited paths. ' +
        'For full control, use a function instead.',
        vm
      );
    }
  }
  this.value = this.lazy
    ? undefined
    : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get () {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, ("getter for watcher \"" + (this.expression) + "\""));
    } else {
      throw e
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep (dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps () {
  var i = this.deps.length;
  while (i--) {
    var dep = this.deps[i];
    if (!this.newDepIds.has(dep.id)) {
      dep.removeSub(this);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update () {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run () {
  if (this.active) {
    var value = this.get();
    if (
      value !== this.value ||
      // Deep watchers and watchers on Object/Arrays should fire even
      // when the value is the same, because the value may
      // have mutated.
      isObject(value) ||
      this.deep
    ) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, ("callback for watcher \"" + (this.expression) + "\""));
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate () {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend () {
  var i = this.deps.length;
  while (i--) {
    this.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown () {
  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this.deps[i].removeSub(this);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy (target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter () {
    return this[sourceKey][key]
  };
  sharedPropertyDefinition.set = function proxySetter (val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState (vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) { initProps(vm, opts.props); }
  if (opts.methods) { initMethods(vm, opts.methods); }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) { initComputed(vm, opts.computed); }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps (vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  if (!isRoot) {
    toggleObserving(false);
  }
  var loop = function ( key ) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) ||
          config.isReservedAttr(hyphenatedKey)) {
        warn(
          ("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop."),
          vm
        );
      }
      defineReactive$$1(props, key, value, function () {
        if (!isRoot && !isUpdatingChildComponent) {
          warn(
            "Avoid mutating a prop directly since the value will be " +
            "overwritten whenever the parent component re-renders. " +
            "Instead, use a data or computed property based on the prop's " +
            "value. Prop being mutated: \"" + key + "\"",
            vm
          );
        }
      });
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) loop( key );
  toggleObserving(true);
}

function initData (vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {};
  if (!isPlainObject(data)) {
    data = {};
    warn(
      'data functions should return an object:\n' +
      'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',
      vm
    );
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    {
      if (methods && hasOwn(methods, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a data property."),
          vm
        );
      }
    }
    if (props && hasOwn(props, key)) {
      warn(
        "The data property \"" + key + "\" is already declared as a prop. " +
        "Use prop default value instead.",
        vm
      );
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData (data, vm) {
  // #7573 disable dep collection when invoking data getters
  pushTarget();
  try {
    return data.call(vm, vm)
  } catch (e) {
    handleError(e, vm, "data()");
    return {}
  } finally {
    popTarget();
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed (vm, computed) {
  // $flow-disable-line
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if (getter == null) {
      warn(
        ("Getter is missing for computed property \"" + key + "\"."),
        vm
      );
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(
        vm,
        getter || noop,
        noop,
        computedWatcherOptions
      );
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else {
      if (key in vm.$data) {
        warn(("The computed property \"" + key + "\" is already defined in data."), vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn(("The computed property \"" + key + "\" is already defined as a prop."), vm);
      }
    }
  }
}

function defineComputed (
  target,
  key,
  userDef
) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef);
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache && userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop;
    sharedPropertyDefinition.set = userDef.set || noop;
  }
  if (sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        ("Computed property \"" + key + "\" was assigned to but it has no setter."),
        this
      );
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter (key) {
  return function computedGetter () {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value
    }
  }
}

function createGetterInvoker(fn) {
  return function computedGetter () {
    return fn.call(this, this)
  }
}

function initMethods (vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    {
      if (typeof methods[key] !== 'function') {
        warn(
          "Method \"" + key + "\" has type \"" + (typeof methods[key]) + "\" in the component definition. " +
          "Did you reference the function correctly?",
          vm
        );
      }
      if (props && hasOwn(props, key)) {
        warn(
          ("Method \"" + key + "\" has already been defined as a prop."),
          vm
        );
      }
      if ((key in vm) && isReserved(key)) {
        warn(
          "Method \"" + key + "\" conflicts with an existing Vue instance method. " +
          "Avoid defining component methods that start with _ or $."
        );
      }
    }
    vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);
  }
}

function initWatch (vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher (
  vm,
  expOrFn,
  handler,
  options
) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(expOrFn, handler, options)
}

function stateMixin (Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () { return this._data };
  var propsDef = {};
  propsDef.get = function () { return this._props };
  {
    dataDef.set = function () {
      warn(
        'Avoid replacing instance root $data. ' +
        'Use nested data properties instead.',
        this
      );
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (
    expOrFn,
    cb,
    options
  ) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options)
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      try {
        cb.call(vm, watcher.value);
      } catch (error) {
        handleError(error, vm, ("callback for immediate watcher \"" + (watcher.expression) + "\""));
      }
    }
    return function unwatchFn () {
      watcher.teardown();
    }
  };
}

/*  */

var uid$3 = 0;

function initMixin (Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$3++;

    var startTag, endTag;
    /* istanbul ignore if */
    if (config.performance && mark) {
      startTag = "vue-perf-start:" + (vm._uid);
      endTag = "vue-perf-end:" + (vm._uid);
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(
        resolveConstructorOptions(vm.constructor),
        options || {},
        vm
      );
    }
    /* istanbul ignore else */
    {
      initProxy(vm);
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if (config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure(("vue " + (vm._name) + " init"), startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent (vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  var parentVnode = options._parentVnode;
  opts.parent = options.parent;
  opts._parentVnode = parentVnode;

  var vnodeComponentOptions = parentVnode.componentOptions;
  opts.propsData = vnodeComponentOptions.propsData;
  opts._parentListeners = vnodeComponentOptions.listeners;
  opts._renderChildren = vnodeComponentOptions.children;
  opts._componentTag = vnodeComponentOptions.tag;

  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions (Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options
}

function resolveModifiedOptions (Ctor) {
  var modified;
  var latest = Ctor.options;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) { modified = {}; }
      modified[key] = latest[key];
    }
  }
  return modified
}

function Vue (options) {
  if (!(this instanceof Vue)
  ) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue);
stateMixin(Vue);
eventsMixin(Vue);
lifecycleMixin(Vue);
renderMixin(Vue);

/*  */

function initUse (Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this
  };
}

/*  */

function initMixin$1 (Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this
  };
}

/*  */

function initExtend (Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    var name = extendOptions.name || Super.options.name;
    if (name) {
      validateComponentName(name);
    }

    var Sub = function VueComponent (options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    );
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub
  };
}

function initProps$1 (Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1 (Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters (Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (
      id,
      definition
    ) {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (type === 'component') {
          validateComponentName(id);
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition
      }
    };
  });
}

/*  */



function getComponentName (opts) {
  return opts && (opts.Ctor.options.name || opts.tag)
}

function matches (pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1
  } else if (isRegExp(pattern)) {
    return pattern.test(name)
  }
  /* istanbul ignore next */
  return false
}

function pruneCache (keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry (
  cache,
  key,
  keys,
  current
) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created () {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed () {
    for (var key in this.cache) {
      pruneCacheEntry(this.cache, key, this.keys);
    }
  },

  mounted: function mounted () {
    var this$1 = this;

    this.$watch('include', function (val) {
      pruneCache(this$1, function (name) { return matches(val, name); });
    });
    this.$watch('exclude', function (val) {
      pruneCache(this$1, function (name) { return !matches(val, name); });
    });
  },

  render: function render () {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
        // not included
        (include && (!name || !matches(include, name))) ||
        // excluded
        (exclude && name && matches(exclude, name))
      ) {
        return vnode
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
        // same constructor may get registered as different local components
        // so cid alone is not enough (#3269)
        ? componentOptions.Ctor.cid + (componentOptions.tag ? ("::" + (componentOptions.tag)) : '')
        : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || (slot && slot[0])
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI (Vue) {
  // config
  var configDef = {};
  configDef.get = function () { return config; };
  {
    configDef.set = function () {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      );
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive$$1
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  // 2.6 explicit observable API
  Vue.observable = function (obj) {
    observe(obj);
    return obj
  };

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue);

Object.defineProperty(Vue.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue.prototype, '$ssrContext', {
  get: function get () {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext
  }
});

// expose FunctionalRenderContext for ssr runtime helper installation
Object.defineProperty(Vue, 'FunctionalRenderContext', {
  value: FunctionalRenderContext
});

Vue.version = '2.6.10';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function (tag, type, attr) {
  return (
    (attr === 'value' && acceptValue(tag)) && type !== 'button' ||
    (attr === 'selected' && tag === 'option') ||
    (attr === 'checked' && tag === 'input') ||
    (attr === 'muted' && tag === 'video')
  )
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');

var convertEnumeratedValue = function (key, value) {
  return isFalsyAttrValue(value) || value === 'false'
    ? 'false'
    // allow arbitrary string value for contenteditable
    : key === 'contenteditable' && isValidContentEditableValue(value)
      ? value
      : 'true'
};

var isBooleanAttr = makeMap(
  'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +
  'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +
  'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +
  'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +
  'required,reversed,scoped,seamless,selected,sortable,translate,' +
  'truespeed,typemustmatch,visible'
);

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function (name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'
};

var getXlinkProp = function (name) {
  return isXlink(name) ? name.slice(6, name.length) : ''
};

var isFalsyAttrValue = function (val) {
  return val == null || val === false
};

/*  */

function genClassForVnode (vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode && childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode && parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class)
}

function mergeClassData (child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class)
      ? [child.class, parent.class]
      : parent.class
  }
}

function renderClass (
  staticClass,
  dynamicClass
) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass))
  }
  /* istanbul ignore next */
  return ''
}

function concat (a, b) {
  return a ? b ? (a + ' ' + b) : a : (b || '')
}

function stringifyClass (value) {
  if (Array.isArray(value)) {
    return stringifyArray(value)
  }
  if (isObject(value)) {
    return stringifyObject(value)
  }
  if (typeof value === 'string') {
    return value
  }
  /* istanbul ignore next */
  return ''
}

function stringifyArray (value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) { res += ' '; }
      res += stringified;
    }
  }
  return res
}

function stringifyObject (value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) { res += ' '; }
      res += key;
    }
  }
  return res
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap(
  'html,body,base,head,link,meta,style,title,' +
  'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +
  'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +
  'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +
  's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +
  'embed,object,param,source,canvas,script,noscript,del,ins,' +
  'caption,col,colgroup,table,thead,tbody,td,th,tr,' +
  'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +
  'output,progress,select,textarea,' +
  'details,dialog,menu,menuitem,summary,' +
  'content,element,shadow,template,blockquote,iframe,tfoot'
);

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap(
  'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +
  'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +
  'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',
  true
);

var isReservedTag = function (tag) {
  return isHTMLTag(tag) || isSVG(tag)
};

function getTagNamespace (tag) {
  if (isSVG(tag)) {
    return 'svg'
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math'
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement (tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true
  }
  if (isReservedTag(tag)) {
    return false
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag]
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return (unknownElementCache[tag] = (
      el.constructor === window.HTMLUnknownElement ||
      el.constructor === window.HTMLElement
    ))
  } else {
    return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query (el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      warn(
        'Cannot find element: ' + el
      );
      return document.createElement('div')
    }
    return selected
  } else {
    return el
  }
}

/*  */

function createElement$1 (tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm
}

function createElementNS (namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName)
}

function createTextNode (text) {
  return document.createTextNode(text)
}

function createComment (text) {
  return document.createComment(text)
}

function insertBefore (parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild (node, child) {
  node.removeChild(child);
}

function appendChild (node, child) {
  node.appendChild(child);
}

function parentNode (node) {
  return node.parentNode
}

function nextSibling (node) {
  return node.nextSibling
}

function tagName (node) {
  return node.tagName
}

function setTextContent (node, text) {
  node.textContent = text;
}

function setStyleScope (node, scopeId) {
  node.setAttribute(scopeId, '');
}

var nodeOps = /*#__PURE__*/Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setStyleScope: setStyleScope
});

/*  */

var ref = {
  create: function create (_, vnode) {
    registerRef(vnode);
  },
  update: function update (oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy (vnode) {
    registerRef(vnode, true);
  }
};

function registerRef (vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!isDef(key)) { return }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode (a, b) {
  return (
    a.key === b.key && (
      (
        a.tag === b.tag &&
        a.isComment === b.isComment &&
        isDef(a.data) === isDef(b.data) &&
        sameInputType(a, b)
      ) || (
        isTrue(a.isAsyncPlaceholder) &&
        a.asyncFactory === b.asyncFactory &&
        isUndef(b.asyncFactory.error)
      )
    )
  )
}

function sameInputType (a, b) {
  if (a.tag !== 'input') { return true }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)
}

function createKeyToOldIdx (children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) { map[key] = i; }
  }
  return map
}

function createPatchFunction (backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt (elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)
  }

  function createRmCb (childElm, listeners) {
    function remove$$1 () {
      if (--remove$$1.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove$$1.listeners = listeners;
    return remove$$1
  }

  function removeNode (el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1 (vnode, inVPre) {
    return (
      !inVPre &&
      !vnode.ns &&
      !(
        config.ignoredElements.length &&
        config.ignoredElements.some(function (ignore) {
          return isRegExp(ignore)
            ? ignore.test(vnode.tag)
            : ignore === vnode.tag
        })
      ) &&
      config.isUnknownElement(vnode.tag)
    )
  }

  var creatingElmInVPre = 0;

  function createElm (
    vnode,
    insertedVnodeQueue,
    parentElm,
    refElm,
    nested,
    ownerArray,
    index
  ) {
    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // This vnode was used in a previous render!
      // now it's used as a new node, overwriting its elm would cause
      // potential patch errors down the road when it's used as an insertion
      // reference node. Instead, we clone the node on-demand before creating
      // associated DOM element for it.
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn(
            'Unknown custom element: <' + tag + '> - did you ' +
            'register the component correctly? For recursive components, ' +
            'make sure to provide the "name" option.',
            vnode.context
          );
        }
      }

      vnode.elm = vnode.ns
        ? nodeOps.createElementNS(vnode.ns, tag)
        : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if (data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        insert(parentElm, vnode.elm, refElm);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true
      }
    }
  }

  function initComponent (vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert (parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (nodeOps.parentNode(ref$$1) === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren (vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      {
        checkDuplicateKeys(children);
      }
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));
    }
  }

  function isPatchable (vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag)
  }

  function invokeCreateHooks (vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) { i.create(emptyNode, vnode); }
      if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope (vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setStyleScope(vnode.elm, i);
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setStyleScope(vnode.elm, i);
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) &&
      i !== vnode.context &&
      i !== vnode.fnContext &&
      isDef(i = i.$options._scopeId)
    ) {
      nodeOps.setStyleScope(vnode.elm, i);
    }
  }

  function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);
    }
  }

  function invokeDestroyHook (vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }
      for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else { // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook (vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    {
      checkDuplicateKeys(newCh);
    }

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }
        idxInOld = isDef(newStartVnode.key)
          ? oldKeyToIdx[newStartVnode.key]
          : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) { // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
        } else {
          vnodeToMove = oldCh[idxInOld];
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function checkDuplicateKeys (children) {
    var seenKeys = {};
    for (var i = 0; i < children.length; i++) {
      var vnode = children[i];
      var key = vnode.key;
      if (isDef(key)) {
        if (seenKeys[key]) {
          warn(
            ("Duplicate keys detected: '" + key + "'. This may cause an update error."),
            vnode.context
          );
        } else {
          seenKeys[key] = true;
        }
      }
    }
  }

  function findIdxInOld (node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) { return i }
    }
  }

  function patchVnode (
    oldVnode,
    vnode,
    insertedVnodeQueue,
    ownerArray,
    index,
    removeOnly
  ) {
    if (oldVnode === vnode) {
      return
    }

    if (isDef(vnode.elm) && isDef(ownerArray)) {
      // clone reused vnode
      vnode = ownerArray[index] = cloneVNode(vnode);
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) &&
      isTrue(oldVnode.isStatic) &&
      vnode.key === oldVnode.key &&
      (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))
    ) {
      vnode.componentInstance = oldVnode.componentInstance;
      return
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }
      if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }
      } else if (isDef(ch)) {
        {
          checkDuplicateKeys(ch);
        }
        if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }
    }
  }

  function invokeInsertHook (vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || (data && data.pre);
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true
    }
    // assert node match
    {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if (typeof console !== 'undefined' &&
                !hydrationBailed
              ) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true
  }

  function assertNodeMatch (node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || (
        !isUnknownElement$$1(vnode, inVPre) &&
        vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())
      )
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3)
    }
  }

  return function patch (oldVnode, vnode, hydrating, removeOnly) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }
      return
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode
            } else {
              warn(
                'The client-side rendered virtual DOM tree is not matching ' +
                'server-rendered content. This is likely caused by incorrect ' +
                'HTML markup, for example nesting block-level elements inside ' +
                '<p>, or missing <tbody>. Bailing hydration and performing ' +
                'full client-side render.'
              );
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm = nodeOps.parentNode(oldElm);

        // create new node
        createElm(
          vnode,
          insertedVnodeQueue,
          // extremely rare edge case: do not insert if old element is in a
          // leaving transition. Only happens when combining transition +
          // keep-alive + HOCs. (#4590)
          oldElm._leaveCb ? null : parentElm,
          nodeOps.nextSibling(oldElm)
        );

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm)) {
          removeVnodes(parentElm, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm
  }
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives (vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives (oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update (oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      dir.oldArg = oldDir.arg;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function () {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1 (
  dirs,
  vm
) {
  var res = Object.create(null);
  if (!dirs) {
    // $flow-disable-line
    return res
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      // $flow-disable-line
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  // $flow-disable-line
  return res
}

function getRawDirName (dir) {
  return dir.rawName || ((dir.name) + "." + (Object.keys(dir.modifiers || {}).join('.')))
}

function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, ("directive " + (dir.name) + " " + hook + " hook"));
    }
  }
}

var baseModules = [
  ref,
  directives
];

/*  */

function updateAttrs (oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr (el, key, value) {
  if (el.tagName.indexOf('-') > -1) {
    baseSetAttr(el, key, value);
  } else if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED'
        ? 'true'
        : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, convertEnumeratedValue(key, value));
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    baseSetAttr(el, key, value);
  }
}

function baseSetAttr (el, key, value) {
  if (isFalsyAttrValue(value)) {
    el.removeAttribute(key);
  } else {
    // #7138: IE10 & 11 fires input event when setting placeholder on
    // <textarea>... block the first input event and remove the blocker
    // immediately.
    /* istanbul ignore if */
    if (
      isIE && !isIE9 &&
      el.tagName === 'TEXTAREA' &&
      key === 'placeholder' && value !== '' && !el.__ieph
    ) {
      var blocker = function (e) {
        e.stopImmediatePropagation();
        el.removeEventListener('input', blocker);
      };
      el.addEventListener('input', blocker);
      // $flow-disable-line
      el.__ieph = true; /* IE placeholder patched */
    }
    el.setAttribute(key, value);
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass (oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (
    isUndef(data.staticClass) &&
    isUndef(data.class) && (
      isUndef(oldData) || (
        isUndef(oldData.staticClass) &&
        isUndef(oldData.class)
      )
    )
  ) {
    return
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

/*  */

/*  */

/*  */

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents (on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler$1 (event, handler, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler () {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  }
}

// #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp
// implementation and does not fire microtasks in between event propagation, so
// safe to exclude.
var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);

function add$1 (
  name,
  handler,
  capture,
  passive
) {
  // async edge case #6566: inner click event triggers patch, event handler
  // attached to outer element during patch, and triggered again. This
  // happens because browsers fire microtask ticks between event propagation.
  // the solution is simple: we save the timestamp when a handler is attached,
  // and the handler would only fire if the event passed to it was fired
  // AFTER it was attached.
  if (useMicrotaskFix) {
    var attachedTimestamp = currentFlushTimestamp;
    var original = handler;
    handler = original._wrapper = function (e) {
      if (
        // no bubbling, should always fire.
        // this is just a safety net in case event.timeStamp is unreliable in
        // certain weird environments...
        e.target === e.currentTarget ||
        // event is fired after handler attachment
        e.timeStamp >= attachedTimestamp ||
        // bail for environments that have buggy event.timeStamp implementations
        // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState
        // #9681 QtWebEngine event.timeStamp is negative value
        e.timeStamp <= 0 ||
        // #9448 bail if event is fired in another document in a multi-page
        // electron/nw.js app, since event.timeStamp will be using a different
        // starting reference
        e.target.ownerDocument !== document
      ) {
        return original.apply(this, arguments)
      }
    };
  }
  target$1.addEventListener(
    name,
    handler,
    supportsPassive
      ? { capture: capture, passive: passive }
      : capture
  );
}

function remove$2 (
  name,
  handler,
  capture,
  _target
) {
  (_target || target$1).removeEventListener(
    name,
    handler._wrapper || handler,
    capture
  );
}

function updateDOMListeners (oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

var svgContainer;

function updateDOMProps (oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (!(key in props)) {
      elm[key] = '';
    }
  }

  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) { vnode.children.length = 0; }
      if (cur === oldProps[key]) { continue }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value' && elm.tagName !== 'PROGRESS') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {
      // IE doesn't support innerHTML for SVG elements
      svgContainer = svgContainer || document.createElement('div');
      svgContainer.innerHTML = "<svg>" + cur + "</svg>";
      var svg = svgContainer.firstChild;
      while (elm.firstChild) {
        elm.removeChild(elm.firstChild);
      }
      while (svg.firstChild) {
        elm.appendChild(svg.firstChild);
      }
    } else if (
      // skip the update if old and new VDOM state is the same.
      // `value` is handled separately because the DOM value may be temporarily
      // out of sync with VDOM state due to focus, composition and modifiers.
      // This  #4521 by skipping the unnecesarry `checked` update.
      cur !== oldProps[key]
    ) {
      // some property updates can throw
      // e.g. `value` on <progress> w/ non-finite value
      try {
        elm[key] = cur;
      } catch (e) {}
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue (elm, checkVal) {
  return (!elm.composing && (
    elm.tagName === 'OPTION' ||
    isNotInFocusAndDirty(elm, checkVal) ||
    isDirtyWithModifiers(elm, checkVal)
  ))
}

function isNotInFocusAndDirty (elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try { notInFocus = document.activeElement !== elm; } catch (e) {}
  return notInFocus && elm.value !== checkVal
}

function isDirtyWithModifiers (elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers)) {
    if (modifiers.number) {
      return toNumber(value) !== toNumber(newVal)
    }
    if (modifiers.trim) {
      return value.trim() !== newVal.trim()
    }
  }
  return value !== newVal
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData (data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle
    ? extend(data.staticStyle, style)
    : style
}

// normalize possible array / string values into Object
function normalizeStyleBinding (bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle)
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle)
  }
  return bindingStyle
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle (vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (
        childNode && childNode.data &&
        (styleData = normalizeStyleData(childNode.data))
      ) {
        extend(res, styleData);
      }
    }
  }

  if ((styleData = normalizeStyleData(vnode.data))) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while ((parentNode = parentNode.parent)) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function (el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && (prop in emptyStyle)) {
    return prop
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name
    }
  }
});

function updateStyle (oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) &&
    isUndef(oldData.staticStyle) && isUndef(oldData.style)
  ) {
    return
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__)
    ? extend({}, style)
    : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

var whitespaceRE = /\s+/;

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass (el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition (def$$1) {
  if (!def$$1) {
    return
  }
  /* istanbul ignore else */
  if (typeof def$$1 === 'object') {
    var res = {};
    if (def$$1.css !== false) {
      extend(res, autoCssTransition(def$$1.name || 'v'));
    }
    extend(res, def$$1);
    return res
  } else if (typeof def$$1 === 'string') {
    return autoCssTransition(def$$1)
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: (name + "-enter"),
    enterToClass: (name + "-enter-to"),
    enterActiveClass: (name + "-enter-active"),
    leaveClass: (name + "-leave"),
    leaveToClass: (name + "-leave-to"),
    leaveActiveClass: (name + "-leave-active")
  }
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined &&
    window.onwebkittransitionend !== undefined
  ) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined &&
    window.onwebkitanimationend !== undefined
  ) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser
  ? window.requestAnimationFrame
    ? window.requestAnimationFrame.bind(window)
    : setTimeout
  : /* istanbul ignore next */ function (fn) { return fn(); };

function nextFrame (fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass (el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass (el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds (
  el,
  expectedType,
  cb
) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) { return cb() }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function () {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function (e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo (el, expectedType) {
  var styles = window.getComputedStyle(el);
  // JSDOM may return undefined for transition properties
  var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');
  var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');
  var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0
      ? transitionTimeout > animationTimeout
        ? TRANSITION
        : ANIMATION
      : null;
    propCount = type
      ? type === TRANSITION
        ? transitionDurations.length
        : animationDurations.length
      : 0;
  }
  var hasTransform =
    type === TRANSITION &&
    transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  }
}

function getTimeout (delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i])
  }))
}

// Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers
// in a locale-dependent way, using a comma instead of a dot.
// If comma is not replaced with a dot, the input will be rounded down (i.e. acting
// as a floor function) causing unexpected behaviors
function toMs (s) {
  return Number(s.slice(0, -1).replace(',', '.')) * 1000
}

/*  */

function enter (vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    context = transitionNode.context;
    transitionNode = transitionNode.parent;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return
  }

  var startClass = isAppear && appearClass
    ? appearClass
    : enterClass;
  var activeClass = isAppear && appearActiveClass
    ? appearActiveClass
    : enterActiveClass;
  var toClass = isAppear && appearToClass
    ? appearToClass
    : enterToClass;

  var beforeEnterHook = isAppear
    ? (beforeAppear || beforeEnter)
    : beforeEnter;
  var enterHook = isAppear
    ? (typeof appear === 'function' ? appear : enter)
    : enter;
  var afterEnterHook = isAppear
    ? (afterAppear || afterEnter)
    : afterEnter;
  var enterCancelledHook = isAppear
    ? (appearCancelled || enterCancelled)
    : enterCancelled;

  var explicitEnterDuration = toNumber(
    isObject(duration)
      ? duration.enter
      : duration
  );

  if (explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode &&
        pendingNode.tag === vnode.tag &&
        pendingNode.elm._leaveCb
      ) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      removeTransitionClass(el, startClass);
      if (!cb.cancelled) {
        addTransitionClass(el, toClass);
        if (!userWantsControl) {
          if (isValidDuration(explicitEnterDuration)) {
            setTimeout(cb, explicitEnterDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave (vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm()
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(
    isObject(duration)
      ? duration.leave
      : duration
  );

  if (isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave () {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return
    }
    // record leaving element
    if (!vnode.data.show && el.parentNode) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled) {
          addTransitionClass(el, leaveToClass);
          if (!userWantsControl) {
            if (isValidDuration(explicitLeaveDuration)) {
              setTimeout(cb, explicitLeaveDuration);
            } else {
              whenTransitionEnds(el, type, cb);
            }
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration (val, name, vnode) {
  if (typeof val !== 'number') {
    warn(
      "<transition> explicit " + name + " duration is not a valid number - " +
      "got " + (JSON.stringify(val)) + ".",
      vnode.context
    );
  } else if (isNaN(val)) {
    warn(
      "<transition> explicit " + name + " duration is NaN - " +
      'the duration expression might be incorrect.',
      vnode.context
    );
  }
}

function isValidDuration (val) {
  return typeof val === 'number' && !isNaN(val)
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength (fn) {
  if (isUndef(fn)) {
    return false
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(
      Array.isArray(invokerFns)
        ? invokerFns[0]
        : invokerFns
    )
  } else {
    return (fn._length || fn.length) > 1
  }
}

function _enter (_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1 (vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [
  attrs,
  klass,
  events,
  domProps,
  style,
  transition
];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted (el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        el.addEventListener('compositionstart', onCompositionStart);
        el.addEventListener('compositionend', onCompositionEnd);
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated (el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple
          ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })
          : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected (el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected (el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    warn(
      "<select multiple v-model=\"" + (binding.expression) + "\"> " +
      "expects an Array value for its binding, but got " + (Object.prototype.toString.call(value).slice(8, -1)),
      vm
    );
    return
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption (value, options) {
  return options.every(function (o) { return !looseEqual(o, value); })
}

function getValue (option) {
  return '_value' in option
    ? option._value
    : option.value
}

function onCompositionStart (e) {
  e.target.composing = true;
}

function onCompositionEnd (e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) { return }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger (el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode (vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition)
    ? locateNode(vnode.componentInstance._vnode)
    : vnode
}

var show = {
  bind: function bind (el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay =
      el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update (el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (!value === !oldValue) { return }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind (
    el,
    binding,
    vnode,
    oldVnode,
    isDestroy
  ) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild (vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children))
  } else {
    return vnode
  }
}

function extractTransitionData (comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data
}

function placeholder (h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    })
  }
}

function hasParentTransition (vnode) {
  while ((vnode = vnode.parent)) {
    if (vnode.data.transition) {
      return true
    }
  }
}

function isSameChild (child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag
}

var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };

var isVShowDirective = function (d) { return d.name === 'show'; };

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render (h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(isNotTextNode);
    /* istanbul ignore if */
    if (!children.length) {
      return
    }

    // warn multiple elements
    if (children.length > 1) {
      warn(
        '<transition> can only be used on a single element. Use ' +
        '<transition-group> for lists.',
        this.$parent
      );
    }

    var mode = this.mode;

    // warn invalid mode
    if (mode && mode !== 'in-out' && mode !== 'out-in'
    ) {
      warn(
        'invalid <transition> mode: ' + mode,
        this.$parent
      );
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild
    }

    if (this._leaving) {
      return placeholder(h, rawChild)
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + (this._uid) + "-";
    child.key = child.key == null
      ? child.isComment
        ? id + 'comment'
        : id + child.tag
      : isPrimitive(child.key)
        ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)
        : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(isVShowDirective)) {
      child.data.show = true;
    }

    if (
      oldChild &&
      oldChild.data &&
      !isSameChild(child, oldChild) &&
      !isAsyncPlaceholder(oldChild) &&
      // #6687 component root is a comment node
      !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)
    ) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild)
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild
        }
        var delayedLeave;
        var performLeave = function () { delayedLeave(); };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });
      }
    }

    return rawChild
  }
};

/*  */

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  beforeMount: function beforeMount () {
    var this$1 = this;

    var update = this._update;
    this._update = function (vnode, hydrating) {
      var restoreActiveInstance = setActiveInstance(this$1);
      // force removing pass
      this$1.__patch__(
        this$1._vnode,
        this$1.kept,
        false, // hydrating
        true // removeOnly (!important, avoids unnecessary moves)
      );
      this$1._vnode = this$1.kept;
      restoreActiveInstance();
      update.call(this$1, vnode, hydrating);
    };
  },

  render: function render (h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c
          ;(c.data || (c.data = {})).transition = transitionData;
        } else {
          var opts = c.componentOptions;
          var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;
          warn(("<transition-group> children must be keyed: <" + name + ">"));
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children)
  },

  updated: function updated () {
    var children = this.prevChildren;
    var moveClass = this.moveClass || ((this.name || 'v') + '-move');
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {
          if (e && e.target !== el) {
            return
          }
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove (el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return (this._hasMove = info.hasTransform)
    }
  }
};

function callPendingCbs (c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition (c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation (c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue.config.mustUseProp = mustUseProp;
Vue.config.isReservedTag = isReservedTag;
Vue.config.isReservedAttr = isReservedAttr;
Vue.config.getTagNamespace = getTagNamespace;
Vue.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue.options.directives, platformDirectives);
extend(Vue.options.components, platformComponents);

// install platform patch function
Vue.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue.prototype.$mount = function (
  el,
  hydrating
) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating)
};

// devtools global hook
/* istanbul ignore next */
if (inBrowser) {
  setTimeout(function () {
    if (config.devtools) {
      if (devtools) {
        devtools.emit('init', Vue);
      } else {
        console[console.info ? 'info' : 'log'](
          'Download the Vue Devtools extension for a better development experience:\n' +
          'https://github.com/vuejs/vue-devtools'
        );
      }
    }
    if (config.productionTip !== false &&
      typeof console !== 'undefined'
    ) {
      console[console.info ? 'info' : 'log'](
        "You are running Vue in development mode.\n" +
        "Make sure to turn on production mode when deploying for production.\n" +
        "See more tips at https://vuejs.org/guide/deployment.html"
      );
    }
  }, 0);
}

/*  */

module.exports = Vue;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],515:[function(require,module,exports){
(function (process){
if (process.env.NODE_ENV === 'production') {
  module.exports = require('./vue.runtime.common.prod.js')
} else {
  module.exports = require('./vue.runtime.common.dev.js')
}

}).call(this,require('_process'))

},{"./vue.runtime.common.dev.js":514,"./vue.runtime.common.prod.js":516,"_process":491}],516:[function(require,module,exports){
(function (global){
/*!
 * Vue.js v2.6.10
 * (c) 2014-2019 Evan You
 * Released under the MIT License.
 */
"use strict";var t=Object.freeze({});function e(t){return null==t}function n(t){return null!=t}function r(t){return!0===t}function o(t){return"string"==typeof t||"number"==typeof t||"symbol"==typeof t||"boolean"==typeof t}function i(t){return null!==t&&"object"==typeof t}var a=Object.prototype.toString;function s(t){return"[object Object]"===a.call(t)}function c(t){var e=parseFloat(String(t));return e>=0&&Math.floor(e)===e&&isFinite(t)}function u(t){return n(t)&&"function"==typeof t.then&&"function"==typeof t.catch}function l(t){return null==t?"":Array.isArray(t)||s(t)&&t.toString===a?JSON.stringify(t,null,2):String(t)}function f(t){var e=parseFloat(t);return isNaN(e)?t:e}function p(t,e){for(var n=Object.create(null),r=t.split(","),o=0;o<r.length;o++)n[r[o]]=!0;return e?function(t){return n[t.toLowerCase()]}:function(t){return n[t]}}var d=p("key,ref,slot,slot-scope,is");function v(t,e){if(t.length){var n=t.indexOf(e);if(n>-1)return t.splice(n,1)}}var h=Object.prototype.hasOwnProperty;function m(t,e){return h.call(t,e)}function y(t){var e=Object.create(null);return function(n){return e[n]||(e[n]=t(n))}}var g=/-(\w)/g,_=y(function(t){return t.replace(g,function(t,e){return e?e.toUpperCase():""})}),b=y(function(t){return t.charAt(0).toUpperCase()+t.slice(1)}),C=/\B([A-Z])/g,$=y(function(t){return t.replace(C,"-$1").toLowerCase()});var w=Function.prototype.bind?function(t,e){return t.bind(e)}:function(t,e){function n(n){var r=arguments.length;return r?r>1?t.apply(e,arguments):t.call(e,n):t.call(e)}return n._length=t.length,n};function A(t,e){e=e||0;for(var n=t.length-e,r=new Array(n);n--;)r[n]=t[n+e];return r}function x(t,e){for(var n in e)t[n]=e[n];return t}function O(t){for(var e={},n=0;n<t.length;n++)t[n]&&x(e,t[n]);return e}function k(t,e,n){}var S=function(t,e,n){return!1},E=function(t){return t};function j(t,e){if(t===e)return!0;var n=i(t),r=i(e);if(!n||!r)return!n&&!r&&String(t)===String(e);try{var o=Array.isArray(t),a=Array.isArray(e);if(o&&a)return t.length===e.length&&t.every(function(t,n){return j(t,e[n])});if(t instanceof Date&&e instanceof Date)return t.getTime()===e.getTime();if(o||a)return!1;var s=Object.keys(t),c=Object.keys(e);return s.length===c.length&&s.every(function(n){return j(t[n],e[n])})}catch(t){return!1}}function T(t,e){for(var n=0;n<t.length;n++)if(j(t[n],e))return n;return-1}function I(t){var e=!1;return function(){e||(e=!0,t.apply(this,arguments))}}var D="data-server-rendered",N=["component","directive","filter"],P=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],L={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:S,isReservedAttr:S,isUnknownElement:S,getTagNamespace:k,parsePlatformTagName:E,mustUseProp:S,async:!0,_lifecycleHooks:P};function M(t,e,n,r){Object.defineProperty(t,e,{value:n,enumerable:!!r,writable:!0,configurable:!0})}var F=new RegExp("[^"+/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/.source+".$_\\d]");var R,U="__proto__"in{},H="undefined"!=typeof window,B="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,V=B&&WXEnvironment.platform.toLowerCase(),z=H&&window.navigator.userAgent.toLowerCase(),W=z&&/msie|trident/.test(z),q=z&&z.indexOf("msie 9.0")>0,K=z&&z.indexOf("edge/")>0,X=(z&&z.indexOf("android"),z&&/iphone|ipad|ipod|ios/.test(z)||"ios"===V),G=(z&&/chrome\/\d+/.test(z),z&&/phantomjs/.test(z),z&&z.match(/firefox\/(\d+)/)),Z={}.watch,J=!1;if(H)try{var Q={};Object.defineProperty(Q,"passive",{get:function(){J=!0}}),window.addEventListener("test-passive",null,Q)}catch(t){}var Y=function(){return void 0===R&&(R=!H&&!B&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),R},tt=H&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function et(t){return"function"==typeof t&&/native code/.test(t.toString())}var nt,rt="undefined"!=typeof Symbol&&et(Symbol)&&"undefined"!=typeof Reflect&&et(Reflect.ownKeys);nt="undefined"!=typeof Set&&et(Set)?Set:function(){function t(){this.set=Object.create(null)}return t.prototype.has=function(t){return!0===this.set[t]},t.prototype.add=function(t){this.set[t]=!0},t.prototype.clear=function(){this.set=Object.create(null)},t}();var ot=k,it=0,at=function(){this.id=it++,this.subs=[]};at.prototype.addSub=function(t){this.subs.push(t)},at.prototype.removeSub=function(t){v(this.subs,t)},at.prototype.depend=function(){at.target&&at.target.addDep(this)},at.prototype.notify=function(){for(var t=this.subs.slice(),e=0,n=t.length;e<n;e++)t[e].update()},at.target=null;var st=[];function ct(t){st.push(t),at.target=t}function ut(){st.pop(),at.target=st[st.length-1]}var lt=function(t,e,n,r,o,i,a,s){this.tag=t,this.data=e,this.children=n,this.text=r,this.elm=o,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},ft={child:{configurable:!0}};ft.child.get=function(){return this.componentInstance},Object.defineProperties(lt.prototype,ft);var pt=function(t){void 0===t&&(t="");var e=new lt;return e.text=t,e.isComment=!0,e};function dt(t){return new lt(void 0,void 0,void 0,String(t))}function vt(t){var e=new lt(t.tag,t.data,t.children&&t.children.slice(),t.text,t.elm,t.context,t.componentOptions,t.asyncFactory);return e.ns=t.ns,e.isStatic=t.isStatic,e.key=t.key,e.isComment=t.isComment,e.fnContext=t.fnContext,e.fnOptions=t.fnOptions,e.fnScopeId=t.fnScopeId,e.asyncMeta=t.asyncMeta,e.isCloned=!0,e}var ht=Array.prototype,mt=Object.create(ht);["push","pop","shift","unshift","splice","sort","reverse"].forEach(function(t){var e=ht[t];M(mt,t,function(){for(var n=[],r=arguments.length;r--;)n[r]=arguments[r];var o,i=e.apply(this,n),a=this.__ob__;switch(t){case"push":case"unshift":o=n;break;case"splice":o=n.slice(2)}return o&&a.observeArray(o),a.dep.notify(),i})});var yt=Object.getOwnPropertyNames(mt),gt=!0;function _t(t){gt=t}var bt=function(t){var e;this.value=t,this.dep=new at,this.vmCount=0,M(t,"__ob__",this),Array.isArray(t)?(U?(e=mt,t.__proto__=e):function(t,e,n){for(var r=0,o=n.length;r<o;r++){var i=n[r];M(t,i,e[i])}}(t,mt,yt),this.observeArray(t)):this.walk(t)};function Ct(t,e){var n;if(i(t)&&!(t instanceof lt))return m(t,"__ob__")&&t.__ob__ instanceof bt?n=t.__ob__:gt&&!Y()&&(Array.isArray(t)||s(t))&&Object.isExtensible(t)&&!t._isVue&&(n=new bt(t)),e&&n&&n.vmCount++,n}function $t(t,e,n,r,o){var i=new at,a=Object.getOwnPropertyDescriptor(t,e);if(!a||!1!==a.configurable){var s=a&&a.get,c=a&&a.set;s&&!c||2!==arguments.length||(n=t[e]);var u=!o&&Ct(n);Object.defineProperty(t,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(t):n;return at.target&&(i.depend(),u&&(u.dep.depend(),Array.isArray(e)&&function t(e){for(var n=void 0,r=0,o=e.length;r<o;r++)(n=e[r])&&n.__ob__&&n.__ob__.dep.depend(),Array.isArray(n)&&t(n)}(e))),e},set:function(e){var r=s?s.call(t):n;e===r||e!=e&&r!=r||s&&!c||(c?c.call(t,e):n=e,u=!o&&Ct(e),i.notify())}})}}function wt(t,e,n){if(Array.isArray(t)&&c(e))return t.length=Math.max(t.length,e),t.splice(e,1,n),n;if(e in t&&!(e in Object.prototype))return t[e]=n,n;var r=t.__ob__;return t._isVue||r&&r.vmCount?n:r?($t(r.value,e,n),r.dep.notify(),n):(t[e]=n,n)}function At(t,e){if(Array.isArray(t)&&c(e))t.splice(e,1);else{var n=t.__ob__;t._isVue||n&&n.vmCount||m(t,e)&&(delete t[e],n&&n.dep.notify())}}bt.prototype.walk=function(t){for(var e=Object.keys(t),n=0;n<e.length;n++)$t(t,e[n])},bt.prototype.observeArray=function(t){for(var e=0,n=t.length;e<n;e++)Ct(t[e])};var xt=L.optionMergeStrategies;function Ot(t,e){if(!e)return t;for(var n,r,o,i=rt?Reflect.ownKeys(e):Object.keys(e),a=0;a<i.length;a++)"__ob__"!==(n=i[a])&&(r=t[n],o=e[n],m(t,n)?r!==o&&s(r)&&s(o)&&Ot(r,o):wt(t,n,o));return t}function kt(t,e,n){return n?function(){var r="function"==typeof e?e.call(n,n):e,o="function"==typeof t?t.call(n,n):t;return r?Ot(r,o):o}:e?t?function(){return Ot("function"==typeof e?e.call(this,this):e,"function"==typeof t?t.call(this,this):t)}:e:t}function St(t,e){var n=e?t?t.concat(e):Array.isArray(e)?e:[e]:t;return n?function(t){for(var e=[],n=0;n<t.length;n++)-1===e.indexOf(t[n])&&e.push(t[n]);return e}(n):n}function Et(t,e,n,r){var o=Object.create(t||null);return e?x(o,e):o}xt.data=function(t,e,n){return n?kt(t,e,n):e&&"function"!=typeof e?t:kt(t,e)},P.forEach(function(t){xt[t]=St}),N.forEach(function(t){xt[t+"s"]=Et}),xt.watch=function(t,e,n,r){if(t===Z&&(t=void 0),e===Z&&(e=void 0),!e)return Object.create(t||null);if(!t)return e;var o={};for(var i in x(o,t),e){var a=o[i],s=e[i];a&&!Array.isArray(a)&&(a=[a]),o[i]=a?a.concat(s):Array.isArray(s)?s:[s]}return o},xt.props=xt.methods=xt.inject=xt.computed=function(t,e,n,r){if(!t)return e;var o=Object.create(null);return x(o,t),e&&x(o,e),o},xt.provide=kt;var jt=function(t,e){return void 0===e?t:e};function Tt(t,e,n){if("function"==typeof e&&(e=e.options),function(t,e){var n=t.props;if(n){var r,o,i={};if(Array.isArray(n))for(r=n.length;r--;)"string"==typeof(o=n[r])&&(i[_(o)]={type:null});else if(s(n))for(var a in n)o=n[a],i[_(a)]=s(o)?o:{type:o};t.props=i}}(e),function(t,e){var n=t.inject;if(n){var r=t.inject={};if(Array.isArray(n))for(var o=0;o<n.length;o++)r[n[o]]={from:n[o]};else if(s(n))for(var i in n){var a=n[i];r[i]=s(a)?x({from:i},a):{from:a}}}}(e),function(t){var e=t.directives;if(e)for(var n in e){var r=e[n];"function"==typeof r&&(e[n]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(t=Tt(t,e.extends,n)),e.mixins))for(var r=0,o=e.mixins.length;r<o;r++)t=Tt(t,e.mixins[r],n);var i,a={};for(i in t)c(i);for(i in e)m(t,i)||c(i);function c(r){var o=xt[r]||jt;a[r]=o(t[r],e[r],n,r)}return a}function It(t,e,n,r){if("string"==typeof n){var o=t[e];if(m(o,n))return o[n];var i=_(n);if(m(o,i))return o[i];var a=b(i);return m(o,a)?o[a]:o[n]||o[i]||o[a]}}function Dt(t,e,n,r){var o=e[t],i=!m(n,t),a=n[t],s=Lt(Boolean,o.type);if(s>-1)if(i&&!m(o,"default"))a=!1;else if(""===a||a===$(t)){var c=Lt(String,o.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(t,e,n){if(!m(e,"default"))return;var r=e.default;if(t&&t.$options.propsData&&void 0===t.$options.propsData[n]&&void 0!==t._props[n])return t._props[n];return"function"==typeof r&&"Function"!==Nt(e.type)?r.call(t):r}(r,o,t);var u=gt;_t(!0),Ct(a),_t(u)}return a}function Nt(t){var e=t&&t.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function Pt(t,e){return Nt(t)===Nt(e)}function Lt(t,e){if(!Array.isArray(e))return Pt(e,t)?0:-1;for(var n=0,r=e.length;n<r;n++)if(Pt(e[n],t))return n;return-1}function Mt(t,e,n){ct();try{if(e)for(var r=e;r=r.$parent;){var o=r.$options.errorCaptured;if(o)for(var i=0;i<o.length;i++)try{if(!1===o[i].call(r,t,e,n))return}catch(t){Rt(t,r,"errorCaptured hook")}}Rt(t,e,n)}finally{ut()}}function Ft(t,e,n,r,o){var i;try{(i=n?t.apply(e,n):t.call(e))&&!i._isVue&&u(i)&&!i._handled&&(i.catch(function(t){return Mt(t,r,o+" (Promise/async)")}),i._handled=!0)}catch(t){Mt(t,r,o)}return i}function Rt(t,e,n){if(L.errorHandler)try{return L.errorHandler.call(null,t,e,n)}catch(e){e!==t&&Ut(e,null,"config.errorHandler")}Ut(t,e,n)}function Ut(t,e,n){if(!H&&!B||"undefined"==typeof console)throw t;console.error(t)}var Ht,Bt=!1,Vt=[],zt=!1;function Wt(){zt=!1;var t=Vt.slice(0);Vt.length=0;for(var e=0;e<t.length;e++)t[e]()}if("undefined"!=typeof Promise&&et(Promise)){var qt=Promise.resolve();Ht=function(){qt.then(Wt),X&&setTimeout(k)},Bt=!0}else if(W||"undefined"==typeof MutationObserver||!et(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ht="undefined"!=typeof setImmediate&&et(setImmediate)?function(){setImmediate(Wt)}:function(){setTimeout(Wt,0)};else{var Kt=1,Xt=new MutationObserver(Wt),Gt=document.createTextNode(String(Kt));Xt.observe(Gt,{characterData:!0}),Ht=function(){Kt=(Kt+1)%2,Gt.data=String(Kt)},Bt=!0}function Zt(t,e){var n;if(Vt.push(function(){if(t)try{t.call(e)}catch(t){Mt(t,e,"nextTick")}else n&&n(e)}),zt||(zt=!0,Ht()),!t&&"undefined"!=typeof Promise)return new Promise(function(t){n=t})}var Jt=new nt;function Qt(t){!function t(e,n){var r,o;var a=Array.isArray(e);if(!a&&!i(e)||Object.isFrozen(e)||e instanceof lt)return;if(e.__ob__){var s=e.__ob__.dep.id;if(n.has(s))return;n.add(s)}if(a)for(r=e.length;r--;)t(e[r],n);else for(o=Object.keys(e),r=o.length;r--;)t(e[o[r]],n)}(t,Jt),Jt.clear()}var Yt=y(function(t){var e="&"===t.charAt(0),n="~"===(t=e?t.slice(1):t).charAt(0),r="!"===(t=n?t.slice(1):t).charAt(0);return{name:t=r?t.slice(1):t,once:n,capture:r,passive:e}});function te(t,e){function n(){var t=arguments,r=n.fns;if(!Array.isArray(r))return Ft(r,null,arguments,e,"v-on handler");for(var o=r.slice(),i=0;i<o.length;i++)Ft(o[i],null,t,e,"v-on handler")}return n.fns=t,n}function ee(t,n,o,i,a,s){var c,u,l,f;for(c in t)u=t[c],l=n[c],f=Yt(c),e(u)||(e(l)?(e(u.fns)&&(u=t[c]=te(u,s)),r(f.once)&&(u=t[c]=a(f.name,u,f.capture)),o(f.name,u,f.capture,f.passive,f.params)):u!==l&&(l.fns=u,t[c]=l));for(c in n)e(t[c])&&i((f=Yt(c)).name,n[c],f.capture)}function ne(t,o,i){var a;t instanceof lt&&(t=t.data.hook||(t.data.hook={}));var s=t[o];function c(){i.apply(this,arguments),v(a.fns,c)}e(s)?a=te([c]):n(s.fns)&&r(s.merged)?(a=s).fns.push(c):a=te([s,c]),a.merged=!0,t[o]=a}function re(t,e,r,o,i){if(n(e)){if(m(e,r))return t[r]=e[r],i||delete e[r],!0;if(m(e,o))return t[r]=e[o],i||delete e[o],!0}return!1}function oe(t){return o(t)?[dt(t)]:Array.isArray(t)?function t(i,a){var s=[];var c,u,l,f;for(c=0;c<i.length;c++)e(u=i[c])||"boolean"==typeof u||(l=s.length-1,f=s[l],Array.isArray(u)?u.length>0&&(ie((u=t(u,(a||"")+"_"+c))[0])&&ie(f)&&(s[l]=dt(f.text+u[0].text),u.shift()),s.push.apply(s,u)):o(u)?ie(f)?s[l]=dt(f.text+u):""!==u&&s.push(dt(u)):ie(u)&&ie(f)?s[l]=dt(f.text+u.text):(r(i._isVList)&&n(u.tag)&&e(u.key)&&n(a)&&(u.key="__vlist"+a+"_"+c+"__"),s.push(u)));return s}(t):void 0}function ie(t){return n(t)&&n(t.text)&&!1===t.isComment}function ae(t,e){if(t){for(var n=Object.create(null),r=rt?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++){var i=r[o];if("__ob__"!==i){for(var a=t[i].from,s=e;s;){if(s._provided&&m(s._provided,a)){n[i]=s._provided[a];break}s=s.$parent}if(!s&&"default"in t[i]){var c=t[i].default;n[i]="function"==typeof c?c.call(e):c}}}return n}}function se(t,e){if(!t||!t.length)return{};for(var n={},r=0,o=t.length;r<o;r++){var i=t[r],a=i.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,i.context!==e&&i.fnContext!==e||!a||null==a.slot)(n.default||(n.default=[])).push(i);else{var s=a.slot,c=n[s]||(n[s]=[]);"template"===i.tag?c.push.apply(c,i.children||[]):c.push(i)}}for(var u in n)n[u].every(ce)&&delete n[u];return n}function ce(t){return t.isComment&&!t.asyncFactory||" "===t.text}function ue(e,n,r){var o,i=Object.keys(n).length>0,a=e?!!e.$stable:!i,s=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(a&&r&&r!==t&&s===r.$key&&!i&&!r.$hasNormal)return r;for(var c in o={},e)e[c]&&"$"!==c[0]&&(o[c]=le(n,c,e[c]))}else o={};for(var u in n)u in o||(o[u]=fe(n,u));return e&&Object.isExtensible(e)&&(e._normalized=o),M(o,"$stable",a),M(o,"$key",s),M(o,"$hasNormal",i),o}function le(t,e,n){var r=function(){var t=arguments.length?n.apply(null,arguments):n({});return(t=t&&"object"==typeof t&&!Array.isArray(t)?[t]:oe(t))&&(0===t.length||1===t.length&&t[0].isComment)?void 0:t};return n.proxy&&Object.defineProperty(t,e,{get:r,enumerable:!0,configurable:!0}),r}function fe(t,e){return function(){return t[e]}}function pe(t,e){var r,o,a,s,c;if(Array.isArray(t)||"string"==typeof t)for(r=new Array(t.length),o=0,a=t.length;o<a;o++)r[o]=e(t[o],o);else if("number"==typeof t)for(r=new Array(t),o=0;o<t;o++)r[o]=e(o+1,o);else if(i(t))if(rt&&t[Symbol.iterator]){r=[];for(var u=t[Symbol.iterator](),l=u.next();!l.done;)r.push(e(l.value,r.length)),l=u.next()}else for(s=Object.keys(t),r=new Array(s.length),o=0,a=s.length;o<a;o++)c=s[o],r[o]=e(t[c],c,o);return n(r)||(r=[]),r._isVList=!0,r}function de(t,e,n,r){var o,i=this.$scopedSlots[t];i?(n=n||{},r&&(n=x(x({},r),n)),o=i(n)||e):o=this.$slots[t]||e;var a=n&&n.slot;return a?this.$createElement("template",{slot:a},o):o}function ve(t){return It(this.$options,"filters",t)||E}function he(t,e){return Array.isArray(t)?-1===t.indexOf(e):t!==e}function me(t,e,n,r,o){var i=L.keyCodes[e]||n;return o&&r&&!L.keyCodes[e]?he(o,r):i?he(i,t):r?$(r)!==e:void 0}function ye(t,e,n,r,o){if(n)if(i(n)){var a;Array.isArray(n)&&(n=O(n));var s=function(i){if("class"===i||"style"===i||d(i))a=t;else{var s=t.attrs&&t.attrs.type;a=r||L.mustUseProp(e,s,i)?t.domProps||(t.domProps={}):t.attrs||(t.attrs={})}var c=_(i),u=$(i);c in a||u in a||(a[i]=n[i],o&&((t.on||(t.on={}))["update:"+i]=function(t){n[i]=t}))};for(var c in n)s(c)}else;return t}function ge(t,e){var n=this._staticTrees||(this._staticTrees=[]),r=n[t];return r&&!e?r:(be(r=n[t]=this.$options.staticRenderFns[t].call(this._renderProxy,null,this),"__static__"+t,!1),r)}function _e(t,e,n){return be(t,"__once__"+e+(n?"_"+n:""),!0),t}function be(t,e,n){if(Array.isArray(t))for(var r=0;r<t.length;r++)t[r]&&"string"!=typeof t[r]&&Ce(t[r],e+"_"+r,n);else Ce(t,e,n)}function Ce(t,e,n){t.isStatic=!0,t.key=e,t.isOnce=n}function $e(t,e){if(e)if(s(e)){var n=t.on=t.on?x({},t.on):{};for(var r in e){var o=n[r],i=e[r];n[r]=o?[].concat(o,i):i}}else;return t}function we(t,e,n,r){e=e||{$stable:!n};for(var o=0;o<t.length;o++){var i=t[o];Array.isArray(i)?we(i,e,n):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return r&&(e.$key=r),e}function Ae(t,e){for(var n=0;n<e.length;n+=2){var r=e[n];"string"==typeof r&&r&&(t[e[n]]=e[n+1])}return t}function xe(t,e){return"string"==typeof t?e+t:t}function Oe(t){t._o=_e,t._n=f,t._s=l,t._l=pe,t._t=de,t._q=j,t._i=T,t._m=ge,t._f=ve,t._k=me,t._b=ye,t._v=dt,t._e=pt,t._u=we,t._g=$e,t._d=Ae,t._p=xe}function ke(e,n,o,i,a){var s,c=this,u=a.options;m(i,"_uid")?(s=Object.create(i))._original=i:(s=i,i=i._original);var l=r(u._compiled),f=!l;this.data=e,this.props=n,this.children=o,this.parent=i,this.listeners=e.on||t,this.injections=ae(u.inject,i),this.slots=function(){return c.$slots||ue(e.scopedSlots,c.$slots=se(o,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ue(e.scopedSlots,this.slots())}}),l&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=ue(e.scopedSlots,this.$slots)),u._scopeId?this._c=function(t,e,n,r){var o=Le(s,t,e,n,r,f);return o&&!Array.isArray(o)&&(o.fnScopeId=u._scopeId,o.fnContext=i),o}:this._c=function(t,e,n,r){return Le(s,t,e,n,r,f)}}function Se(t,e,n,r,o){var i=vt(t);return i.fnContext=n,i.fnOptions=r,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Ee(t,e){for(var n in e)t[_(n)]=e[n]}Oe(ke.prototype);var je={init:function(t,e){if(t.componentInstance&&!t.componentInstance._isDestroyed&&t.data.keepAlive){var r=t;je.prepatch(r,r)}else{(t.componentInstance=function(t,e){var r={_isComponent:!0,_parentVnode:t,parent:e},o=t.data.inlineTemplate;n(o)&&(r.render=o.render,r.staticRenderFns=o.staticRenderFns);return new t.componentOptions.Ctor(r)}(t,qe)).$mount(e?t.elm:void 0,e)}},prepatch:function(e,n){var r=n.componentOptions;!function(e,n,r,o,i){var a=o.data.scopedSlots,s=e.$scopedSlots,c=!!(a&&!a.$stable||s!==t&&!s.$stable||a&&e.$scopedSlots.$key!==a.$key),u=!!(i||e.$options._renderChildren||c);e.$options._parentVnode=o,e.$vnode=o,e._vnode&&(e._vnode.parent=o);if(e.$options._renderChildren=i,e.$attrs=o.data.attrs||t,e.$listeners=r||t,n&&e.$options.props){_t(!1);for(var l=e._props,f=e.$options._propKeys||[],p=0;p<f.length;p++){var d=f[p],v=e.$options.props;l[d]=Dt(d,v,n,e)}_t(!0),e.$options.propsData=n}r=r||t;var h=e.$options._parentListeners;e.$options._parentListeners=r,We(e,r,h),u&&(e.$slots=se(i,o.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,r.propsData,r.listeners,n,r.children)},insert:function(t){var e,n=t.context,r=t.componentInstance;r._isMounted||(r._isMounted=!0,Ze(r,"mounted")),t.data.keepAlive&&(n._isMounted?((e=r)._inactive=!1,Qe.push(e)):Ge(r,!0))},destroy:function(t){var e=t.componentInstance;e._isDestroyed||(t.data.keepAlive?function t(e,n){if(n&&(e._directInactive=!0,Xe(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)t(e.$children[r]);Ze(e,"deactivated")}}(e,!0):e.$destroy())}},Te=Object.keys(je);function Ie(o,a,s,c,l){if(!e(o)){var f=s.$options._base;if(i(o)&&(o=f.extend(o)),"function"==typeof o){var p;if(e(o.cid)&&void 0===(o=function(t,o){if(r(t.error)&&n(t.errorComp))return t.errorComp;if(n(t.resolved))return t.resolved;var a=Fe;a&&n(t.owners)&&-1===t.owners.indexOf(a)&&t.owners.push(a);if(r(t.loading)&&n(t.loadingComp))return t.loadingComp;if(a&&!n(t.owners)){var s=t.owners=[a],c=!0,l=null,f=null;a.$on("hook:destroyed",function(){return v(s,a)});var p=function(t){for(var e=0,n=s.length;e<n;e++)s[e].$forceUpdate();t&&(s.length=0,null!==l&&(clearTimeout(l),l=null),null!==f&&(clearTimeout(f),f=null))},d=I(function(e){t.resolved=Re(e,o),c?s.length=0:p(!0)}),h=I(function(e){n(t.errorComp)&&(t.error=!0,p(!0))}),m=t(d,h);return i(m)&&(u(m)?e(t.resolved)&&m.then(d,h):u(m.component)&&(m.component.then(d,h),n(m.error)&&(t.errorComp=Re(m.error,o)),n(m.loading)&&(t.loadingComp=Re(m.loading,o),0===m.delay?t.loading=!0:l=setTimeout(function(){l=null,e(t.resolved)&&e(t.error)&&(t.loading=!0,p(!1))},m.delay||200)),n(m.timeout)&&(f=setTimeout(function(){f=null,e(t.resolved)&&h(null)},m.timeout)))),c=!1,t.loading?t.loadingComp:t.resolved}}(p=o,f)))return function(t,e,n,r,o){var i=pt();return i.asyncFactory=t,i.asyncMeta={data:e,context:n,children:r,tag:o},i}(p,a,s,c,l);a=a||{},_n(o),n(a.model)&&function(t,e){var r=t.model&&t.model.prop||"value",o=t.model&&t.model.event||"input";(e.attrs||(e.attrs={}))[r]=e.model.value;var i=e.on||(e.on={}),a=i[o],s=e.model.callback;n(a)?(Array.isArray(a)?-1===a.indexOf(s):a!==s)&&(i[o]=[s].concat(a)):i[o]=s}(o.options,a);var d=function(t,r,o){var i=r.options.props;if(!e(i)){var a={},s=t.attrs,c=t.props;if(n(s)||n(c))for(var u in i){var l=$(u);re(a,c,u,l,!0)||re(a,s,u,l,!1)}return a}}(a,o);if(r(o.options.functional))return function(e,r,o,i,a){var s=e.options,c={},u=s.props;if(n(u))for(var l in u)c[l]=Dt(l,u,r||t);else n(o.attrs)&&Ee(c,o.attrs),n(o.props)&&Ee(c,o.props);var f=new ke(o,c,a,i,e),p=s.render.call(null,f._c,f);if(p instanceof lt)return Se(p,o,f.parent,s);if(Array.isArray(p)){for(var d=oe(p)||[],v=new Array(d.length),h=0;h<d.length;h++)v[h]=Se(d[h],o,f.parent,s);return v}}(o,d,a,s,c);var h=a.on;if(a.on=a.nativeOn,r(o.options.abstract)){var m=a.slot;a={},m&&(a.slot=m)}!function(t){for(var e=t.hook||(t.hook={}),n=0;n<Te.length;n++){var r=Te[n],o=e[r],i=je[r];o===i||o&&o._merged||(e[r]=o?De(i,o):i)}}(a);var y=o.options.name||l;return new lt("vue-component-"+o.cid+(y?"-"+y:""),a,void 0,void 0,void 0,s,{Ctor:o,propsData:d,listeners:h,tag:l,children:c},p)}}}function De(t,e){var n=function(n,r){t(n,r),e(n,r)};return n._merged=!0,n}var Ne=1,Pe=2;function Le(t,a,s,c,u,l){return(Array.isArray(s)||o(s))&&(u=c,c=s,s=void 0),r(l)&&(u=Pe),function(t,o,a,s,c){if(n(a)&&n(a.__ob__))return pt();n(a)&&n(a.is)&&(o=a.is);if(!o)return pt();Array.isArray(s)&&"function"==typeof s[0]&&((a=a||{}).scopedSlots={default:s[0]},s.length=0);c===Pe?s=oe(s):c===Ne&&(s=function(t){for(var e=0;e<t.length;e++)if(Array.isArray(t[e]))return Array.prototype.concat.apply([],t);return t}(s));var u,l;if("string"==typeof o){var f;l=t.$vnode&&t.$vnode.ns||L.getTagNamespace(o),u=L.isReservedTag(o)?new lt(L.parsePlatformTagName(o),a,s,void 0,void 0,t):a&&a.pre||!n(f=It(t.$options,"components",o))?new lt(o,a,s,void 0,void 0,t):Ie(f,a,t,s,o)}else u=Ie(o,a,t,s);return Array.isArray(u)?u:n(u)?(n(l)&&function t(o,i,a){o.ns=i;"foreignObject"===o.tag&&(i=void 0,a=!0);if(n(o.children))for(var s=0,c=o.children.length;s<c;s++){var u=o.children[s];n(u.tag)&&(e(u.ns)||r(a)&&"svg"!==u.tag)&&t(u,i,a)}}(u,l),n(a)&&function(t){i(t.style)&&Qt(t.style);i(t.class)&&Qt(t.class)}(a),u):pt()}(t,a,s,c,u)}var Me,Fe=null;function Re(t,e){return(t.__esModule||rt&&"Module"===t[Symbol.toStringTag])&&(t=t.default),i(t)?e.extend(t):t}function Ue(t){return t.isComment&&t.asyncFactory}function He(t){if(Array.isArray(t))for(var e=0;e<t.length;e++){var r=t[e];if(n(r)&&(n(r.componentOptions)||Ue(r)))return r}}function Be(t,e){Me.$on(t,e)}function Ve(t,e){Me.$off(t,e)}function ze(t,e){var n=Me;return function r(){null!==e.apply(null,arguments)&&n.$off(t,r)}}function We(t,e,n){Me=t,ee(e,n||{},Be,Ve,ze,t),Me=void 0}var qe=null;function Ke(t){var e=qe;return qe=t,function(){qe=e}}function Xe(t){for(;t&&(t=t.$parent);)if(t._inactive)return!0;return!1}function Ge(t,e){if(e){if(t._directInactive=!1,Xe(t))return}else if(t._directInactive)return;if(t._inactive||null===t._inactive){t._inactive=!1;for(var n=0;n<t.$children.length;n++)Ge(t.$children[n]);Ze(t,"activated")}}function Ze(t,e){ct();var n=t.$options[e],r=e+" hook";if(n)for(var o=0,i=n.length;o<i;o++)Ft(n[o],t,null,t,r);t._hasHookEvent&&t.$emit("hook:"+e),ut()}var Je=[],Qe=[],Ye={},tn=!1,en=!1,nn=0;var rn=0,on=Date.now;if(H&&!W){var an=window.performance;an&&"function"==typeof an.now&&on()>document.createEvent("Event").timeStamp&&(on=function(){return an.now()})}function sn(){var t,e;for(rn=on(),en=!0,Je.sort(function(t,e){return t.id-e.id}),nn=0;nn<Je.length;nn++)(t=Je[nn]).before&&t.before(),e=t.id,Ye[e]=null,t.run();var n=Qe.slice(),r=Je.slice();nn=Je.length=Qe.length=0,Ye={},tn=en=!1,function(t){for(var e=0;e<t.length;e++)t[e]._inactive=!0,Ge(t[e],!0)}(n),function(t){var e=t.length;for(;e--;){var n=t[e],r=n.vm;r._watcher===n&&r._isMounted&&!r._isDestroyed&&Ze(r,"updated")}}(r),tt&&L.devtools&&tt.emit("flush")}var cn=0,un=function(t,e,n,r,o){this.vm=t,o&&(t._watcher=this),t._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++cn,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new nt,this.newDepIds=new nt,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(t){if(!F.test(t)){var e=t.split(".");return function(t){for(var n=0;n<e.length;n++){if(!t)return;t=t[e[n]]}return t}}}(e),this.getter||(this.getter=k)),this.value=this.lazy?void 0:this.get()};un.prototype.get=function(){var t;ct(this);var e=this.vm;try{t=this.getter.call(e,e)}catch(t){if(!this.user)throw t;Mt(t,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&Qt(t),ut(),this.cleanupDeps()}return t},un.prototype.addDep=function(t){var e=t.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(t),this.depIds.has(e)||t.addSub(this))},un.prototype.cleanupDeps=function(){for(var t=this.deps.length;t--;){var e=this.deps[t];this.newDepIds.has(e.id)||e.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},un.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(t){var e=t.id;if(null==Ye[e]){if(Ye[e]=!0,en){for(var n=Je.length-1;n>nn&&Je[n].id>t.id;)n--;Je.splice(n+1,0,t)}else Je.push(t);tn||(tn=!0,Zt(sn))}}(this)},un.prototype.run=function(){if(this.active){var t=this.get();if(t!==this.value||i(t)||this.deep){var e=this.value;if(this.value=t,this.user)try{this.cb.call(this.vm,t,e)}catch(t){Mt(t,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,t,e)}}},un.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},un.prototype.depend=function(){for(var t=this.deps.length;t--;)this.deps[t].depend()},un.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||v(this.vm._watchers,this);for(var t=this.deps.length;t--;)this.deps[t].removeSub(this);this.active=!1}};var ln={enumerable:!0,configurable:!0,get:k,set:k};function fn(t,e,n){ln.get=function(){return this[e][n]},ln.set=function(t){this[e][n]=t},Object.defineProperty(t,n,ln)}function pn(t){t._watchers=[];var e=t.$options;e.props&&function(t,e){var n=t.$options.propsData||{},r=t._props={},o=t.$options._propKeys=[];t.$parent&&_t(!1);var i=function(i){o.push(i);var a=Dt(i,e,n,t);$t(r,i,a),i in t||fn(t,"_props",i)};for(var a in e)i(a);_t(!0)}(t,e.props),e.methods&&function(t,e){t.$options.props;for(var n in e)t[n]="function"!=typeof e[n]?k:w(e[n],t)}(t,e.methods),e.data?function(t){var e=t.$options.data;s(e=t._data="function"==typeof e?function(t,e){ct();try{return t.call(e,e)}catch(t){return Mt(t,e,"data()"),{}}finally{ut()}}(e,t):e||{})||(e={});var n=Object.keys(e),r=t.$options.props,o=(t.$options.methods,n.length);for(;o--;){var i=n[o];r&&m(r,i)||(a=void 0,36!==(a=(i+"").charCodeAt(0))&&95!==a&&fn(t,"_data",i))}var a;Ct(e,!0)}(t):Ct(t._data={},!0),e.computed&&function(t,e){var n=t._computedWatchers=Object.create(null),r=Y();for(var o in e){var i=e[o],a="function"==typeof i?i:i.get;r||(n[o]=new un(t,a||k,k,dn)),o in t||vn(t,o,i)}}(t,e.computed),e.watch&&e.watch!==Z&&function(t,e){for(var n in e){var r=e[n];if(Array.isArray(r))for(var o=0;o<r.length;o++)yn(t,n,r[o]);else yn(t,n,r)}}(t,e.watch)}var dn={lazy:!0};function vn(t,e,n){var r=!Y();"function"==typeof n?(ln.get=r?hn(e):mn(n),ln.set=k):(ln.get=n.get?r&&!1!==n.cache?hn(e):mn(n.get):k,ln.set=n.set||k),Object.defineProperty(t,e,ln)}function hn(t){return function(){var e=this._computedWatchers&&this._computedWatchers[t];if(e)return e.dirty&&e.evaluate(),at.target&&e.depend(),e.value}}function mn(t){return function(){return t.call(this,this)}}function yn(t,e,n,r){return s(n)&&(r=n,n=n.handler),"string"==typeof n&&(n=t[n]),t.$watch(e,n,r)}var gn=0;function _n(t){var e=t.options;if(t.super){var n=_n(t.super);if(n!==t.superOptions){t.superOptions=n;var r=function(t){var e,n=t.options,r=t.sealedOptions;for(var o in n)n[o]!==r[o]&&(e||(e={}),e[o]=n[o]);return e}(t);r&&x(t.extendOptions,r),(e=t.options=Tt(n,t.extendOptions)).name&&(e.components[e.name]=t)}}return e}function bn(t){this._init(t)}function Cn(t){t.cid=0;var e=1;t.extend=function(t){t=t||{};var n=this,r=n.cid,o=t._Ctor||(t._Ctor={});if(o[r])return o[r];var i=t.name||n.options.name,a=function(t){this._init(t)};return(a.prototype=Object.create(n.prototype)).constructor=a,a.cid=e++,a.options=Tt(n.options,t),a.super=n,a.options.props&&function(t){var e=t.options.props;for(var n in e)fn(t.prototype,"_props",n)}(a),a.options.computed&&function(t){var e=t.options.computed;for(var n in e)vn(t.prototype,n,e[n])}(a),a.extend=n.extend,a.mixin=n.mixin,a.use=n.use,N.forEach(function(t){a[t]=n[t]}),i&&(a.options.components[i]=a),a.superOptions=n.options,a.extendOptions=t,a.sealedOptions=x({},a.options),o[r]=a,a}}function $n(t){return t&&(t.Ctor.options.name||t.tag)}function wn(t,e){return Array.isArray(t)?t.indexOf(e)>-1:"string"==typeof t?t.split(",").indexOf(e)>-1:(n=t,"[object RegExp]"===a.call(n)&&t.test(e));var n}function An(t,e){var n=t.cache,r=t.keys,o=t._vnode;for(var i in n){var a=n[i];if(a){var s=$n(a.componentOptions);s&&!e(s)&&xn(n,i,r,o)}}}function xn(t,e,n,r){var o=t[e];!o||r&&o.tag===r.tag||o.componentInstance.$destroy(),t[e]=null,v(n,e)}!function(e){e.prototype._init=function(e){var n=this;n._uid=gn++,n._isVue=!0,e&&e._isComponent?function(t,e){var n=t.$options=Object.create(t.constructor.options),r=e._parentVnode;n.parent=e.parent,n._parentVnode=r;var o=r.componentOptions;n.propsData=o.propsData,n._parentListeners=o.listeners,n._renderChildren=o.children,n._componentTag=o.tag,e.render&&(n.render=e.render,n.staticRenderFns=e.staticRenderFns)}(n,e):n.$options=Tt(_n(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(t){var e=t.$options,n=e.parent;if(n&&!e.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(t)}t.$parent=n,t.$root=n?n.$root:t,t.$children=[],t.$refs={},t._watcher=null,t._inactive=null,t._directInactive=!1,t._isMounted=!1,t._isDestroyed=!1,t._isBeingDestroyed=!1}(n),function(t){t._events=Object.create(null),t._hasHookEvent=!1;var e=t.$options._parentListeners;e&&We(t,e)}(n),function(e){e._vnode=null,e._staticTrees=null;var n=e.$options,r=e.$vnode=n._parentVnode,o=r&&r.context;e.$slots=se(n._renderChildren,o),e.$scopedSlots=t,e._c=function(t,n,r,o){return Le(e,t,n,r,o,!1)},e.$createElement=function(t,n,r,o){return Le(e,t,n,r,o,!0)};var i=r&&r.data;$t(e,"$attrs",i&&i.attrs||t,null,!0),$t(e,"$listeners",n._parentListeners||t,null,!0)}(n),Ze(n,"beforeCreate"),function(t){var e=ae(t.$options.inject,t);e&&(_t(!1),Object.keys(e).forEach(function(n){$t(t,n,e[n])}),_t(!0))}(n),pn(n),function(t){var e=t.$options.provide;e&&(t._provided="function"==typeof e?e.call(t):e)}(n),Ze(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(bn),function(t){var e={get:function(){return this._data}},n={get:function(){return this._props}};Object.defineProperty(t.prototype,"$data",e),Object.defineProperty(t.prototype,"$props",n),t.prototype.$set=wt,t.prototype.$delete=At,t.prototype.$watch=function(t,e,n){if(s(e))return yn(this,t,e,n);(n=n||{}).user=!0;var r=new un(this,t,e,n);if(n.immediate)try{e.call(this,r.value)}catch(t){Mt(t,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(bn),function(t){var e=/^hook:/;t.prototype.$on=function(t,n){var r=this;if(Array.isArray(t))for(var o=0,i=t.length;o<i;o++)r.$on(t[o],n);else(r._events[t]||(r._events[t]=[])).push(n),e.test(t)&&(r._hasHookEvent=!0);return r},t.prototype.$once=function(t,e){var n=this;function r(){n.$off(t,r),e.apply(n,arguments)}return r.fn=e,n.$on(t,r),n},t.prototype.$off=function(t,e){var n=this;if(!arguments.length)return n._events=Object.create(null),n;if(Array.isArray(t)){for(var r=0,o=t.length;r<o;r++)n.$off(t[r],e);return n}var i,a=n._events[t];if(!a)return n;if(!e)return n._events[t]=null,n;for(var s=a.length;s--;)if((i=a[s])===e||i.fn===e){a.splice(s,1);break}return n},t.prototype.$emit=function(t){var e=this._events[t];if(e){e=e.length>1?A(e):e;for(var n=A(arguments,1),r='event handler for "'+t+'"',o=0,i=e.length;o<i;o++)Ft(e[o],this,n,this,r)}return this}}(bn),function(t){t.prototype._update=function(t,e){var n=this,r=n.$el,o=n._vnode,i=Ke(n);n._vnode=t,n.$el=o?n.__patch__(o,t):n.__patch__(n.$el,t,e,!1),i(),r&&(r.__vue__=null),n.$el&&(n.$el.__vue__=n),n.$vnode&&n.$parent&&n.$vnode===n.$parent._vnode&&(n.$parent.$el=n.$el)},t.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},t.prototype.$destroy=function(){var t=this;if(!t._isBeingDestroyed){Ze(t,"beforeDestroy"),t._isBeingDestroyed=!0;var e=t.$parent;!e||e._isBeingDestroyed||t.$options.abstract||v(e.$children,t),t._watcher&&t._watcher.teardown();for(var n=t._watchers.length;n--;)t._watchers[n].teardown();t._data.__ob__&&t._data.__ob__.vmCount--,t._isDestroyed=!0,t.__patch__(t._vnode,null),Ze(t,"destroyed"),t.$off(),t.$el&&(t.$el.__vue__=null),t.$vnode&&(t.$vnode.parent=null)}}}(bn),function(t){Oe(t.prototype),t.prototype.$nextTick=function(t){return Zt(t,this)},t.prototype._render=function(){var t,e=this,n=e.$options,r=n.render,o=n._parentVnode;o&&(e.$scopedSlots=ue(o.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=o;try{Fe=e,t=r.call(e._renderProxy,e.$createElement)}catch(n){Mt(n,e,"render"),t=e._vnode}finally{Fe=null}return Array.isArray(t)&&1===t.length&&(t=t[0]),t instanceof lt||(t=pt()),t.parent=o,t}}(bn);var On=[String,RegExp,Array],kn={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:On,exclude:On,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var t in this.cache)xn(this.cache,t,this.keys)},mounted:function(){var t=this;this.$watch("include",function(e){An(t,function(t){return wn(e,t)})}),this.$watch("exclude",function(e){An(t,function(t){return!wn(e,t)})})},render:function(){var t=this.$slots.default,e=He(t),n=e&&e.componentOptions;if(n){var r=$n(n),o=this.include,i=this.exclude;if(o&&(!r||!wn(o,r))||i&&r&&wn(i,r))return e;var a=this.cache,s=this.keys,c=null==e.key?n.Ctor.cid+(n.tag?"::"+n.tag:""):e.key;a[c]?(e.componentInstance=a[c].componentInstance,v(s,c),s.push(c)):(a[c]=e,s.push(c),this.max&&s.length>parseInt(this.max)&&xn(a,s[0],s,this._vnode)),e.data.keepAlive=!0}return e||t&&t[0]}}};!function(t){var e={get:function(){return L}};Object.defineProperty(t,"config",e),t.util={warn:ot,extend:x,mergeOptions:Tt,defineReactive:$t},t.set=wt,t.delete=At,t.nextTick=Zt,t.observable=function(t){return Ct(t),t},t.options=Object.create(null),N.forEach(function(e){t.options[e+"s"]=Object.create(null)}),t.options._base=t,x(t.options.components,kn),function(t){t.use=function(t){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(t)>-1)return this;var n=A(arguments,1);return n.unshift(this),"function"==typeof t.install?t.install.apply(t,n):"function"==typeof t&&t.apply(null,n),e.push(t),this}}(t),function(t){t.mixin=function(t){return this.options=Tt(this.options,t),this}}(t),Cn(t),function(t){N.forEach(function(e){t[e]=function(t,n){return n?("component"===e&&s(n)&&(n.name=n.name||t,n=this.options._base.extend(n)),"directive"===e&&"function"==typeof n&&(n={bind:n,update:n}),this.options[e+"s"][t]=n,n):this.options[e+"s"][t]}})}(t)}(bn),Object.defineProperty(bn.prototype,"$isServer",{get:Y}),Object.defineProperty(bn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(bn,"FunctionalRenderContext",{value:ke}),bn.version="2.6.10";var Sn=p("style,class"),En=p("input,textarea,option,select,progress"),jn=p("contenteditable,draggable,spellcheck"),Tn=p("events,caret,typing,plaintext-only"),In=function(t,e){return Mn(e)||"false"===e?"false":"contenteditable"===t&&Tn(e)?e:"true"},Dn=p("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),Nn="http://www.w3.org/1999/xlink",Pn=function(t){return":"===t.charAt(5)&&"xlink"===t.slice(0,5)},Ln=function(t){return Pn(t)?t.slice(6,t.length):""},Mn=function(t){return null==t||!1===t};function Fn(t){for(var e=t.data,r=t,o=t;n(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=Rn(o.data,e));for(;n(r=r.parent);)r&&r.data&&(e=Rn(e,r.data));return function(t,e){if(n(t)||n(e))return Un(t,Hn(e));return""}(e.staticClass,e.class)}function Rn(t,e){return{staticClass:Un(t.staticClass,e.staticClass),class:n(t.class)?[t.class,e.class]:e.class}}function Un(t,e){return t?e?t+" "+e:t:e||""}function Hn(t){return Array.isArray(t)?function(t){for(var e,r="",o=0,i=t.length;o<i;o++)n(e=Hn(t[o]))&&""!==e&&(r&&(r+=" "),r+=e);return r}(t):i(t)?function(t){var e="";for(var n in t)t[n]&&(e&&(e+=" "),e+=n);return e}(t):"string"==typeof t?t:""}var Bn={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Vn=p("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),zn=p("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Wn=function(t){return Vn(t)||zn(t)};var qn=Object.create(null);var Kn=p("text,number,password,search,email,tel,url");var Xn=Object.freeze({createElement:function(t,e){var n=document.createElement(t);return"select"!==t?n:(e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n)},createElementNS:function(t,e){return document.createElementNS(Bn[t],e)},createTextNode:function(t){return document.createTextNode(t)},createComment:function(t){return document.createComment(t)},insertBefore:function(t,e,n){t.insertBefore(e,n)},removeChild:function(t,e){t.removeChild(e)},appendChild:function(t,e){t.appendChild(e)},parentNode:function(t){return t.parentNode},nextSibling:function(t){return t.nextSibling},tagName:function(t){return t.tagName},setTextContent:function(t,e){t.textContent=e},setStyleScope:function(t,e){t.setAttribute(e,"")}}),Gn={create:function(t,e){Zn(e)},update:function(t,e){t.data.ref!==e.data.ref&&(Zn(t,!0),Zn(e))},destroy:function(t){Zn(t,!0)}};function Zn(t,e){var r=t.data.ref;if(n(r)){var o=t.context,i=t.componentInstance||t.elm,a=o.$refs;e?Array.isArray(a[r])?v(a[r],i):a[r]===i&&(a[r]=void 0):t.data.refInFor?Array.isArray(a[r])?a[r].indexOf(i)<0&&a[r].push(i):a[r]=[i]:a[r]=i}}var Jn=new lt("",{},[]),Qn=["create","activate","update","remove","destroy"];function Yn(t,o){return t.key===o.key&&(t.tag===o.tag&&t.isComment===o.isComment&&n(t.data)===n(o.data)&&function(t,e){if("input"!==t.tag)return!0;var r,o=n(r=t.data)&&n(r=r.attrs)&&r.type,i=n(r=e.data)&&n(r=r.attrs)&&r.type;return o===i||Kn(o)&&Kn(i)}(t,o)||r(t.isAsyncPlaceholder)&&t.asyncFactory===o.asyncFactory&&e(o.asyncFactory.error))}function tr(t,e,r){var o,i,a={};for(o=e;o<=r;++o)n(i=t[o].key)&&(a[i]=o);return a}var er={create:nr,update:nr,destroy:function(t){nr(t,Jn)}};function nr(t,e){(t.data.directives||e.data.directives)&&function(t,e){var n,r,o,i=t===Jn,a=e===Jn,s=or(t.data.directives,t.context),c=or(e.data.directives,e.context),u=[],l=[];for(n in c)r=s[n],o=c[n],r?(o.oldValue=r.value,o.oldArg=r.arg,ar(o,"update",e,t),o.def&&o.def.componentUpdated&&l.push(o)):(ar(o,"bind",e,t),o.def&&o.def.inserted&&u.push(o));if(u.length){var f=function(){for(var n=0;n<u.length;n++)ar(u[n],"inserted",e,t)};i?ne(e,"insert",f):f()}l.length&&ne(e,"postpatch",function(){for(var n=0;n<l.length;n++)ar(l[n],"componentUpdated",e,t)});if(!i)for(n in s)c[n]||ar(s[n],"unbind",t,t,a)}(t,e)}var rr=Object.create(null);function or(t,e){var n,r,o=Object.create(null);if(!t)return o;for(n=0;n<t.length;n++)(r=t[n]).modifiers||(r.modifiers=rr),o[ir(r)]=r,r.def=It(e.$options,"directives",r.name);return o}function ir(t){return t.rawName||t.name+"."+Object.keys(t.modifiers||{}).join(".")}function ar(t,e,n,r,o){var i=t.def&&t.def[e];if(i)try{i(n.elm,t,n,r,o)}catch(r){Mt(r,n.context,"directive "+t.name+" "+e+" hook")}}var sr=[Gn,er];function cr(t,r){var o=r.componentOptions;if(!(n(o)&&!1===o.Ctor.options.inheritAttrs||e(t.data.attrs)&&e(r.data.attrs))){var i,a,s=r.elm,c=t.data.attrs||{},u=r.data.attrs||{};for(i in n(u.__ob__)&&(u=r.data.attrs=x({},u)),u)a=u[i],c[i]!==a&&ur(s,i,a);for(i in(W||K)&&u.value!==c.value&&ur(s,"value",u.value),c)e(u[i])&&(Pn(i)?s.removeAttributeNS(Nn,Ln(i)):jn(i)||s.removeAttribute(i))}}function ur(t,e,n){t.tagName.indexOf("-")>-1?lr(t,e,n):Dn(e)?Mn(n)?t.removeAttribute(e):(n="allowfullscreen"===e&&"EMBED"===t.tagName?"true":e,t.setAttribute(e,n)):jn(e)?t.setAttribute(e,In(e,n)):Pn(e)?Mn(n)?t.removeAttributeNS(Nn,Ln(e)):t.setAttributeNS(Nn,e,n):lr(t,e,n)}function lr(t,e,n){if(Mn(n))t.removeAttribute(e);else{if(W&&!q&&"TEXTAREA"===t.tagName&&"placeholder"===e&&""!==n&&!t.__ieph){var r=function(e){e.stopImmediatePropagation(),t.removeEventListener("input",r)};t.addEventListener("input",r),t.__ieph=!0}t.setAttribute(e,n)}}var fr={create:cr,update:cr};function pr(t,r){var o=r.elm,i=r.data,a=t.data;if(!(e(i.staticClass)&&e(i.class)&&(e(a)||e(a.staticClass)&&e(a.class)))){var s=Fn(r),c=o._transitionClasses;n(c)&&(s=Un(s,Hn(c))),s!==o._prevClass&&(o.setAttribute("class",s),o._prevClass=s)}}var dr,vr={create:pr,update:pr},hr="__r",mr="__c";function yr(t,e,n){var r=dr;return function o(){null!==e.apply(null,arguments)&&br(t,o,n,r)}}var gr=Bt&&!(G&&Number(G[1])<=53);function _r(t,e,n,r){if(gr){var o=rn,i=e;e=i._wrapper=function(t){if(t.target===t.currentTarget||t.timeStamp>=o||t.timeStamp<=0||t.target.ownerDocument!==document)return i.apply(this,arguments)}}dr.addEventListener(t,e,J?{capture:n,passive:r}:n)}function br(t,e,n,r){(r||dr).removeEventListener(t,e._wrapper||e,n)}function Cr(t,r){if(!e(t.data.on)||!e(r.data.on)){var o=r.data.on||{},i=t.data.on||{};dr=r.elm,function(t){if(n(t[hr])){var e=W?"change":"input";t[e]=[].concat(t[hr],t[e]||[]),delete t[hr]}n(t[mr])&&(t.change=[].concat(t[mr],t.change||[]),delete t[mr])}(o),ee(o,i,_r,br,yr,r.context),dr=void 0}}var $r,wr={create:Cr,update:Cr};function Ar(t,r){if(!e(t.data.domProps)||!e(r.data.domProps)){var o,i,a=r.elm,s=t.data.domProps||{},c=r.data.domProps||{};for(o in n(c.__ob__)&&(c=r.data.domProps=x({},c)),s)o in c||(a[o]="");for(o in c){if(i=c[o],"textContent"===o||"innerHTML"===o){if(r.children&&(r.children.length=0),i===s[o])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===o&&"PROGRESS"!==a.tagName){a._value=i;var u=e(i)?"":String(i);xr(a,u)&&(a.value=u)}else if("innerHTML"===o&&zn(a.tagName)&&e(a.innerHTML)){($r=$r||document.createElement("div")).innerHTML="<svg>"+i+"</svg>";for(var l=$r.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;l.firstChild;)a.appendChild(l.firstChild)}else if(i!==s[o])try{a[o]=i}catch(t){}}}}function xr(t,e){return!t.composing&&("OPTION"===t.tagName||function(t,e){var n=!0;try{n=document.activeElement!==t}catch(t){}return n&&t.value!==e}(t,e)||function(t,e){var r=t.value,o=t._vModifiers;if(n(o)){if(o.number)return f(r)!==f(e);if(o.trim)return r.trim()!==e.trim()}return r!==e}(t,e))}var Or={create:Ar,update:Ar},kr=y(function(t){var e={},n=/:(.+)/;return t.split(/;(?![^(]*\))/g).forEach(function(t){if(t){var r=t.split(n);r.length>1&&(e[r[0].trim()]=r[1].trim())}}),e});function Sr(t){var e=Er(t.style);return t.staticStyle?x(t.staticStyle,e):e}function Er(t){return Array.isArray(t)?O(t):"string"==typeof t?kr(t):t}var jr,Tr=/^--/,Ir=/\s*!important$/,Dr=function(t,e,n){if(Tr.test(e))t.style.setProperty(e,n);else if(Ir.test(n))t.style.setProperty($(e),n.replace(Ir,""),"important");else{var r=Pr(e);if(Array.isArray(n))for(var o=0,i=n.length;o<i;o++)t.style[r]=n[o];else t.style[r]=n}},Nr=["Webkit","Moz","ms"],Pr=y(function(t){if(jr=jr||document.createElement("div").style,"filter"!==(t=_(t))&&t in jr)return t;for(var e=t.charAt(0).toUpperCase()+t.slice(1),n=0;n<Nr.length;n++){var r=Nr[n]+e;if(r in jr)return r}});function Lr(t,r){var o=r.data,i=t.data;if(!(e(o.staticStyle)&&e(o.style)&&e(i.staticStyle)&&e(i.style))){var a,s,c=r.elm,u=i.staticStyle,l=i.normalizedStyle||i.style||{},f=u||l,p=Er(r.data.style)||{};r.data.normalizedStyle=n(p.__ob__)?x({},p):p;var d=function(t,e){var n,r={};if(e)for(var o=t;o.componentInstance;)(o=o.componentInstance._vnode)&&o.data&&(n=Sr(o.data))&&x(r,n);(n=Sr(t.data))&&x(r,n);for(var i=t;i=i.parent;)i.data&&(n=Sr(i.data))&&x(r,n);return r}(r,!0);for(s in f)e(d[s])&&Dr(c,s,"");for(s in d)(a=d[s])!==f[s]&&Dr(c,s,null==a?"":a)}}var Mr={create:Lr,update:Lr},Fr=/\s+/;function Rr(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Fr).forEach(function(e){return t.classList.add(e)}):t.classList.add(e);else{var n=" "+(t.getAttribute("class")||"")+" ";n.indexOf(" "+e+" ")<0&&t.setAttribute("class",(n+e).trim())}}function Ur(t,e){if(e&&(e=e.trim()))if(t.classList)e.indexOf(" ")>-1?e.split(Fr).forEach(function(e){return t.classList.remove(e)}):t.classList.remove(e),t.classList.length||t.removeAttribute("class");else{for(var n=" "+(t.getAttribute("class")||"")+" ",r=" "+e+" ";n.indexOf(r)>=0;)n=n.replace(r," ");(n=n.trim())?t.setAttribute("class",n):t.removeAttribute("class")}}function Hr(t){if(t){if("object"==typeof t){var e={};return!1!==t.css&&x(e,Br(t.name||"v")),x(e,t),e}return"string"==typeof t?Br(t):void 0}}var Br=y(function(t){return{enterClass:t+"-enter",enterToClass:t+"-enter-to",enterActiveClass:t+"-enter-active",leaveClass:t+"-leave",leaveToClass:t+"-leave-to",leaveActiveClass:t+"-leave-active"}}),Vr=H&&!q,zr="transition",Wr="animation",qr="transition",Kr="transitionend",Xr="animation",Gr="animationend";Vr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(qr="WebkitTransition",Kr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Xr="WebkitAnimation",Gr="webkitAnimationEnd"));var Zr=H?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(t){return t()};function Jr(t){Zr(function(){Zr(t)})}function Qr(t,e){var n=t._transitionClasses||(t._transitionClasses=[]);n.indexOf(e)<0&&(n.push(e),Rr(t,e))}function Yr(t,e){t._transitionClasses&&v(t._transitionClasses,e),Ur(t,e)}function to(t,e,n){var r=no(t,e),o=r.type,i=r.timeout,a=r.propCount;if(!o)return n();var s=o===zr?Kr:Gr,c=0,u=function(){t.removeEventListener(s,l),n()},l=function(e){e.target===t&&++c>=a&&u()};setTimeout(function(){c<a&&u()},i+1),t.addEventListener(s,l)}var eo=/\b(transform|all)(,|$)/;function no(t,e){var n,r=window.getComputedStyle(t),o=(r[qr+"Delay"]||"").split(", "),i=(r[qr+"Duration"]||"").split(", "),a=ro(o,i),s=(r[Xr+"Delay"]||"").split(", "),c=(r[Xr+"Duration"]||"").split(", "),u=ro(s,c),l=0,f=0;return e===zr?a>0&&(n=zr,l=a,f=i.length):e===Wr?u>0&&(n=Wr,l=u,f=c.length):f=(n=(l=Math.max(a,u))>0?a>u?zr:Wr:null)?n===zr?i.length:c.length:0,{type:n,timeout:l,propCount:f,hasTransform:n===zr&&eo.test(r[qr+"Property"])}}function ro(t,e){for(;t.length<e.length;)t=t.concat(t);return Math.max.apply(null,e.map(function(e,n){return oo(e)+oo(t[n])}))}function oo(t){return 1e3*Number(t.slice(0,-1).replace(",","."))}function io(t,r){var o=t.elm;n(o._leaveCb)&&(o._leaveCb.cancelled=!0,o._leaveCb());var a=Hr(t.data.transition);if(!e(a)&&!n(o._enterCb)&&1===o.nodeType){for(var s=a.css,c=a.type,u=a.enterClass,l=a.enterToClass,p=a.enterActiveClass,d=a.appearClass,v=a.appearToClass,h=a.appearActiveClass,m=a.beforeEnter,y=a.enter,g=a.afterEnter,_=a.enterCancelled,b=a.beforeAppear,C=a.appear,$=a.afterAppear,w=a.appearCancelled,A=a.duration,x=qe,O=qe.$vnode;O&&O.parent;)x=O.context,O=O.parent;var k=!x._isMounted||!t.isRootInsert;if(!k||C||""===C){var S=k&&d?d:u,E=k&&h?h:p,j=k&&v?v:l,T=k&&b||m,D=k&&"function"==typeof C?C:y,N=k&&$||g,P=k&&w||_,L=f(i(A)?A.enter:A),M=!1!==s&&!q,F=co(D),R=o._enterCb=I(function(){M&&(Yr(o,j),Yr(o,E)),R.cancelled?(M&&Yr(o,S),P&&P(o)):N&&N(o),o._enterCb=null});t.data.show||ne(t,"insert",function(){var e=o.parentNode,n=e&&e._pending&&e._pending[t.key];n&&n.tag===t.tag&&n.elm._leaveCb&&n.elm._leaveCb(),D&&D(o,R)}),T&&T(o),M&&(Qr(o,S),Qr(o,E),Jr(function(){Yr(o,S),R.cancelled||(Qr(o,j),F||(so(L)?setTimeout(R,L):to(o,c,R)))})),t.data.show&&(r&&r(),D&&D(o,R)),M||F||R()}}}function ao(t,r){var o=t.elm;n(o._enterCb)&&(o._enterCb.cancelled=!0,o._enterCb());var a=Hr(t.data.transition);if(e(a)||1!==o.nodeType)return r();if(!n(o._leaveCb)){var s=a.css,c=a.type,u=a.leaveClass,l=a.leaveToClass,p=a.leaveActiveClass,d=a.beforeLeave,v=a.leave,h=a.afterLeave,m=a.leaveCancelled,y=a.delayLeave,g=a.duration,_=!1!==s&&!q,b=co(v),C=f(i(g)?g.leave:g),$=o._leaveCb=I(function(){o.parentNode&&o.parentNode._pending&&(o.parentNode._pending[t.key]=null),_&&(Yr(o,l),Yr(o,p)),$.cancelled?(_&&Yr(o,u),m&&m(o)):(r(),h&&h(o)),o._leaveCb=null});y?y(w):w()}function w(){$.cancelled||(!t.data.show&&o.parentNode&&((o.parentNode._pending||(o.parentNode._pending={}))[t.key]=t),d&&d(o),_&&(Qr(o,u),Qr(o,p),Jr(function(){Yr(o,u),$.cancelled||(Qr(o,l),b||(so(C)?setTimeout($,C):to(o,c,$)))})),v&&v(o,$),_||b||$())}}function so(t){return"number"==typeof t&&!isNaN(t)}function co(t){if(e(t))return!1;var r=t.fns;return n(r)?co(Array.isArray(r)?r[0]:r):(t._length||t.length)>1}function uo(t,e){!0!==e.data.show&&io(e)}var lo=function(t){var i,a,s={},c=t.modules,u=t.nodeOps;for(i=0;i<Qn.length;++i)for(s[Qn[i]]=[],a=0;a<c.length;++a)n(c[a][Qn[i]])&&s[Qn[i]].push(c[a][Qn[i]]);function l(t){var e=u.parentNode(t);n(e)&&u.removeChild(e,t)}function f(t,e,o,i,a,c,l){if(n(t.elm)&&n(c)&&(t=c[l]=vt(t)),t.isRootInsert=!a,!function(t,e,o,i){var a=t.data;if(n(a)){var c=n(t.componentInstance)&&a.keepAlive;if(n(a=a.hook)&&n(a=a.init)&&a(t,!1),n(t.componentInstance))return d(t,e),v(o,t.elm,i),r(c)&&function(t,e,r,o){for(var i,a=t;a.componentInstance;)if(a=a.componentInstance._vnode,n(i=a.data)&&n(i=i.transition)){for(i=0;i<s.activate.length;++i)s.activate[i](Jn,a);e.push(a);break}v(r,t.elm,o)}(t,e,o,i),!0}}(t,e,o,i)){var f=t.data,p=t.children,m=t.tag;n(m)?(t.elm=t.ns?u.createElementNS(t.ns,m):u.createElement(m,t),g(t),h(t,p,e),n(f)&&y(t,e),v(o,t.elm,i)):r(t.isComment)?(t.elm=u.createComment(t.text),v(o,t.elm,i)):(t.elm=u.createTextNode(t.text),v(o,t.elm,i))}}function d(t,e){n(t.data.pendingInsert)&&(e.push.apply(e,t.data.pendingInsert),t.data.pendingInsert=null),t.elm=t.componentInstance.$el,m(t)?(y(t,e),g(t)):(Zn(t),e.push(t))}function v(t,e,r){n(t)&&(n(r)?u.parentNode(r)===t&&u.insertBefore(t,e,r):u.appendChild(t,e))}function h(t,e,n){if(Array.isArray(e))for(var r=0;r<e.length;++r)f(e[r],n,t.elm,null,!0,e,r);else o(t.text)&&u.appendChild(t.elm,u.createTextNode(String(t.text)))}function m(t){for(;t.componentInstance;)t=t.componentInstance._vnode;return n(t.tag)}function y(t,e){for(var r=0;r<s.create.length;++r)s.create[r](Jn,t);n(i=t.data.hook)&&(n(i.create)&&i.create(Jn,t),n(i.insert)&&e.push(t))}function g(t){var e;if(n(e=t.fnScopeId))u.setStyleScope(t.elm,e);else for(var r=t;r;)n(e=r.context)&&n(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e),r=r.parent;n(e=qe)&&e!==t.context&&e!==t.fnContext&&n(e=e.$options._scopeId)&&u.setStyleScope(t.elm,e)}function _(t,e,n,r,o,i){for(;r<=o;++r)f(n[r],i,t,e,!1,n,r)}function b(t){var e,r,o=t.data;if(n(o))for(n(e=o.hook)&&n(e=e.destroy)&&e(t),e=0;e<s.destroy.length;++e)s.destroy[e](t);if(n(e=t.children))for(r=0;r<t.children.length;++r)b(t.children[r])}function C(t,e,r,o){for(;r<=o;++r){var i=e[r];n(i)&&(n(i.tag)?($(i),b(i)):l(i.elm))}}function $(t,e){if(n(e)||n(t.data)){var r,o=s.remove.length+1;for(n(e)?e.listeners+=o:e=function(t,e){function n(){0==--n.listeners&&l(t)}return n.listeners=e,n}(t.elm,o),n(r=t.componentInstance)&&n(r=r._vnode)&&n(r.data)&&$(r,e),r=0;r<s.remove.length;++r)s.remove[r](t,e);n(r=t.data.hook)&&n(r=r.remove)?r(t,e):e()}else l(t.elm)}function w(t,e,r,o){for(var i=r;i<o;i++){var a=e[i];if(n(a)&&Yn(t,a))return i}}function A(t,o,i,a,c,l){if(t!==o){n(o.elm)&&n(a)&&(o=a[c]=vt(o));var p=o.elm=t.elm;if(r(t.isAsyncPlaceholder))n(o.asyncFactory.resolved)?k(t.elm,o,i):o.isAsyncPlaceholder=!0;else if(r(o.isStatic)&&r(t.isStatic)&&o.key===t.key&&(r(o.isCloned)||r(o.isOnce)))o.componentInstance=t.componentInstance;else{var d,v=o.data;n(v)&&n(d=v.hook)&&n(d=d.prepatch)&&d(t,o);var h=t.children,y=o.children;if(n(v)&&m(o)){for(d=0;d<s.update.length;++d)s.update[d](t,o);n(d=v.hook)&&n(d=d.update)&&d(t,o)}e(o.text)?n(h)&&n(y)?h!==y&&function(t,r,o,i,a){for(var s,c,l,p=0,d=0,v=r.length-1,h=r[0],m=r[v],y=o.length-1,g=o[0],b=o[y],$=!a;p<=v&&d<=y;)e(h)?h=r[++p]:e(m)?m=r[--v]:Yn(h,g)?(A(h,g,i,o,d),h=r[++p],g=o[++d]):Yn(m,b)?(A(m,b,i,o,y),m=r[--v],b=o[--y]):Yn(h,b)?(A(h,b,i,o,y),$&&u.insertBefore(t,h.elm,u.nextSibling(m.elm)),h=r[++p],b=o[--y]):Yn(m,g)?(A(m,g,i,o,d),$&&u.insertBefore(t,m.elm,h.elm),m=r[--v],g=o[++d]):(e(s)&&(s=tr(r,p,v)),e(c=n(g.key)?s[g.key]:w(g,r,p,v))?f(g,i,t,h.elm,!1,o,d):Yn(l=r[c],g)?(A(l,g,i,o,d),r[c]=void 0,$&&u.insertBefore(t,l.elm,h.elm)):f(g,i,t,h.elm,!1,o,d),g=o[++d]);p>v?_(t,e(o[y+1])?null:o[y+1].elm,o,d,y,i):d>y&&C(0,r,p,v)}(p,h,y,i,l):n(y)?(n(t.text)&&u.setTextContent(p,""),_(p,null,y,0,y.length-1,i)):n(h)?C(0,h,0,h.length-1):n(t.text)&&u.setTextContent(p,""):t.text!==o.text&&u.setTextContent(p,o.text),n(v)&&n(d=v.hook)&&n(d=d.postpatch)&&d(t,o)}}}function x(t,e,o){if(r(o)&&n(t.parent))t.parent.data.pendingInsert=e;else for(var i=0;i<e.length;++i)e[i].data.hook.insert(e[i])}var O=p("attrs,class,staticClass,staticStyle,key");function k(t,e,o,i){var a,s=e.tag,c=e.data,u=e.children;if(i=i||c&&c.pre,e.elm=t,r(e.isComment)&&n(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(n(c)&&(n(a=c.hook)&&n(a=a.init)&&a(e,!0),n(a=e.componentInstance)))return d(e,o),!0;if(n(s)){if(n(u))if(t.hasChildNodes())if(n(a=c)&&n(a=a.domProps)&&n(a=a.innerHTML)){if(a!==t.innerHTML)return!1}else{for(var l=!0,f=t.firstChild,p=0;p<u.length;p++){if(!f||!k(f,u[p],o,i)){l=!1;break}f=f.nextSibling}if(!l||f)return!1}else h(e,u,o);if(n(c)){var v=!1;for(var m in c)if(!O(m)){v=!0,y(e,o);break}!v&&c.class&&Qt(c.class)}}else t.data!==e.text&&(t.data=e.text);return!0}return function(t,o,i,a){if(!e(o)){var c,l=!1,p=[];if(e(t))l=!0,f(o,p);else{var d=n(t.nodeType);if(!d&&Yn(t,o))A(t,o,p,null,null,a);else{if(d){if(1===t.nodeType&&t.hasAttribute(D)&&(t.removeAttribute(D),i=!0),r(i)&&k(t,o,p))return x(o,p,!0),t;c=t,t=new lt(u.tagName(c).toLowerCase(),{},[],void 0,c)}var v=t.elm,h=u.parentNode(v);if(f(o,p,v._leaveCb?null:h,u.nextSibling(v)),n(o.parent))for(var y=o.parent,g=m(o);y;){for(var _=0;_<s.destroy.length;++_)s.destroy[_](y);if(y.elm=o.elm,g){for(var $=0;$<s.create.length;++$)s.create[$](Jn,y);var w=y.data.hook.insert;if(w.merged)for(var O=1;O<w.fns.length;O++)w.fns[O]()}else Zn(y);y=y.parent}n(h)?C(0,[t],0,0):n(t.tag)&&b(t)}}return x(o,p,l),o.elm}n(t)&&b(t)}}({nodeOps:Xn,modules:[fr,vr,wr,Or,Mr,H?{create:uo,activate:uo,remove:function(t,e){!0!==t.data.show?ao(t,e):e()}}:{}].concat(sr)});q&&document.addEventListener("selectionchange",function(){var t=document.activeElement;t&&t.vmodel&&_o(t,"input")});var fo={inserted:function(t,e,n,r){"select"===n.tag?(r.elm&&!r.elm._vOptions?ne(n,"postpatch",function(){fo.componentUpdated(t,e,n)}):po(t,e,n.context),t._vOptions=[].map.call(t.options,mo)):("textarea"===n.tag||Kn(t.type))&&(t._vModifiers=e.modifiers,e.modifiers.lazy||(t.addEventListener("compositionstart",yo),t.addEventListener("compositionend",go),t.addEventListener("change",go),q&&(t.vmodel=!0)))},componentUpdated:function(t,e,n){if("select"===n.tag){po(t,e,n.context);var r=t._vOptions,o=t._vOptions=[].map.call(t.options,mo);if(o.some(function(t,e){return!j(t,r[e])}))(t.multiple?e.value.some(function(t){return ho(t,o)}):e.value!==e.oldValue&&ho(e.value,o))&&_o(t,"change")}}};function po(t,e,n){vo(t,e,n),(W||K)&&setTimeout(function(){vo(t,e,n)},0)}function vo(t,e,n){var r=e.value,o=t.multiple;if(!o||Array.isArray(r)){for(var i,a,s=0,c=t.options.length;s<c;s++)if(a=t.options[s],o)i=T(r,mo(a))>-1,a.selected!==i&&(a.selected=i);else if(j(mo(a),r))return void(t.selectedIndex!==s&&(t.selectedIndex=s));o||(t.selectedIndex=-1)}}function ho(t,e){return e.every(function(e){return!j(e,t)})}function mo(t){return"_value"in t?t._value:t.value}function yo(t){t.target.composing=!0}function go(t){t.target.composing&&(t.target.composing=!1,_o(t.target,"input"))}function _o(t,e){var n=document.createEvent("HTMLEvents");n.initEvent(e,!0,!0),t.dispatchEvent(n)}function bo(t){return!t.componentInstance||t.data&&t.data.transition?t:bo(t.componentInstance._vnode)}var Co={model:fo,show:{bind:function(t,e,n){var r=e.value,o=(n=bo(n)).data&&n.data.transition,i=t.__vOriginalDisplay="none"===t.style.display?"":t.style.display;r&&o?(n.data.show=!0,io(n,function(){t.style.display=i})):t.style.display=r?i:"none"},update:function(t,e,n){var r=e.value;!r!=!e.oldValue&&((n=bo(n)).data&&n.data.transition?(n.data.show=!0,r?io(n,function(){t.style.display=t.__vOriginalDisplay}):ao(n,function(){t.style.display="none"})):t.style.display=r?t.__vOriginalDisplay:"none")},unbind:function(t,e,n,r,o){o||(t.style.display=t.__vOriginalDisplay)}}},$o={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function wo(t){var e=t&&t.componentOptions;return e&&e.Ctor.options.abstract?wo(He(e.children)):t}function Ao(t){var e={},n=t.$options;for(var r in n.propsData)e[r]=t[r];var o=n._parentListeners;for(var i in o)e[_(i)]=o[i];return e}function xo(t,e){if(/\d-keep-alive$/.test(e.tag))return t("keep-alive",{props:e.componentOptions.propsData})}var Oo=function(t){return t.tag||Ue(t)},ko=function(t){return"show"===t.name},So={name:"transition",props:$o,abstract:!0,render:function(t){var e=this,n=this.$slots.default;if(n&&(n=n.filter(Oo)).length){var r=this.mode,i=n[0];if(function(t){for(;t=t.parent;)if(t.data.transition)return!0}(this.$vnode))return i;var a=wo(i);if(!a)return i;if(this._leaving)return xo(t,i);var s="__transition-"+this._uid+"-";a.key=null==a.key?a.isComment?s+"comment":s+a.tag:o(a.key)?0===String(a.key).indexOf(s)?a.key:s+a.key:a.key;var c=(a.data||(a.data={})).transition=Ao(this),u=this._vnode,l=wo(u);if(a.data.directives&&a.data.directives.some(ko)&&(a.data.show=!0),l&&l.data&&!function(t,e){return e.key===t.key&&e.tag===t.tag}(a,l)&&!Ue(l)&&(!l.componentInstance||!l.componentInstance._vnode.isComment)){var f=l.data.transition=x({},c);if("out-in"===r)return this._leaving=!0,ne(f,"afterLeave",function(){e._leaving=!1,e.$forceUpdate()}),xo(t,i);if("in-out"===r){if(Ue(a))return u;var p,d=function(){p()};ne(c,"afterEnter",d),ne(c,"enterCancelled",d),ne(f,"delayLeave",function(t){p=t})}}return i}}},Eo=x({tag:String,moveClass:String},$o);function jo(t){t.elm._moveCb&&t.elm._moveCb(),t.elm._enterCb&&t.elm._enterCb()}function To(t){t.data.newPos=t.elm.getBoundingClientRect()}function Io(t){var e=t.data.pos,n=t.data.newPos,r=e.left-n.left,o=e.top-n.top;if(r||o){t.data.moved=!0;var i=t.elm.style;i.transform=i.WebkitTransform="translate("+r+"px,"+o+"px)",i.transitionDuration="0s"}}delete Eo.mode;var Do={Transition:So,TransitionGroup:{props:Eo,beforeMount:function(){var t=this,e=this._update;this._update=function(n,r){var o=Ke(t);t.__patch__(t._vnode,t.kept,!1,!0),t._vnode=t.kept,o(),e.call(t,n,r)}},render:function(t){for(var e=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),r=this.prevChildren=this.children,o=this.$slots.default||[],i=this.children=[],a=Ao(this),s=0;s<o.length;s++){var c=o[s];c.tag&&null!=c.key&&0!==String(c.key).indexOf("__vlist")&&(i.push(c),n[c.key]=c,(c.data||(c.data={})).transition=a)}if(r){for(var u=[],l=[],f=0;f<r.length;f++){var p=r[f];p.data.transition=a,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):l.push(p)}this.kept=t(e,null,u),this.removed=l}return t(e,null,i)},updated:function(){var t=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";t.length&&this.hasMove(t[0].elm,e)&&(t.forEach(jo),t.forEach(To),t.forEach(Io),this._reflow=document.body.offsetHeight,t.forEach(function(t){if(t.data.moved){var n=t.elm,r=n.style;Qr(n,e),r.transform=r.WebkitTransform=r.transitionDuration="",n.addEventListener(Kr,n._moveCb=function t(r){r&&r.target!==n||r&&!/transform$/.test(r.propertyName)||(n.removeEventListener(Kr,t),n._moveCb=null,Yr(n,e))})}}))},methods:{hasMove:function(t,e){if(!Vr)return!1;if(this._hasMove)return this._hasMove;var n=t.cloneNode();t._transitionClasses&&t._transitionClasses.forEach(function(t){Ur(n,t)}),Rr(n,e),n.style.display="none",this.$el.appendChild(n);var r=no(n);return this.$el.removeChild(n),this._hasMove=r.hasTransform}}}};bn.config.mustUseProp=function(t,e,n){return"value"===n&&En(t)&&"button"!==e||"selected"===n&&"option"===t||"checked"===n&&"input"===t||"muted"===n&&"video"===t},bn.config.isReservedTag=Wn,bn.config.isReservedAttr=Sn,bn.config.getTagNamespace=function(t){return zn(t)?"svg":"math"===t?"math":void 0},bn.config.isUnknownElement=function(t){if(!H)return!0;if(Wn(t))return!1;if(t=t.toLowerCase(),null!=qn[t])return qn[t];var e=document.createElement(t);return t.indexOf("-")>-1?qn[t]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:qn[t]=/HTMLUnknownElement/.test(e.toString())},x(bn.options.directives,Co),x(bn.options.components,Do),bn.prototype.__patch__=H?lo:k,bn.prototype.$mount=function(t,e){return function(t,e,n){var r;return t.$el=e,t.$options.render||(t.$options.render=pt),Ze(t,"beforeMount"),r=function(){t._update(t._render(),n)},new un(t,r,k,{before:function(){t._isMounted&&!t._isDestroyed&&Ze(t,"beforeUpdate")}},!0),n=!1,null==t.$vnode&&(t._isMounted=!0,Ze(t,"mounted")),t}(this,t=t&&H?function(t){if("string"==typeof t){var e=document.querySelector(t);return e||document.createElement("div")}return t}(t):void 0,e)},H&&setTimeout(function(){L.devtools&&tt&&tt.emit("init",bn)},0),module.exports=bn;
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],517:[function(require,module,exports){
var inserted = exports.cache = {}

function noop () {}

exports.insert = function (css) {
  if (inserted[css]) return noop
  inserted[css] = true

  var elem = document.createElement('style')
  elem.setAttribute('type', 'text/css')

  if ('textContent' in elem) {
    elem.textContent = css
  } else {
    elem.styleSheet.cssText = css
  }

  document.getElementsByTagName('head')[0].appendChild(elem)
  return function () {
    document.getElementsByTagName('head')[0].removeChild(elem)
    inserted[css] = false
  }
}

},{}],518:[function(require,module,exports){
module.exports = {

  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    // fallback for older browsers like  IE 8
    return Object.prototype.toString.call( value ) === '[object Array]';
  }

};

},{}],519:[function(require,module,exports){
/*jslint node:true */

var xml2js = require('./xml2js');
var xml2json = require('./xml2json');
var js2xml = require('./js2xml');
var json2xml = require('./json2xml');

module.exports = {
  xml2js: xml2js,
  xml2json: xml2json,
  js2xml: js2xml,
  json2xml: json2xml
};

},{"./js2xml":520,"./json2xml":521,"./xml2js":523,"./xml2json":524}],520:[function(require,module,exports){
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;

var currentElement, currentElementName;

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('indentText', options);
  helper.ensureFlagExists('indentCdata', options);
  helper.ensureFlagExists('indentAttributes', options);
  helper.ensureFlagExists('indentInstruction', options);
  helper.ensureFlagExists('fullTagEmptyElement', options);
  helper.ensureFlagExists('noQuotesForNativeAttributes', options);
  helper.ensureSpacesExists(options);
  if (typeof options.spaces === 'number') {
    options.spaces = Array(options.spaces + 1).join(' ');
  }
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  helper.checkFnExists('fullTagEmptyElement', options);
  return options;
}

function writeIndentation(options, depth, firstLine) {
  return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes(attributes, options, depth) {
  if (options.ignoreAttributes) {
    return '';
  }
  if ('attributesFn' in options) {
    attributes = options.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
      attr = '' + attributes[key]; // ensure number and boolean are converted to String
      attr = attr.replace(/"/g, '&quot;');
      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));
      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
    result.push(writeIndentation(options, depth, false));
  }
  return result.join('');
}

function writeDeclaration(declaration, options, depth) {
  currentElement = declaration;
  currentElementName = 'xml';
  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}

function writeInstruction(instruction, options, depth) {
  if (options.ignoreInstruction) {
    return '';
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === 'object') {
    currentElement = instruction;
    currentElementName = instructionName;
    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
  } else {
    var instructionValue = instruction[key] ? instruction[key] : '';
    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
  }
}

function writeComment(comment, options) {
  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}

function writeCdata(cdata, options) {
  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}

function writeDoctype(doctype, options) {
  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}

function writeText(text, options) {
  if (options.ignoreText) return '';
  text = '' + text; // ensure Number and Boolean are converted to String
  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}

function hasContent(element, options) {
  var i;
  if (element.elements && element.elements.length) {
    for (i = 0; i < element.elements.length; ++i) {
      switch (element.elements[i][options.typeKey]) {
      case 'text':
        if (options.indentText) {
          return true;
        }
        break; // skip to next key
      case 'cdata':
        if (options.indentCdata) {
          return true;
        }
        break; // skip to next key
      case 'instruction':
        if (options.indentInstruction) {
          return true;
        }
        break; // skip to next key
      case 'doctype':
      case 'comment':
      case 'element':
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElement(element, options, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
  xml.push('<' + elementName);
  if (element[options.attributesKey]) {
    xml.push(writeAttributes(element[options.attributesKey], options, depth));
  }
  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
  if (!withClosingTag) {
    if ('fullTagEmptyElementFn' in options) {
      withClosingTag = options.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml.push('>');
    if (element[options.elementsKey] && element[options.elementsKey].length) {
      xml.push(writeElements(element[options.elementsKey], options, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }
    xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
    xml.push('</' + elementName + '>');
  } else {
    xml.push('/>');
  }
  return xml.join('');
}

function writeElements(elements, options, depth, firstLine) {
  return elements.reduce(function (xml, element) {
    var indent = writeIndentation(options, depth, firstLine && !xml);
    switch (element.type) {
    case 'element': return xml + indent + writeElement(element, options, depth);
    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);
    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);
    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
    case 'instruction':
      var instruction = {};
      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
    }
  }, '');
}

function hasContentCompact(element, options, anyContent) {
  var key;
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
      case options.parentKey:
      case options.attributesKey:
        break; // skip to next key
      case options.textKey:
        if (options.indentText || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.cdataKey:
        if (options.indentCdata || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.instructionKey:
        if (options.indentInstruction || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.doctypeKey:
      case options.commentKey:
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElementCompact(element, name, options, depth, indent) {
  currentElement = element;
  currentElementName = name;
  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
  if (typeof element === 'undefined' || element === null || element === '') {
    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
  }
  var xml = [];
  if (name) {
    xml.push('<' + elementName);
    if (typeof element !== 'object') {
      xml.push('>' + writeText(element,options) + '</' + elementName + '>');
      return xml.join('');
    }
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
      if ('fullTagEmptyElementFn' in options) {
        withClosingTag = options.fullTagEmptyElementFn(name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push('>');
    } else {
      xml.push('/>');
      return xml.join('');
    }
  }
  xml.push(writeElementsCompact(element, options, depth + 1, false));
  currentElement = element;
  currentElementName = name;
  if (name) {
    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
  }
  return xml.join('');
}

function writeElementsCompact(element, options, depth, firstLine) {
  var i, key, nodes, xml = [];
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray(element[key]) ? element[key] : [element[key]];
      for (i = 0; i < nodes.length; ++i) {
        switch (key) {
        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;
        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;
        case options.attributesKey: case options.parentKey: break; // skip
        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;
        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;
        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;
        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;
        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
        }
        firstLine = firstLine && !xml.length;
      }
    }
  }
  return xml.join('');
}

module.exports = function (js, options) {
  options = validateOptions(options);
  var xml = [];
  currentElement = js;
  currentElementName = '_root_';
  if (options.compact) {
    xml.push(writeElementsCompact(js, options, 0, true));
  } else {
    if (js[options.declarationKey]) {
      xml.push(writeDeclaration(js[options.declarationKey], options, 0));
    }
    if (js[options.elementsKey] && js[options.elementsKey].length) {
      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
  }
  return xml.join('');
};

},{"./array-helper":518,"./options-helper":522}],521:[function(require,module,exports){
(function (Buffer){
var js2xml = require('./js2xml.js');

module.exports = function (json, options) {
  if (json instanceof Buffer) {
    json = json.toString();
  }
  var js = null;
  if (typeof (json) === 'string') {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error('The JSON structure is invalid');
    }
  } else {
    js = json;
  }
  return js2xml(js, options);
};

}).call(this,require("buffer").Buffer)

},{"./js2xml.js":520,"buffer":30}],522:[function(require,module,exports){
var isArray = require('./array-helper').isArray;

module.exports = {

  copyOptions: function (options) {
    var key, copy = {};
    for (key in options) {
      if (options.hasOwnProperty(key)) {
        copy[key] = options[key];
      }
    }
    return copy;
  },

  ensureFlagExists: function (item, options) {
    if (!(item in options) || typeof options[item] !== 'boolean') {
      options[item] = false;
    }
  },

  ensureSpacesExists: function (options) {
    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {
      options.spaces = 0;
    }
  },

  ensureAlwaysArrayExists: function (options) {
    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {
      options.alwaysArray = false;
    }
  },

  ensureKeyExists: function (key, options) {
    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
      options[key + 'Key'] = options.compact ? '_' + key : key;
    }
  },

  checkFnExists: function (key, options) {
    return key + 'Fn' in options;
  }

};

},{"./array-helper":518}],523:[function(require,module,exports){
var sax = require('sax');
var expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };
var helper = require('./options-helper');
var isArray = require('./array-helper').isArray;

var options;
var pureJsParser = true;
var currentElement;

function validateOptions(userOptions) {
  options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('alwaysChildren', options);
  helper.ensureFlagExists('addParent', options);
  helper.ensureFlagExists('trim', options);
  helper.ensureFlagExists('nativeType', options);
  helper.ensureFlagExists('nativeTypeAttributes', options);
  helper.ensureFlagExists('sanitize', options);
  helper.ensureFlagExists('instructionHasAttributes', options);
  helper.ensureFlagExists('captureSpacesBetweenElements', options);
  helper.ensureAlwaysArrayExists(options);
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.ensureKeyExists('parent', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  return options;
}

function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === 'true') {
    return true;
  } else if (bValue === 'false') {
    return false;
  }
  return value;
}

function addField(type, value) {
  var key;
  if (options.compact) {
    if (
      !currentElement[options[type + 'Key']] &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)
    ) {
      currentElement[options[type + 'Key']] = [];
    }
    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];
    }
    if (type + 'Fn' in options && typeof value === 'string') {
      value = options[type + 'Fn'](value, currentElement);
    }
    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ('instructionFn' in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement)] = temp;
          }
        }
      }
    }
    if (isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']].push(value);
    } else {
      currentElement[options[type + 'Key']] = value;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    var element = {};
    element[options.typeKey] = type;
    if (type === 'instruction') {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];
        if ('instructionFn' in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
        }
      } else {
        if ('instructionFn' in options) {
          value[key] = options.instructionFn(value[key], key, currentElement);
        }
        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + 'Fn' in options) {
        value = options[type + 'Fn'](value, currentElement);
      }
      element[options[type + 'Key']] = value;
    }
    if (options.addParent) {
      element[options.parentKey] = currentElement;
    }
    currentElement[options.elementsKey].push(element);
  }
}

function manipulateAttributes(attributes) {
  if ('attributesFn' in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement);
  }
  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim) attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
        if ('attributeNameFn' in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
        }
      }
    }
  }
  return attributes;
}

function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === 'xml') {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField('instruction', value);
  }
}

function onStartElement(name, attributes) {
  var element;
  if (typeof name === 'object') {
    attributes = name.attributes;
    name = name.name;
  }
  attributes = manipulateAttributes(attributes);
  if ('elementNameFn' in options) {
    name = options.elementNameFn(name, currentElement);
  }
  if (options.compact) {
    element = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (
      !(name in currentElement) &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)
    ) {
      currentElement[name] = [];
    }
    if (currentElement[name] && !isArray(currentElement[name])) {
      currentElement[name] = [currentElement[name]];
    }
    if (isArray(currentElement[name])) {
      currentElement[name].push(element);
    } else {
      currentElement[name] = element;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    element = {};
    element[options.typeKey] = 'element';
    element[options.nameKey] = name;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }
    currentElement[options.elementsKey].push(element);
  }
  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
  currentElement = element;
}

function onText(text) {
  if (options.ignoreText) {
    return;
  }
  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text = text.trim();
  }
  if (options.nativeType) {
    text = nativeType(text);
  }
  if (options.sanitize) {
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  addField('text', text);
}

function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField('comment', comment);
}

function onEndElement(name) {
  var parentElement = currentElement[options.parentKey];
  if (!options.addParent) {
    delete currentElement[options.parentKey];
  }
  currentElement = parentElement;
}

function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField('cdata', cdata);
}

function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, '');
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField('doctype', doctype);
}

function onError(error) {
  error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {

  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
  var result = {};
  currentElement = result;

  options = validateOptions(userOptions);

  if (pureJsParser) {
    parser.opt = {strictEntities: true};
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  } else {
    parser.on('startElement', onStartElement);
    parser.on('text', onText);
    parser.on('comment', onComment);
    parser.on('endElement', onEndElement);
    parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
  }

  if (pureJsParser) {
    parser.write(xml).close();
  } else {
    if (!parser.parse(xml)) {
      throw new Error('XML parsing error: ' + parser.getError());
    }
  }

  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }

  return result;

};

},{"./array-helper":518,"./options-helper":522,"sax":509}],524:[function(require,module,exports){
var helper = require('./options-helper');
var xml2js = require('./xml2js');

function validateOptions (userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureSpacesExists(options);
  return options;
}

module.exports = function(xml, userOptions) {
  var options, js, json, parentKey;
  options = validateOptions(userOptions);
  js = xml2js(xml, options);
  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
  // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
  if ('addParent' in options && options.addParent) {
    json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);
  } else {
    json = JSON.stringify(js, null, options.spaces);
  }
  return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};

},{"./options-helper":522,"./xml2js":523}],525:[function(require,module,exports){
var apptitle = "G3W Client";

var plugins = {};

var tools = {
  tools: []
};

// get message from internalization
var i18n = {
  resources: require('./locales/app.js')
};

var client = {
  debug: true,
  local: false
};

var server = {
  urls: {
    baseurl: '/',
    ows: 'ows',
    api: 'api',
    initconfig: 'api/initconfig',
    config: 'api/config'
  }
};

var utils = {
  merge: function merge(type) {
    if (type) {
      console.log(CONFIG);
    }
  }
};

var CONFIG = {
  apptitle: apptitle,
  client: client,
  server: server,
  plugins: plugins,
  tools: tools,
  i18n: i18n,
  utils: utils
};

module.exports = CONFIG;

},{"./locales/app.js":526}],526:[function(require,module,exports){
var translations = {
  "it": {
    "translation": {
      "yes": "Si",
      "no": "No",
      "back": "Indietro",
      "backto": "Torna a ",
      "changemap": "Cambia Mappa",
      "component": "Componente Generico",
      "search": "Ricerche",
      "no_results": "Nessun risultato trovato",
      "print": "Stampa",
      "create_print": "Crea Stampa",
      "dosearch": "Cerca",
      "metadata": {},
      "catalog": "Mappa",
      "data": "Dati",
      "baselayers": "Basi",
      "tools": "Strumenti",
      "tree": "Strati",
      "legend": "Legenda",
      "nobaselayer": "Nessuna mappa di base",
      "street_search": "Cerca indirizzo",
      "show": "Mostra",
      "hide": "Nascondi",
      "copy_form_data": "Copia i dati del modulo",
      "paste_form_data": "Incolla",
      "copy_form_data_from_feature": "Copia i dati dalla mappa",
      "error_map_loading": "Errore di caricamento della nuova mappa",
      "check_internet_connection_or_server_admin": "Controllare la connessione internet o contattare l'amministratore",
      "could_not_load_vector_layers": "Errore di connessione al server: non  stato possibile caricare i vettoriali richiesti",
      "server_saver_error": "Errore nel salvataggio sul server",
      "server_error": "Si  verificato un errore nella richiesta al server",
      "save": "Salva",
      "cancel": "Cancella",
      "close": "Chiudi",
      "add": "Aggiungi",
      "exitnosave": "Esci senza salvare",
      "annul": "Annulla",
      "layer_is_added": "Layer gi aggiunto",
      "sidebar": {},
      "info": {
        "title": "Risultati",
        "open_link": "Apri documento allegato",
        "server_error": "Si  verificato un errore nella richiesta al server",
        "no_results": "Nessun risultato per questa interrogazione/ricerca ",
        "link_button": "Apri"
      },
      "mapcontrols": {
        "geolocations": {
          "title": "",
          "error": "Non  possibile calcolare la tua posizione."
        },
        "nominatim": {
          "placeholder": "Indirizzo ...",
          "noresults": "Nessun risultato",
          "notresponseserver": "Il server non risponde"
        },
        "add_layer_control": {
          "header": "Aggiungi Layer",
          "select_projection": "Seleziona il sistema di proiezione del layer",
          "select_color": "Seleziona il colore del Layer",
          "drag_layer": "Trascina il layer in questa area"
        },
        "query": {
          "input_relation": "Clicca per consultare le relazioni"
        },
        "length": {
          "tooltip": "Lunghezza"
        },
        "area": {
          "tooltip": "Area"
        }
      },
      "catalog_items": {
        "helptext": "Tasto destro sui singoli layer per accedere alle funzionalit aggiuntive",
        "contextmenu": {
          "zoomtolayer": "Zoom to Layer",
          "open_attribute_table": "Apri la tabella degli attibuti",
          "show_metadata": "Metadati"
        }
      },
      "dataTable": {
        "previous": "Precedente",
        "next": "Successivo",
        "info": "Visualizzazione _START_ a _END_ su _TOTAL_ righe",
        "nodatafilterd": "Nessun risultato trovato",
        "infoFiltered": "(Filtrati da _MAX_ total righe)"
      }
    }
  },
  "en": {
    "translation": {
      "yes": "Yes",
      "no": "No",
      "back": "Back",
      "backto": "Back to ",
      "changemap": "Change Map",
      "component": "Generic Component",
      "search": "Search",
      "no_results": "No results found",
      "print": "Print",
      "create_print": "Create Print",
      "dosearch": "Search",
      "catalog": "Map",
      "data": "Data",
      "baselayers": "Base",
      "tools": "Tools",
      "tree": "Layers",
      "legend": "Legend",
      "nobaselayer": "No basemap",
      "street_search": "Find Address",
      "show": "Show",
      "hide": "Hide",
      "copy_form_data": "Copy data",
      "paste_form_data": "Paste",
      "copy_form_data_from_feature": "Copy data from map",
      "error_map_loading": "Error occurs loading map",
      "check_internet_connection_or_server_admin": "Check internet connection or contact admin",
      "could_not_load_vector_layers": "Connection error: Layers can be loaded",
      "server_saver_error": "Error in server saving",
      "server_error": "Server connection error",
      "save": "Save",
      "cancel": "Cancel",
      "close": "Close",
      "add": "Add",
      "exitnosave": "Exit without save",
      "annul": "Cancel",
      "layer_is_added": "Layer already added",
      "sidebar": {},
      "info": {
        "title": "Results",
        "open_link": "Open attached document",
        "server_error": "An error occurred from server",
        "no_results": "No results found for this query/search",
        "link_button": "Open"
      },
      "mapcontrols": {
        "geolocations": {
          "error": "Can't get your position"
        },
        "nominatim": {
          "placeholder": "Address ...",
          "noresults": "No results",
          "notresponseserver": "No response from server"
        },
        "add_layer_control": {
          "header": "Add Layer",
          "select_projection": "Select layer projection",
          "select_color": "Select Layer Color",
          "drag_layer": "Drag and drop layer here"
        },
        "query": {
          "input_relation": "Click to show relations"
        },
        "length": {
          "tooltip": "Length"
        },
        "area": {
          "tooltip": "Area"
        }
      },
      "catalog_items": {
        "helptext": "Right-click on individual layer to access additional features",
        "contextmenu": {
          "zoomtolayer": "Zoom to Layer",
          "open_attribute_table": "Open Attribute Table",
          "show_metadata": "Metadata"
        }
      },
      "dataTable": {
        "previous": "Previous",
        "next": "Next",
        "info": "Showing _START_ to _END_ of _TOTAL_ entries",
        "no_data": "No data",
        "nodatafilterd": "No matching records found",
        "infoFiltered": "(filtered from _MAX_ total records)"
      }
    }
  }
};

module.exports = translations;

},{}],527:[function(require,module,exports){
var _config = require('./template/config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var i18ninit = require('sdk').core.i18n.init;
var addI18n = require('sdk').core.i18n.addI18n;
// sdk configuration file
var sdkConfig = require('sdk').config;
// template configuration file

var ApplicationService = require('sdk/sdk').core.ApplicationService;
// ApplicationTemplate instance. It manages the application template
var ApplicationTemplate = require('./template/js/template');
// Main applcation config file
var config = require('./config/config.js');
// set the global enviromental variable g3wsdk. It used by plugins to load sdk class and instances
window.g3wsdk = require('sdk');

// this function is used to merge all configurations from sdk template etc .. for example i18n
function addI18nConfigModules() {
  //i18n
  var sdkI18n = sdkConfig.i18n || {};
  var templateI18n = _config2.default.i18n || {};
  addI18n(sdkI18n);
  addI18n(templateI18n);
}

// main function to create the start application configuration
function createApplicationConfig() {
  return {
    apptitle: config.apptitle || '',
    logo_img: config.group.header_logo_img,
    logo_link: config.group.header_logo_link,
    terms_of_use_text: config.group.header_terms_of_use_text,
    terms_of_use_link: config.group.terms_of_use_link,
    header_custom_links: config.group.header_custom_links,
    debug: config.client.debug || false,
    group: config.group,
    urls: config.server.urls,
    mediaurl: config.server.urls.mediaurl,
    resourcesurl: config.server.urls.clienturl,
    vectorurl: config.server.urls.vectorurl,
    projects: config.group.projects,
    initproject: config.group.initproject,
    overviewproject: config.group.overviewproject && config.group.overviewproject.gid ? config.group.overviewproject : null,
    baselayers: config.group.baselayers,
    mapcontrols: config.group.mapcontrols,
    background_color: config.group.background_color,
    crs: config.group.crs,
    proj4: config.group.proj4,
    minscale: config.group.minscale,
    maxscale: config.group.maxscale,
    main_map_title: config.main_map_title,
    credits: config.credits,
    layout: config.group.layout || {},
    // needed by ProjectService
    getWmsUrl: function getWmsUrl(project) {
      return config.server.urls.baseurl + config.server.urls.ows + '/' + config.group.id + '/' + project.type + '/' + project.id + '/';
    },
    // needed by ProjectsRegistry to get informations about project configuration
    getProjectConfigUrl: function getProjectConfigUrl(project) {
      return config.server.urls.baseurl + config.server.urls.config + '/' + config.group.id + '/' + project.type + '/' + project.id;
    },
    plugins: config.group.plugins,
    tools: config.tools,
    views: config.views || {},
    user: config.user || null
  };
}

// frun when app.js is loaded
var bootstrap = function bootstrap() {
  function handleError(error) {
    if (error && error.responseJSON && error.responseJSON.error.data) {
      error = error.responseJSON.error.data;
    } else {
      error = null;
    }
    return error;
  }
  // add all configurations
  //addConfigurationFromOtherModules();
  //get all configuration from groups
  //config.server.urls.initconfig: api url to get starting configuration
  ApplicationService.obtainInitConfig({
    initConfigUrl: config.server.urls.initconfig
  })
  //returna promise with starting configuration
  .then(function (initConfig) {
    // write urls of static files and media url (base url and vector url)
    config.server.urls.baseurl = initConfig.baseurl;
    config.server.urls.frontendurl = initConfig.frontendurl;
    config.server.urls.staticurl = initConfig.staticurl;
    config.server.urls.clienturl = initConfig.staticurl + initConfig.client;
    config.server.urls.mediaurl = initConfig.mediaurl;
    config.server.urls.vectorurl = initConfig.vectorurl;
    config.main_map_title = initConfig.main_map_title;
    config.group = initConfig.group;
    config.user = initConfig.user;
    config.credits = initConfig.credits;
    // get language from server
    config.i18n.lng = config.user.i18n;
    // create application configuration
    var applicationConfig = createApplicationConfig();
    // check if is inside a iframe
    config.group.layout.iframe = window.top !== window.self;
    // inizialize internalization
    i18ninit(config.i18n).then(function () {
      addI18nConfigModules();
    });
    // set accept-language reuest header based on config language
    //jquery
    var language = config.i18n.lng || 'en';
    $.ajaxSetup({
      beforeSend: function beforeSend(jqXHR) {
        jqXHR.setRequestHeader('Accept-Language', language);
      }
    });

    ApplicationService.init(applicationConfig).then(function () {
      //create the ApplicationTemplate instance passing the template configuration
      // and the applicationService instance that is useful to work with project API
      var applicationTemplate = new ApplicationTemplate({
        ApplicationService: ApplicationService
      });
      // Listen ready event emit after build interface
      applicationTemplate.on('ready', function () {
        ApplicationService.postBootstrap();
      });
      //call initialize applicationTemplate method
      applicationTemplate.init();
    }).fail(function (error) {
      error = handleError(error);
      ApplicationTemplate.fail({
        language: language,
        error: error
      });
    });
  }).fail(function (error) {
    var language = config.i18n.lng || 'en';
    // inizialize internalization
    error = handleError(error);
    ApplicationTemplate.fail({
      language: language,
      error: error
    });
  });
};

// run  bootstrap function
bootstrap();

},{"./config/config.js":525,"./template/config":531,"./template/js/template":553,"sdk":820,"sdk/sdk":820}],528:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".usermessage-content[data-v-7acb7000] {\n   color: #FFFFFF;\n   z-index: 1000;\n   position: absolute;\n   display: flex;\n   flex-wrap: wrap;\n   flex-direction: column;\n   align-items: center;\n   padding: 5px;\n   min-width: 250px;\n   box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);\n   -moz-box-shadow: 0 3px 5px rgba(0, 0, 0, 0.3);\n }\n\n .usermessage-header-content[data-v-7acb7000] {\n   display: flex;\n   justify-content: space-between;\n   width: 100%;\n }\n\n .usermessage-header-icontype[data-v-7acb7000] {\n   padding: 10px 0 0 5px;\n   font-weight: bold;\n   font-size: 1.3em;\n }\n\n.usermessage-header-title[data-v-7acb7000], .usermessage-header-title h4[data-v-7acb7000] {\n   font-weight: bold;\n }\n\n.usermessage-header-right[data-v-7acb7000] {\n   padding: 5px;\n }\n\n .usermessage-header-right-item[data-v-7acb7000] {\n   font-weight: bold !important;\n   font-size: 1.2em;\n   cursor: pointer;\n }\n\n .usermessage-message[data-v-7acb7000] {\n   width: 100%;\n   padding: 5px;\n   max-height: 70%;\n   font-weight: bold;\n   font-size: 1.2em;\n   align-self: flex-start;\n   overflow-y: auto;\n }")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var COLORS = {
  success: {
    backgroundColor: '#62ac62',
    color: '#FFFFFF'
  },
  info: {
    backgroundColor: '#44a0bb',
    color: '#FFFFFF'
  },
  warning: {
    backgroundColor: '#f29e1d',
    color: '#FFFFFF'
  },
  alert: {
    backgroundColor: '#c34943',
    color: '#FFFFFF'
  },
  tool: {
    backgroundColor: '#FFFFFF',
    color: "#222d32"
  }
};
exports.default = {
  name: "usermessage",
  props: {
    type: {
      type: String,
      default: 'info' },
    title: {
      type: String,
      default: null
    },
    position: {
      type: String,
      default: 'top'
    },
    size: {
      type: 'String',
      default: null
    },
    message: {
      type: String,
      deafult: ''
    },
    autoclose: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    closable: {
      type: Boolean,
      default: true
    }
  },
  methods: {
    closeUserMessage: function closeUserMessage() {
      this.$emit('close-usermessage');
    },
    hideShow: function hideShow() {}
  },
  created: function created() {
    var _position$split = this.position.split('-'),
        _position$split2 = (0, _slicedToArray3.default)(_position$split, 2),
        where = _position$split2[0],
        alignement = _position$split2[1];

    var width = '100%';
    switch (this.size) {
      case 'small':
        width = '25%';
        break;
      case 'medium':
        width = '50%';
        break;
      default:
        width = '100%';
    }
    if (where === 'center') where = {
      top: 0,
      bottom: 0,
      maxHeight: '20%'
    };else {
      where = (0, _defineProperty3.default)({}, where, 0);
    }
    var position = (0, _extends3.default)({}, where, {
      width: width
    });
    if (alignement) {
      position.width = '25%';
      switch (alignement) {
        case 'center':
          position.left = '0';
          position.right = '0';
          position.margin = 'auto';
          break;
        case 'right':
          position.right = 0;
          break;
      }
    }
    this.style = (0, _extends3.default)({}, COLORS[this.type], position);
  },
  mounted: function mounted() {
    var _this = this;

    this.autoclose && this.$nextTick(function () {
      var timeout = setTimeout(function () {
        _this.closeUserMessage();
        clearTimeout(timeout);
      }, 2000);
    });
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"usermessage-content",style:(_vm.style)},[_c('div',{staticClass:"usermessage-header-content"},[_c('i',{staticClass:"usermessage-header-icontype",class:_vm.g3wtemplate.getFontClass(_vm.type)}),_vm._v(" "),_c('div',{staticClass:"usermessage-header-title"},[_vm._t("header",[_c('h4',[_vm._v(_vm._s(_vm.title || _vm.type.toUpperCase()))])])],2),_vm._v(" "),_c('div',{staticClass:"usermessage-header-right"},[(!_vm.autoclose && _vm.closable)?_c('div',{on:{"click":_vm.closeUserMessage}},[_c('i',{staticClass:"usermessage-header-right-item",class:_vm.g3wtemplate.getFontClass('close')})]):_vm._e()])]),_vm._v(" "),_vm._t("body",[_c('div',{staticClass:"usermessage-message",domProps:{"innerHTML":_vm._s(_vm.message)}})]),_vm._v(" "),_vm._t("footer")],2)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-7acb7000"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-7acb7000", __vue__options__)
  } else {
    hotAPI.reload("data-v-7acb7000", __vue__options__)
  }
})()}

},{"babel-runtime/helpers/defineProperty":21,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],529:[function(require,module,exports){
var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _, _2;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Fonts = {
  fontawsome: {
    versions: {
      '4': (_ = {
        'change-map': "fa fa-map-signs",
        map: "fa fa-map-o",
        file: "fa fa-file-code-o",
        marker: "fa fa-map-marker",
        relation: "fa fa-sitemap",
        tools: "fa fa-gears",
        tool: "fa fa-gear",
        search: "fa fa-search",
        print: "fa fa-print",
        info: "fa fa-info-circle",
        'info-circle': "fa fa-info-circle",
        globe: "fa fa-globe",
        mail: "fa fa-envelope-o",
        mobile: "fa fa-mobile",
        fax: "fa fa-fax",
        user: "fa fa-user",
        bars: "fa fa-bars",
        uncheck: "fa fa-square-o",
        check: "fa fa-check-square-o",
        filluncheck: "fa fa-square",
        table: "fa fa-table",
        trash: "fa fa-trash",
        'trash-o': "fa fa-trash-o",
        pencil: "fa fa-pencil",
        'ellips-h': "fa fa-ellips-h",
        'arrow-up': "fa fa-chevron-up",
        'arrow-down': "fa fa-chevron-down",
        'arrow-left': "fa fa-chevron-left",
        'arrow-right': "fa fa-chevron-right",
        'angle-up': "fa fa-angle-up",
        'angle-down': "fa fa-angle-down",
        'angle-left': "fa fa-angle-left",
        'angle-right': "fa fa-angle-right",
        'caret-up': "fa fa-caret-up",
        'caret-down': "fa fa-caret-down",
        'caret-left': "fa fa-caret-left",
        'caret-right': "fa fa-caret-right",
        'empty-circle': "fa fa-circle-o",
        'cloud-upload': "fa fa-cloud-upload",
        spinner: "fa fa-spinner",
        minus: "fa fa-minus",
        plus: "fa fa-plus",
        grid: "fa fa-th",
        home: "fa fa-home",
        folder: "fa fa-folder",
        'sign-out': "fa fa-sign-out",
        close: "fa fa-times",
        time: "fa fa-clock-o",
        calendar: "fa fa-calendar",
        list: "fa fa-list-alt",
        link: "fa fa-link",
        unlink: " fa-chain-broken",
        eye: "fa fa-eye",
        'eye-close': "fa fa-eye-slash",
        save: "fa fa-floppy-o",
        pdf: "fa fa-file-pdf-o",
        image: "fa fa-file-image-o",
        video: "fa fa-file-video-o",
        unknow: "fa fa-question-circle-o",
        zip: "fa file-zip-o",
        text: "fa fa-file-text-o",
        excel: "fa fa-file-excel-o",
        csv: "fa fa-file-excel-o",
        ppt: "fa fa-file-powerpoint-o",
        circle: "fa fa-circle",
        download: "fa fa-download",
        calculator: "fa fa-calculator",
        picture: "fa fa-picture-o",
        crosshairs: "fa fa-crosshairs",
        keyboard: "fa fa-keyboard-o",
        'file-download': "fa fa-download",
        copy: "fa fa-clone",
        draw: "fa fa-plus",
        chart: "fa fa-bar-chart",
        'chart-line': "fa fa-chart-line",
        run: "fa fa-play",
        warning: "fa fa-exclamation-circle",
        alert: "a fa-exclamation-triangle"
      }, (0, _defineProperty3.default)(_, 'crosshairs', "fa fa-crosshairs"), (0, _defineProperty3.default)(_, 'success', "fa fa-check-circle-o"), (0, _defineProperty3.default)(_, 'back', "fa fa-chevron-circle-left"), (0, _defineProperty3.default)(_, 'file-upload', "fa fa-file-upload"), _),
      '5': (_2 = {
        'change-map': "fas fa-map-signs",
        map: "far fa-map",
        file: "fas fa-file-code",
        marker: "fas fa-map-marker-alt",
        relation: "fas fa-sitemap",
        tools: "fas fa-cogs",
        tool: "fas fa-cog",
        search: "fas fa-search",
        print: "fas fa-print",
        info: "fas fa-info-circle",
        'info-circle': "fas fa-info-circle",
        globe: "fas fa-globe",
        mail: "fas fa-envelope",
        mobile: "fas fa-mobile",
        fax: "fas fa-fax",
        user: "fas fa-user",
        bars: "fas fa-bars",
        uncheck: "far fa-square",
        check: "far fa-check-square",
        filluncheck: "fas fa-square",
        table: "fas fa-table",
        trash: "fas fa-trash",
        'trash-o': "far fa-trash-alt",
        pencil: "fas fa-pencil-alt",
        'ellips-h': "fas fa-ellips-h",
        'arrow-up': "fas fa-chevron-up",
        'arrow-down': "fas fa-chevron-down",
        'arrow-left': "fas fa-chevron-left",
        'arrow-right': "fas fa-chevron-right",
        'caret-up': "fas fa-caret-up",
        'caret-down': "fas fa-caret-down",
        'caret-left': "fas fa-caret-left",
        'caret-right': "fas fa-caret-right",
        'empty-circle': "far fa-circle",
        'cloud-upload': "fas fa-cloud-upload-alt",
        spinner: "fas fa-spinner",
        minus: "fas fa-minus",
        plus: "fas fa-plus",
        grid: "fas fa-th",
        home: "fas fa-home",
        folder: "fas fa-folder",
        'sign-out': "fas fa-sign-out-alt",
        close: "fas fa-times",
        time: "far fa-clock",
        calendar: "fas fa-calendar-alt",
        list: "fas fa-list-alt",
        link: "fas fa-link",
        unlink: "fas fa-unlink",
        eye: "far fa-eye",
        'eye-close': "far fa-eye-slash",
        save: "far fa-save",
        pdf: "fas fa-file-pdf",
        image: "far fa-image",
        video: "far fa-file-video",
        unknow: "far fa-question-circle",
        zip: "far fa-file-archive",
        text: "far fa-file-alt",
        excel: "far fa-file-excel",
        csv: "fas fa-file-csv",
        ppt: "far fa-file-powerpoint",
        circle: "fas fa-circle",
        download: "fas fa-download",
        calculator: "fas fa-calculator",
        picture: "far fa-image",
        crosshairs: "fas fa-crosshairs",
        keyboard: "far fa-keyboard",
        'file-download': "fas fa-file-download",
        copy: "far fa-copy",
        draw: "fas fa-draw-polygon",
        chart: "fas fa-chart-bar",
        'chart-line': "fas fa-chart-line",
        run: "fas fa-play",
        warning: "fas fa-exclamation-circle",
        alert: "fas fa-exclamation-triangle"
      }, (0, _defineProperty3.default)(_2, 'crosshairs', "fas fa-crosshairs"), (0, _defineProperty3.default)(_2, 'success', "far fa-check-circle"), (0, _defineProperty3.default)(_2, 'back', "fas fa-chevron-circle-left"), (0, _defineProperty3.default)(_2, 'file-upload', "fas fa-file-upload"), _2)
    }
  }
};

module.exports = Fonts;

},{"babel-runtime/helpers/defineProperty":21}],530:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  "it": {
    "template": {
      g3wSuiteFramework: "Applicativo realizzato con il framework OS",
      productOf: "Prodotto da",
      logout: "Esci",
      no_other_projects: "Non ci sono altri progetti in questo gruppo cartografico",
      usermessage: {
        info: "Informazioni",
        warning: "Attenzione",
        alert: "Errore",
        success: "Success",
        tool: "Strumenti"
      }
    }
  },
  "en": {
    "template": {
      g3wSuiteFramework: "Application based on OS framework",
      productOf: "A product of",
      logout: "Logout",
      no_other_projects: "No more project for this group",
      usermessage: {
        info: "Information",
        warning: "Warning",
        alert: "Alert",
        success: "Success",
        tool: "Tool"
      }
    }
  }
};

},{}],531:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _i18n = require('./i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  i18n: _i18n2.default
};

},{"./i18n":530}],532:[function(require,module,exports){
module.exports = "<div class=\"error-initial-page skin-background-color\">\n  <h1 class=\"oops\">Oops!</h1>\n  <h1 class=\"cause\">{{messages.error}}</h1>\n  <h3 class=\"at-moment\">{{ messages.at_moment }}</h3>\n  <h2 class=\"f5\">{{ messages.f5}}</h2>\n</div>\n";

},{}],533:[function(require,module,exports){
module.exports = "<div class=\"wrapper\">\n  <header v-if=\"!isIframe\" class=\"main-header\">\n    <!-- Logo -->\n    <!-- Header Navbar: style can be found in header.less -->\n    <nav class=\"navbar navbar-inverse navbar-fixed-top\" role=\"navigation\">\n      <div class=\"container-fluid\">\n        <div class=\"navbar-header\">\n          <button type=\"button\" class=\"navbar-toggle\" data-toggle=\"collapse\" data-target=\"#main-navbar\">\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n            <span class=\"icon-bar\"></span>\n          </button>\n          <!-- Toggle button on navbar only for mobile -->\n          <a v-if=\"isMobile()\" href=\"#\" class=\"sidebar-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n            <i :class=\"g3wtemplate.getFontClass('bars')\"></i>\n          </a>\n          <div class=\"logo-wrapper\">\n            <a v-if=\"logo_url\" :href=\"logo_link\" :target=\"logo_link_target\" class=\"project_logo_link\">\n              <img :src=\"logo_url\">\n            </a>\n            <div v-if=\"!isMobile()\" class=\"project_title_content\">\n              <div class=\"main_title\">{{ main_title }}</div>\n              <div class=\"sub_title\">{{project_title}}</div>\n            </div>\n          </div>\n        </div>\n        <div class=\"collapse navbar-collapse\" id=\"main-navbar\">\n          <navbarleftitems></navbarleftitems>\n          <navbarrightitems></navbarrightitems>\n          <ul class=\"nav navbar-nav navbar-right app-navbar-nav\">\n            <header-item :state=\"state\" @show-custom-modal-content=\"showCustomModalContent\" v-for=\"state in custom_header_items_position[0]\" :key=\"state.id\"></header-item>\n            <li id=\"changemaps\" class=\"dropdown user\" v-if=\"numberOfProjectsInGroup > 1\">\n              <a href=\"#\" @click=\"openProjectsMenu\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n                <i :class=\"g3wtemplate.getFontClass('change-map')\" aria-hidden=\"true\"></i>\n                <span v-t=\"'changemap'\"></span>\n              </a>\n            </li>\n            <header-item :state=\"state\" @show-custom-modal-content=\"showCustomModalContent\" v-for=\"state in custom_header_items_position[1]\" :key=\"state.id\"></header-item>\n            <li v-if=\"user\" class=\"dropdown user user-menu\">\n              <a href=\"#\" class=\"dropdown-toggle\" data-toggle=\"dropdown\">\n                <i :class=\"g3wtemplate.getFontClass('user')\"></i>\n                <span class=\"hidden-xs\">{{ user.username }}</span>\n              </a>\n              <ul class=\"dropdown-menu\">\n                <li class=\"user-header\">\n                  <p>\n                    {{ user.first_name }} {{ user.last_name }}\n                  </p>\n                </li>\n                <li class=\"user-footer\">\n                  <div class=\"pull-left\" v-if=\"user.admin_url\">\n                    <a :href=\"user.admin_url\" class=\"btn btn-default btn-flat\" ><i :class=\"g3wtemplate.getFontClass('folder')\"></i> Admin</a>\n                  </div>\n                  <div class=\"pull-right\">\n                    <a :href=\"user.logout_url\" class=\"btn btn-default btn-flat\" v-t=\"'template.logout'\"><i :class=\"g3wtemplate.getFontClass('sign-out')\" style=\"margin-right: 2px;\"></i></a>\n                  </div>\n                </li>\n              </ul>\n            </li>\n            <header-item :state=\"state\" @show-custom-modal-content=\"showCustomModalContent\" v-for=\"state in custom_header_items_position[2]\" :key=\"state.id\"></header-item>\n            <li class=\"dropdown user user-menu\">\n              <a href=\"#\" data-toggle=\"modal\" data-target=\"#credits\" class=\"dropdown-toggle\">\n                <span>Credits</span>\n              </a>\n            </li>\n            <header-item :state=\"state\" @show-custom-modal-content=\"showCustomModalContent\" v-for=\"state in custom_header_items_position[3]\" :key=\"state.id\"></header-item>\n            <li v-if=\"frontendurl\" class=\"dropdown\">\n              <a :href=\"frontendurl\">\n                <span><i :class=\"g3wtemplate.getFontClass('home')\"></i> Home</span>\n              </a>\n            </li>\n            <header-item :state=\"state\" @show-custom-modal-content=\"showCustomModalContent\" v-for=\"state in custom_header_items_position[4]\" :key=\"state.id\"></header-item>\n          </ul>\n        </div>\n      </div>\n    </nav>\n  </header>\n  <!-- Left side column. contains the logo and sidebar -->\n  <sidebar :iframe=\"isIframe\"></sidebar>\n  <!-- Content Wrapper. Contains page content -->\n  <div class=\"content-wrapper\" :style=\"{paddingTop: isIframe ? 0 : null}\">\n    <viewport></viewport>\n  </div>\n  <!-- /.content-wrapper -->\n  <!-- Control Sidebar -->\n  <floatbar></floatbar>\n  <!-- /.control-sidebar -->\n  <!-- Add the sidebar's background. This div must be placed\n       immediately after the control sidebar -->\n  <div class=\"control-sidebar-bg\"></div>\n  <!--full screen modal element-->\n  <div class=\"modal fade modal-fullscreen force-fullscreen\" id=\"full-screen-modal\" tabindex=\"-1\" role=\"dialog\" data-backdrop=\"static\" data-keyboard=\"false\" aria-labelledby=\"full-screen-modal\" aria-hidden=\"true\"></div>\n  <!---->\n  <div id=\"credits\" class=\"modal fade\">\n    <div class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content\">\n        <div class=\"modal-header\">\n          <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n            <span aria-hidden=\"true\">&times;</span>\n          </button>\n          <div style=\"display: flex; flex-direction: column; justify-content: space-around; justify-items: center; align-items: center\">\n            <div class=\"customcredits\" v-if=\"!!customcredits\" v-html=\"customcredits\"></div>\n            <div v-if=\"powered_by\">\n              <div class=\"g3w-credits-block\">\n                <div v-t-template=\"'g3wSuiteFramework'\" class=\"credit-title-logo\"></div>\n                <a target=\"_blank\" href=\"https://g3wsuite.gis3w.it/\">\n                  <img class=\"g3w-suite-logo\" :src=\"g3w_suite_logo\" alt=\"\">\n                </a>\n              </div>\n              <div v-t-template=\"'productOf'\" class=\"credit-title-logo g3w-credits-block\"></div>\n              <a style=\"text-align: center!important;\" href=\"http://www.gis3w.it\" target=\"_blank\">\n                <img :src=\"credits_logo\" class=\"img-responsive center-block\" alt=\"\">\n                <div style=\"text-align: center!important; margin-bottom:10px; margin-top:30px; color:#000000\">\n                  <h4>GIS3W s.n.c.</h4>\n                </div>\n              </a>\n              <address id=\"address-credits\" style=\"line-height: 2; text-align: center\">\n                <i :class=\"g3wtemplate.getFontClass('marker')\" aria-hidden=\"true\"></i>\n                <span> Viale Verdi, 24 - Montecatini Terme (PT)</span></br>\n                <i :class=\"g3wtemplate.getFontClass('mobile')\" aria-hidden=\"true\"></i>\n                <span> +39 347 6597931</span></br>\n                <i :class=\"g3wtemplate.getFontClass('fax')\" aria-hidden=\"true\"></i>\n                <span> +39 0572 901639</span></br>\n                <i :class=\"g3wtemplate.getFontClass('mail')\" aria-hidden=\"true\">\n                </i>\n                <span><a href=\"mailto:info@gis3w.it\" style=\"color:#000000\"> info@gis3w.it</a></span>\n              </address>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n  <div id=\"custom_modal\" class=\"modal fade\">\n    <div class=\"modal-dialog\" role=\"document\">\n      <div class=\"modal-content\" v-html=\"current_custom_modal_content\"></div>\n    </div>\n  </div>\n</div>\n";

},{}],534:[function(require,module,exports){
module.exports = "<div id=\"contents\" class=\"contents\"></div>\n";

},{}],535:[function(require,module,exports){
module.exports = "<aside class=\"control-sidebar control-sidebar-light\" >\n  <a v-show=\"panelsinstack\" href=\"#\" class=\"floatbar-aside-toggle\" data-toggle=\"control-sidebar\" role=\"button\">\n    <span class=\"sr-only\">Expand</span>\n  </a>\n  <div id=\"floatbar-spinner\" style=\"position:absolute\"></div>\n  <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n    <div v-if=\"closable\" class=\"row\">\n      <div class=\"col-xs-12 col-sm-12 col-md-12\">\n        <button :class=\"g3wtemplate.getFontClass('close')\" class=\"pull-right close-panel-button\" @click=\"closePanel\"></button>\n      </div>\n    </div>\n    <div v-if=\"panelname\">\n      <h4 class=\"g3w-floatbarpanel-name\">{{ panelname }}</h4>\n    </div>\n    <div id=\"g3w-floatbarpanel-placeholder\" class=\"g3w-floatbarpanel-placeholder\"></div>\n  </div>\n</aside>\n";

},{}],536:[function(require,module,exports){
module.exports = "<li class=\"customheaderlink dropdown user user-menu\" :title=\"state.title\">\n  <a v-if=\"state.type === 'link'\" :href=\"state.url\" :class=\"{ imagelink : !!state.img}\" :target=\"state.target\" class=\"dropdown-toggle\">\n    <img height=\"40\" v-if=\"state.img\" :src=\"state.img\">\n    <span v-else>{{state.title}}</span>\n  </a>\n  <a v-else-if=\"state.type === 'modal'\" style=\"cursor: pointer\" @click=\"showCustomModal(state.id)\" data-toggle=\"modal\" data-target=\"#custom_modal\" class=\"dropdown-toggle\">\n    <span>{{state.title}}</span>\n  </a>\n</li>\n";

},{}],537:[function(require,module,exports){
module.exports = "<div id=\"menu-projects\" class=\"container\">\n  <div class=\"row row-equal\">\n    <!-- item -->\n    <div v-for=\"menuitem in state.menuitems\"  :key=\"menuitem.title\" @click=\"trigger(menuitem)\" class=\"col-xs-12 col-sm-4 project-menu\">\n      <div class=\"project-menu-item-image\">\n        <img :src=\"logoSrc(menuitem.thumbnail)\" class=\"img-responsive\">\n      </div>\n      <div class=\"project-menu-item-content\">\n        <div class=\"project-menu-item-text\">\n          <h4 class=\"project-menu-item-title\">{{ menuitem.title }}</h4>\n          <div v-html=\"menuitem.description\"></div>\n        </div>\n      </div>\n    </div>\n    <div v-if=\"!state.menuitems.length\" style=\"margin-left:15px;\">\n      <h2 v-t=\"'template.no_other_projects'\"></h2>\n    </div>\n  </div>\n</div>\n";

},{}],538:[function(require,module,exports){
module.exports = "<ul class=\"nav navbar-nav navbar-left\">\n  <li v-for=\"item in items\" :is=\"item\" :key=\"item.id\"></li>\n</ul>\n";

},{}],539:[function(require,module,exports){
module.exports = "<ul class=\"nav navbar-nav navbar-right\">\n  <li v-for=\"item in items\" :is=\"item\" :key=\"item.id\"></li>\n</ul>\n";

},{}],540:[function(require,module,exports){
module.exports = "<li  v-show=\"state.visible\" class=\"treeview sidebaritem\" :class=\"{'active': open}\">\n  <a @click.prevent=\"onClickItem\" ref=\"anchor_click\" href=\"#\">\n    <i :class=\"icon\" :style=\"{color: iconColor}\"></i>\n    <span class=\"treeview-label\">{{title | t}}</span>\n    <span v-if=\"info.state\" style=\"position: absolute; right: 5px; font-weight: bold\" :class=\"info.class\" :style=\"info.style\">{{ info.state }}</span>\n    <i v-if=\"collapsible\" :class=\"g3wtemplate.getFontClass('angle-left')\" class=\"pull-right\"></i>\n  </a>\n  <div id=\"g3w-sidebarcomponent-placeholder\"></div>\n</li>\n";

},{}],541:[function(require,module,exports){
module.exports = "<aside class=\"main-sidebar\" :class=\"{iframe: iframe}\">\n  <!-- sidebar: style can be found in sidebar.less -->\n  <!-- Sidebar toggle button-->\n  <!-- Toggle button on the left side of main sidebar only if not mobile -->\n  <a v-if=\"!isMobile()\" href=\"#\" class=\"sidebar-aside-toggle\" data-toggle=\"offcanvas\" role=\"button\">\n    <i :class=\"g3wtemplate.getFontClass('bars')\"></i>\n  </a>\n\t<div id=\"g3w-sidebar\" class=\"sidebar\">\n    <div v-show=\"panelsinstack\" class=\"g3w-sidebarpanel\">\n      <div style=\"overflow: hidden;line-height: 14px;margin-top: 4px; font-size:1.5em\">\n          <h4 style=\"display: inline-block; font-weight: bold\">{{ gui.title }}</h4>\n          <span @click=\"closePanel\" class=\"g3w-span-button close-pane-button fa-stack fa-lg pull-right\">\n            <i :class=\"g3wtemplate.getFontClass('circle')\" class=\"fa-stack-1x panel-button\"></i>\n            <i :class=\"g3wtemplate.getFontClass('close')\" class=\"fa-stack-1x panel-icon\"></i>\n          </span>\n      </div>\n      <div id=\"g3w-sidebarpanel-placeholder\" class=\"g3w-sidebarpanel-placeholder\"></div>\n    </div>\n    <div id=\"g3w-sidebarcomponents-content\">\n      <ul id=\"g3w-sidebarcomponents\" v-show=\"showmainpanel\" class=\"sidebar-menu\"></ul>\n    </div>\n\t</div>\n\t<!-- /.sidebar -->\n</aside>\n";

},{}],542:[function(require,module,exports){
module.exports = "<div class=\"g3w-viewport\">\n  <div id=\"g3w-view-map\" class=\"g3w-view map\" :style=\"{width:state.map.sizes.width+'px',height:state.map.sizes.height+'px'}\">\n    <transition name=\"fade\" :duration=\"{ enter: 800, leave: 500 }\">\n      <user-message\n        v-if=\"usermessage.show\"\n        @close-usermessage=\"closeUserMessage\"\n        :title=\"usermessage.title\"\n        :message=\"usermessage.message\"\n        :draggable=\"usermessage.draggable\"\n        :closable=\"usermessage.closable\"\n        :position=\"usermessage.position\"\n        :autoclose=\"usermessage.autoclose\"\n        :size=\"usermessage.size\"\n        :type=\"usermessage.type\">\n        <template v-if=\"hooks.header\" v-slot:header>\n          <component :is=\"hooks.header\"></component>\n        </template>\n        <template v-if=\"hooks.body\" v-slot:body>\n          <component :is=\"hooks.body\"></component>\n        </template>\n        <template v-if=\"hooks.footer\" v-slot:footer>\n          <component :is=\"usermessage.hooks.footer\"></component>\n        </template>\n      </user-message>\n    </transition>\n  </div>\n  <div id=\"g3w-view-content\" class=\"g3w-view content\" :style=\"{width:state.content.sizes.width+'px',height:state.content.sizes.height+'px'}\">\n    <div v-if=\"(showtitle && contentTitle) || previousTitle || (state.content.closable && state.content.aside)\" class=\"close-panel-block\">\n      <div v-if=\"previousTitle\" class=\"g3w_contents_back\">\n        <span  @click=\"gotoPreviousContent()\">\n          <span :class=\"g3wtemplate.getFontClass('back')\"></span>{{ previousTitle }}\n        </span>\n      </div>\n      <span v-if=\"state.content.closable && state.content.aside\" @click=\"closeContent\" class=\"g3w-span-button fa-stack fa-lg pull-right\">\n        <i :class=\"g3wtemplate.getFontClass('circle')\"  class=\"fa-stack-2x panel-button\"></i>\n        <i :class=\"g3wtemplate.getFontClass('close')\" class=\"fa-stack-1x panel-icon\"></i>\n      </span>\n      <span v-if=\"showCollapseButton\" class=\"g3w-span-button fa-stack fa-lg pull-right\" @click=\"collapseContent\">\n         <i class=\"fa fa-circle fa-stack-2x panel-button\"></i>\n         <i :class=\"[collapsedContent ? g3wtemplate.getFontClass('arrow-up'): g3wtemplate.getFontClass('arrow-down')]\" class=\"fa-stack-1x panel-icon\"></i>\n      </span>\n      <div class=\"panel-title\" v-if=\"showtitle && contentTitle\">\n        <span id=\"contenttitle\">{{ contentTitle }}</span>\n      </div>\n    </div>\n    <div v-show=\"state.content.loading\" class=\"bar-loader\"></div>\n  </div>\n</div>\n";

},{}],543:[function(require,module,exports){
var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var uniqueId = require('core/utils/utils').uniqueId;
var HeaderItem = require('./headeritem');
var GUI = require('sdk/gui/gui');
var layout = require('./layout');
var compiledTemplate = Vue.compile(require('../html/app.html'));
var AppUI = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      customcredits: false,
      current_custom_modal_content: null
    };
  },

  components: {
    HeaderItem: HeaderItem
  },
  mounted: function mounted() {
    this.$nextTick(function () {
      /* start to render LayoutManager layout */
      layout.loading(false);
      layout.setup();
      //Fix the problem with right sidebar and layout boxed
      layout.pushMenu.expandOnHover();
      layout.controlSidebar._fix($(".control-sidebar-bg"));
      layout.controlSidebar._fix($(".control-sidebar"));
      var controlsidebarEl = layout.options.controlSidebarOptions.selector;
      function setFloatBarMaxHeight() {
        $(controlsidebarEl).css('max-height', $(window).innerHeight());
        $('.g3w-sidebarpanel').css('height', $(window).height() - $("#main-navbar").height());
      }
      setFloatBarMaxHeight();
      function setModalHeight() {
        $('#g3w-modal-overlay').css('height', $(window).height());
      }
      $(window).resize(function () {
        setFloatBarMaxHeight();
        setModalHeight();
      });
    });
  },
  computed: {
    currentProject: function currentProject() {
      return ProjectsRegistry.getCurrentProject();
    },
    appconfig: function appconfig() {
      return ApplicationService.getConfig();
    },
    isIframe: function isIframe() {
      return !!this.appconfig.group.layout.iframe;
    },
    urls: function urls() {
      return this.appconfig.urls;
    },
    powered_by: function powered_by() {
      return this.appconfig.group.powered_by;
    },
    g3w_suite_logo: function g3w_suite_logo() {
      var client_url = this.urls.clienturl;
      return client_url + 'images/g3wsuite_logo.png';
    },

    credits_logo: function credits_logo() {
      var client_url = this.urls.clienturl;
      return client_url + 'images/logo_gis3w_156_85.png';
    },
    logo_url: function logo_url() {
      var logo_project_url = this.currentProject.getThumbnail();
      return logo_project_url ? logo_project_url : '' + this.appconfig.mediaurl + this.appconfig.logo_img;
    },
    logo_link: function logo_link() {
      var logo_link = this.getLogoLink();
      return logo_link ? logo_link : "#";
    },
    logo_link_target: function logo_link_target() {
      var logo_link = this.getLogoLink();
      return logo_link ? "_blank" : "";
    },
    project_title: function project_title() {
      return this.currentProject.getState().name;
    },
    user: function user() {
      return this.appconfig.user && this.appconfig.user.username ? this.appconfig.user : null;
    },
    numberOfProjectsInGroup: function numberOfProjectsInGroup() {
      return this.appconfig.projects.length;
    },
    frontendurl: function frontendurl() {
      return this.urls.frontendurl;
    },
    main_title: function main_title() {
      var main_title = this.appconfig.main_map_title;
      var group_name = this.appconfig.group.name;
      return main_title ? main_title + ' - ' + group_name : group_name;
    }
  },
  methods: {
    showCustomModalContent: function showCustomModalContent(id) {
      var _custom_modals$find = this.custom_modals.find(function (custommodal) {
        return custommodal.id === id;
      }),
          content = _custom_modals$find.content;

      this.current_custom_modal_content = content;
    },

    closePanel: function closePanel() {
      sidebarService.closePanel();
    },
    getLogoLink: function getLogoLink() {
      return this.appconfig.logo_link ? this.appconfig.logo_link : null;
    },
    openProjectsMenu: function openProjectsMenu() {
      GUI.openProjectsMenu();
    }
  },
  created: function created() {
    var _this = this;

    this.custom_modals = [];
    this.custom_header_items_position = {
      0: [],
      1: [],
      2: [],
      3: [],
      4: []
    };
    this.customlinks = Array.isArray(this.appconfig.header_custom_links) ? this.appconfig.header_custom_links.filter(function (customitem) {
      if (customitem !== null) {
        var id = customitem.id = uniqueId();
        customitem.type === 'modal' && _this.custom_modals.push({
          id: id,
          content: customitem.content
        });
        var position = 1 * (customitem.position || 0);
        position = position > 4 ? 4 : position < 0 || (0, _isNan2.default)(position) ? 0 : position;
        _this.custom_header_items_position[position].push(customitem);
        return true;
      }
      return false;
    }) : [];

    !!this.appconfig.credits && $.get(this.appconfig.credits).then(function (credits) {
      _this.customcredits = credits !== 'None' && credits;
    });
  }
}));

module.exports = AppUI;

},{"../html/app.html":533,"./headeritem":547,"./layout":548,"babel-runtime/core-js/number/is-nan":8,"babel-runtime/helpers/extends":22,"core/applicationservice":560,"core/project/projectsregistry":624,"core/utils/utils":630,"sdk/gui/gui":710}],544:[function(require,module,exports){
var utils = require('sdk/core/utils/utils');
var inherit = require('sdk/core/utils/utils').inherit;
var G3WObject = require('sdk/core/g3wobject');
var Component = require('gui/vue/component');
var Panel = require('gui/panel');

//Barstack Class
// It used to mount panels stack
// on top of each parent
function BarStack() {
  this._parent = null;
  // barstack state. It store the panels array
  this.state = {
    contentsdata: []
  };
}

inherit(BarStack, G3WObject);

var proto = BarStack.prototype;

// push componenet on top of parent
proto.push = function (content, options) {
  // parent identify the DOM element where insert (append o meno) the component/panel
  this._parent = options.parent;
  // call barstack mount method
  return this._mount(content, options);
};

// remove last component from stack
proto.pop = function () {
  var _this = this;

  var d = $.Deferred();
  // qui potremo chiedere al pannello se pu essere chiuso...
  if (this.state.contentsdata.length) {
    var content = this.state.contentsdata.slice(-1)[0].content;
    this._unmount(content).then(function () {
      var content = _this.state.contentsdata.pop();
      d.resolve(content);
    });
  } else {
    d.resolve();
  }
  return d.promise();
};

// clear all stack
proto.clear = function () {
  var _this2 = this;

  var d = $.Deferred();
  if (this.state.contentsdata.length) {
    var unmountRequests = [];
    this.state.contentsdata.forEach(function (data) {
      unmountRequests.push(_this2._unmount(data.content));
    });
    $.when(unmountRequests).then(function () {
      _this2.state.contentsdata.splice(0, _this2.state.contentsdata.length);
      d.resolve();
    });
  } else {
    d.resolve();
  }
  return d.promise();
};

proto.getContentData = function () {
  return this.state.contentsdata;
};

proto.getCurrentContentData = function () {
  return this.state.contentsdata[this.state.contentsdata.length - 1];
};

proto.getPreviousContentData = function () {
  return this.state.contentsdata[this.state.contentsdata.length - 2];
};

// funzione che fa il mopnt del componente
proto._mount = function (content, options) {
  // check the type of content:
  // JQuery type
  if (content instanceof jQuery) {
    return this._setJqueryContent(content);
  }
  //String
  else if (_.isString(content)) {
      var jqueryEl = $(content);
      // nel caso in cui content sia testo puro, devo wrapparlo in un tag HTML in modo che $() generi un elemento DOM
      if (!jqueryEl.length) {
        jqueryEl = $('<div>' + content + '</div>');
      }
      return this._setJqueryContent(jqueryEl);
    }
    // Vue
    else if (content.mount && typeof content.mount == 'function') {
        this._checkDuplicateVueContent(content); // if already exist it removed before
        return this._setVueContent(content, options);
      }
      // DOM
      else {
          return this._setDOMContent(content);
        }
};

// JQuery append jQuery comonent
proto._setJqueryContent = function (content, options) {
  $(this._parent).append(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

//Append DOM element
proto._setDOMContent = function (content, options) {
  this._parent.appendChild(content);
  this.state.contentsdata.push({
    content: content,
    options: options
  });
  return utils.resolve();
};

// Mount component to parent
proto._setVueContent = function (content, options) {
  var _this3 = this;

  var d = $.Deferred();
  var append = options.append || false;
  content.mount(this._parent, append).then(function () {
    $(parent).localize();
    // Insert the content into the array with the followind attributes:
    // content: componet object
    // options: es. title, perc etc ...
    _this3.state.contentsdata.push({
      content: content,
      options: options
    });
    d.resolve(content);
  });
  return d.promise();
};

// Check duplicate Vue Content
proto._checkDuplicateVueContent = function (content) {
  var _this4 = this;

  var idxToRemove = null;
  var id = content.getId();
  this.state.contentsdata.forEach(function (data, idx) {
    if (data.content.getId && data.content.getId() == id) {
      idxToRemove = idx;
    }
  });
  if (!_.isNull(idxToRemove)) {
    var data = this.state.contentsdata[idxToRemove];
    data.content.unmount().then(function () {
      _this4.state.contentsdata.splice(idxToRemove, 1);
    });
  }
};

// unmount component
proto._unmount = function (content) {
  var d = $.Deferred();
  if (content instanceof Component || content instanceof Panel) {
    content.unmount().then(function () {
      d.resolve();
    });
  } else {
    $(this._parent).empty();
    d.resolve();
  }
  return d.promise();
};

proto.forEach = function (cbk) {
  this.state.contentsdata.forEach(function (data) {
    cbk(data.content);
  });
};

// Get lenght / numbero of element stored in stack
proto.getLength = function () {
  return this.state.contentsdata.length;
};

module.exports = BarStack;

},{"gui/panel":770,"gui/vue/component":806,"sdk/core/g3wobject":569,"sdk/core/utils/utils":630}],545:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Stack = require('./barstack.js');
var Component = require('gui/vue/component');
var compiledTemplate = Vue.compile(require('../html/contentsviewer.html'));

// Internal Component (VUE) of the content of the  viewport
var InternalComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null
    };
  }
}));

function ContentsViewerComponent(options) {
  base(this, options);
  this.stack = new Stack();
  this.setService(this);
  this.title = "contents";
  // parent component state is
  /*
   this.state = {
    visible: options.visible || true,
    open: options.open || false
   }
   */
  this.contentsdata = this.stack.state.contentsdata;
  this.state.visible = true;
  this.setInternalComponent(new InternalComponent({
    service: this
  }));
  this.internalComponent.state = this.state;
}

inherit(ContentsViewerComponent, Component);

var proto = ContentsViewerComponent.prototype;

proto.setContent = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var push = options.push || false;
  var content = options.content;
  // clean the stack every time, sure to have just one component.
  // Use barstack because it handle the logic og mounting component on DOM
  if (!push) {
    // clear stack
    this.clearContents().then(function () {
      _this.addContent(content, options).then(function () {
        d.resolve(options);
      });
    });
  } else {
    this.addContent(content, options).then(function () {
      d.resolve(options);
    });
  }
  this.setOpen(true);
  return d.promise();
};

proto.addContent = function (content, options) {
  var _this2 = this;

  // parent element is the internal element
  options.parent = this.internalComponent.$el;
  options.append = true;
  return this.stack.push(content, options).then(function () {
    // get stack content
    _this2.contentsdata = _this2.stack.state.contentsdata;
    // update the visibility of the others components
    _this2.updateContentVisibility();
  });
};

// remove content from stack
proto.removeContent = function () {
  this.setOpen(false);
  return this.clearContents();
};

// used by  viewport.js
proto.popContent = function () {
  var _this3 = this;

  return this.stack.pop().then(function () {
    // updatethe content of contentsdata only after stack is updated
    _this3.contentsdata = _this3.stack.state.contentsdata;
    _this3.updateContentVisibility();
  });
};

// get component through class
proto.getComponentByClass = function (componentClass) {
  var component = void 0;
  var contentdata = this.stack.getContentData();
  contentdata.forEach(function (content) {
    if (content.content instanceof componentClass) {
      component = content.content;
      return false;
    }
  });
  return component;
};

// get component by component id
proto.getComponentById = function (id) {
  var component = void 0;
  var contentdata = this.stack.getContentData();
  contentdata.forEach(function (content) {
    if (content.content.id == id) {
      component = content.content;
      return false;
    }
  });
  return component;
};

proto.getContentData = function () {
  return this.stack.getContentData();
};

// get current contentdata
proto.getCurrentContentData = function () {
  return this.stack.getCurrentContentData();
};

// get  previuos contentdata
proto.getPreviousContentData = function () {
  return this.stack.getPreviousContentData();
};

// update visibility of the components of content
proto.updateContentVisibility = function () {
  // hide each elements but not the last one
  var contentsEls = $(this.internalComponent.$el).children();
  contentsEls.hide();
  contentsEls.last().show();
};

// stack clear because if we want the contentComponente stack
// it has to be empty stack
proto.clearContents = function () {
  var _this4 = this;

  return this.stack.clear().then(function () {
    _this4.contentsdata = _this4.stack.state.contentsdata;
  });
};

// Set layout of the content each time
// Parameters are: height and with of the parent content
proto.layout = function (parentWidth, parentHeight) {
  var _this5 = this;

  var el = $(this.internalComponent.$el);
  //run the callback only after that vue state is updated
  Vue.nextTick(function () {
    var contentsdata = _this5.stack.state.contentsdata;
    // el.parent() is div g3w-view-content
    var height = el.parent().height() - el.siblings('.close-panel-block').outerHeight(true) - el.siblings('.g3w_contents_back').outerHeight(true);
    el.height(height);
    el.children().first().height(height);
    contentsdata.forEach(function (data) {
      //check each componentstored in stack
      if (typeof data.content.layout == 'function') {
        //call function layout of each component that are stored into the stack
        data.content.layout(parentWidth + 0.5, height);
      }
    });
  });
};

module.exports = ContentsViewerComponent;

},{"../html/contentsviewer.html":534,"./barstack.js":544,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/vue/component":806}],546:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('sdk/core/i18n/i18n.service').t;
var Stack = require('./barstack.js');
var GUI = require('sdk/gui/gui');

function FloatbarService() {
  this.stack = new Stack();
  this.init = function (layout) {
    this.layout = layout;
    this.sidebarEl = $(this.layout.options.controlSidebarOptions.selector);
    this._zindex = this.sidebarEl.css("z-index");
    this._modalOverlay = null;
    this._modal = false;
    this._isopen = false;
  };

  this.isOpen = function () {
    return this._isopen;
  };

  this.open = function () {
    this.layout.floatBar.open(this.sidebarEl, true);
    this._isopen = true;
  };

  this.close = function () {
    this.layout.floatBar.close(this.sidebarEl, true);
    this._isopen = false;
  };

  this.showPanel = function (panel, options) {
    options = options || {};
    var append = options.append || false;
    var modal = options.modal || false;
    options.parent = "#g3w-floatbarpanel-placeholder";
    this.stack.push(panel, options);
    if (!this._isopen) {
      this.open();
    }
  };

  this.closePanel = function (panel) {
    if (panel) {
      this.stack.remove(panel);
    } else {
      this.stack.pop();
    }
    if (!this.stack.getLength()) {
      if (this._modal) {
        GUI.setModal(false);
        this.close();
        $('.control-sidebar-bg').toggleClass('control-sidebar-bg-shadow');
        this.sidebarEl.css("z-index", "");
        this.sidebarEl.css("padding-top", "50px");
        $('.control-sidebar-bg').css("z-index", "");
        this._modal = false;
      } else {
        this.close();
      }
    }
  };

  this.hidePanel = function () {
    this.close();
  };
}

var floatbarService = new FloatbarService();
var compiledFloatBarTemplate = Vue.compile(require('../html/floatbar.html'));

var FloatbarComponent = Vue.extend((0, _extends3.default)({}, compiledFloatBarTemplate, {
  data: function data() {
    return {
      stack: floatbarService.stack.state
    };
  },
  computed: {
    // active panels on stack
    panelsinstack: function panelsinstack() {
      return this.stack.contentsdata.length > 0;
    },
    panelname: function panelname() {
      var name = void 0;
      if (this.stack.contentsdata.length) {
        name = this.stack.contentsdata.slice(-1)[0].content.getTitle();
      }
      return name;
    },
    closable: function closable() {
      return floatbarService.closable;
    }
  },
  watch: {
    "stack.contentsdata": function stackContentsdata() {
      var children = $("#g3w-floatbarpanel-placeholder").children();
      children.forEach(function (child, index) {
        if (index == children.length - 1) {
          $(child).show();
        } else {
          $(child).hide();
        }
      });
    }
  },
  methods: {
    closePanel: function closePanel() {
      floatbarService.closePanel();
    }
  }
}));

module.exports = {
  FloatbarService: floatbarService,
  FloatbarComponent: FloatbarComponent
};

},{"../html/floatbar.html":535,"./barstack.js":544,"babel-runtime/helpers/extends":22,"sdk/core/i18n/i18n.service":572,"sdk/gui/gui":710}],547:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compiledTemplate = Vue.compile(require('../html/headeritem.html'));
var HeaderItemComponent = (0, _extends3.default)({
  props: ['state']
}, compiledTemplate, {
  methods: {
    showCustomModal: function showCustomModal(id) {
      this.$emit('show-custom-modal-content', id);
    }
  },
  created: function created() {
    this.state.type = this.state.type || 'link';
  }
});

module.exports = HeaderItemComponent;

},{"../html/headeritem.html":536,"babel-runtime/helpers/extends":22}],548:[function(require,module,exports){
//Make sure jQuery has been loaded before app.js
if (typeof jQuery === "undefined") {
  throw new Error("LayoutManager requires jQuery");
}

$.LayoutManager = {};

/* --------------------
 * - LayoutManager Options -
 * --------------------
 * Modify these options to suit your implementation
 */
$.LayoutManager.options = {
  //Add slimscroll to navbar menus
  //This requires you to load the slimscroll plugin
  //in every page before app.js
  navbarMenuSlimscroll: true,
  navbarMenuSlimscrollWidth: "0px", //The width of the scroll bar
  navbarMenuHeight: "200px", //The height of the inner menu
  //General animation speed for JS animated elements such as box collapse/expand and
  //sidebar treeview slide up/down. This options accepts an integer as milliseconds,
  //'fast', 'normal', or 'slow'
  animationSpeed: 'fast',
  //Sidebar push menu toggle button selector
  sidebarToggleSelector: "[data-toggle='offcanvas']",
  //Activate sidebar push menu
  sidebarPushMenu: true,
  //Activate sidebar slimscroll if the fixed layout is set (requires SlimScroll Plugin)
  sidebarSlimScroll: false,
  //Enable sidebar expand on hover effect for sidebar mini
  //This option is forced to true if both the fixed layout and sidebar mini
  //are used together
  sidebarExpandOnHover: false,
  //BoxRefresh Plugin
  enableBoxRefresh: true,
  //Enable Fast Click. Fastclick.js creates a more
  //native touch experience with touch devices. If you
  //choose to enable the plugin, make sure you load the script
  //before LayoutManager's app.js
  enableFastclick: true,
  //Control Sidebar Options
  enableControlSidebar: true,
  controlSidebarOptions: {
    //Which button should trigger the open/close event
    toggleBtnSelector: "[data-toggle='control-sidebar']",
    //The sidebar selector
    selector: ".control-sidebar",
    //Enable slide over content
    slide: true
  },
  //Box Widget Plugin. Enable this plugin
  //to allow boxes to be collapsed and/or removed
  enableBoxWidget: true,
  //Box Widget plugin options
  boxWidgetOptions: {
    boxWidgetIcons: {
      //Collapse icon
      collapse: 'fa-minus',
      //Open icon
      open: 'fa-plus',
      //Remove icon
      remove: 'fa-times'
    },
    boxWidgetSelectors: {
      //Remove button selector
      remove: '[data-widget="remove"]',
      //Collapse button selector
      collapse: '[data-widget="collapse"]'
    }
  },
  //Direct Chat plugin options
  directChat: {
    //Enable direct chat by default
    enable: true,
    //The button to open and close the chat contacts pane
    contactToggleSelector: '[data-widget="chat-pane-toggle"]'
  },
  //Define the set of colors to use globally around the website
  colors: {
    lightBlue: "#3c8dbc",
    red: "#f56954",
    green: "#00a65a",
    aqua: "#00c0ef",
    yellow: "#f39c12",
    blue: "#0073b7",
    navy: "#001F3F",
    teal: "#39CCCC",
    olive: "#3D9970",
    lime: "#01FF70",
    orange: "#FF851B",
    fuchsia: "#F012BE",
    purple: "#8E24AA",
    maroon: "#D81B60",
    black: "#222222",
    gray: "#d2d6de"
  },
  //The standard screen sizes that bootstrap uses.
  //If you change these in the variables.less file, change
  //them here too.
  screenSizes: {
    xs: 480,
    sm: 768,
    md: 992,
    lg: 1200
  }
};

/* ----------------------------------
 * - Initialize the LayoutManager Object -
 * ----------------------------------
 * All LayoutManager functions are implemented below.
 */
$.LayoutManager._init = function () {
  'use strict';
  /* Layout
   * ======
   * Fixes the layout height in case min-height fails.
   *
   * @type Object
   * @usage $.LayoutManager.layout.activate()
   *        $.LayoutManager.layout.fix()
   *        $.LayoutManager.layout.fixSidebar()
   */

  $.LayoutManager.layout = {
    activate: function activate() {
      var _this = this;
      _this.fix();
      _this.fixSidebar();
      $(window, ".wrapper").resize(function () {
        _this.fix();
        _this.fixSidebar();
      });
    },
    fix: function fix() {
      //Get window height and the wrapper height
      var neg = $('.main-header').outerHeight() + $('.main-footer').outerHeight();
      var window_height = $(window).height();
      var sidebar_height = $(".sidebar").height();
      //Set the min-height of the content and sidebar based on the
      //the height of the document.
      if ($("body").hasClass("fixed")) {
        $(".content-wrapper, .right-side").css('min-height', window_height - $('.main-footer').outerHeight());
        $(".content-wrapper, .right-side").css('height', window_height - $('.main-footer').outerHeight());
      } else {
        var postSetWidth = void 0;
        if (window_height >= sidebar_height) {
          $(".content-wrapper, .right-side").css('min-height', window_height - neg);
          postSetWidth = window_height - neg;
        } else {
          $(".content-wrapper, .right-side").css('min-height', sidebar_height);
          postSetWidth = sidebar_height;
        }
        //Fix for the control sidebar height
        var controlSidebar = $($.LayoutManager.options.controlSidebarOptions.selector);
        if (typeof controlSidebar !== "undefined") {
          if (controlSidebar.height() > postSetWidth) $(".content-wrapper, .right-side").css('min-height', controlSidebar.height());
        }
      }
    },
    fixSidebar: function fixSidebar() {
      //Make sure the body tag has the .fixed class
      if (!$("body").hasClass("fixed")) {
        if (typeof $.fn.slimScroll != 'undefined') {
          $(".sidebar").slimScroll({ destroy: true }).height("auto");
        }
        return;
      } else if (typeof $.fn.slimScroll == 'undefined' && window.console) {
        window.console.error("Error: the fixed layout requires the slimscroll plugin!");
      }
      //Enable slimscroll for fixed layout (sidebar)
      if ($.LayoutManager.options.sidebarSlimScroll && !isMobile.any) {
        if (typeof $.fn.slimScroll != 'undefined') {
          //Destroy if it exists
          $("#g3w-sidebar").slimScroll({ destroy: true }).height("auto");
          //Add slimscroll
          $("#g3w-sidebar").slimScroll({
            touchScrollStep: 50,
            height: $(window).height() - $(".navbar-header").height() - 10 + "px",
            color: "rgba(255,255,255,0.7)",
            size: "3px"
          });
        }
      } else {
        $(".sidebar").css({ 'height': $(window).height() - $(".navbar-header").height() + "px" });
        $(".sidebar").css('overflow-y', 'auto');
      }
    }

  };

  /* PushMenu()
   * ==========
   * Adds the push menu functionality to the sidebar.
   *
   * @type Function
   * @usage: $.LayoutManager.pushMenu("[data-toggle='offcanvas']")
   */
  $.LayoutManager.pushMenu = {
    activate: function activate(toggleBtn) {
      //Get the screen sizes
      var screenSizes = $.LayoutManager.options.screenSizes;

      //Enable sidebar toggle
      $(toggleBtn).on('click', function (e) {
        e.preventDefault();

        //Enable sidebar push menu
        if ($(window).width() > screenSizes.sm - 1) {
          if ($("body").hasClass('sidebar-collapse')) {
            $("body").removeClass('sidebar-collapse').trigger('expanded.pushMenu');
          } else {
            $("body").addClass('sidebar-collapse').trigger('collapsed.pushMenu');
          }
        }
        //Handle sidebar push menu for small screens
        else {
            if ($("body").hasClass('sidebar-open')) {
              $("body").removeClass('sidebar-open').removeClass('sidebar-collapse').trigger('collapsed.pushMenu');
            } else {
              $("body").addClass('sidebar-open').trigger('expanded.pushMenu');
            }
          }
      });

      /*$(".content-wrapper").click(function () {
        //Enable hide menu when clicking on the content-wrapper on small screens
        if ($(window).width() <= (screenSizes.sm - 1) && $("body").hasClass("sidebar-open")) {
          $("body").removeClass('sidebar-open');
        }
      });*/

      //Enable expand on hover for sidebar mini
      if ($.LayoutManager.options.sidebarExpandOnHover || $('body').hasClass('fixed') && $('body').hasClass('sidebar-mini')) {
        this.expandOnHover();
      }
    },
    expandOnHover: function expandOnHover() {
      var _this = this;
      var screenWidth = $.LayoutManager.options.screenSizes.sm - 1;
      //Expand sidebar on hover
      $('.main-sidebar').hover(function () {
        if ($('body').hasClass('sidebar-mini') && $("body").hasClass('sidebar-collapse') && $(window).width() > screenWidth) {
          _this.expand();
        }
      }, function () {
        if ($('body').hasClass('sidebar-mini') && $('body').hasClass('sidebar-expanded-on-hover') && $(window).width() > screenWidth) {
          _this.collapse();
        }
      });
    },
    expand: function expand() {
      $("body").removeClass('sidebar-collapse').addClass('sidebar-expanded-on-hover');
    },
    collapse: function collapse() {
      if ($('body').hasClass('sidebar-expanded-on-hover')) {
        $('body').removeClass('sidebar-expanded-on-hover').addClass('sidebar-collapse');
      }
    }
  };

  /* Tree()
   * ======
   * Converts the sidebar into a multilevel
   * tree view menu.
   *
   * @type Function
   * @Usage: $.LayoutManager.tree('.sidebar')
   */
  $.LayoutManager.tree = function (menu) {
    var _this = this;
    var animationSpeed = $.LayoutManager.options.animationSpeed;
    //click event //
    $(document).on('click', menu + ' li a', function (e) {
      //Get the clicked link and the next element
      var $this = $(this);
      //is the content of the "accordion" ul //
      var checkElement = $this.next();

      //Check if the next element is a menu and is visible
      if (checkElement.is('.treeview-menu') && checkElement.is(':visible')) {
        //Close the menu
        checkElement.slideUp(animationSpeed, function () {
          checkElement.parent("li.treeview").removeClass("active");
          checkElement.removeClass('menu-open');
          //Fix the layout in case the sidebar stretches over the height of the window
          //_this.layout.fix();
        });
      }
      //If the menu is not visible
      else if (checkElement.is('.treeview-menu') && !checkElement.is(':visible')) {
          //Get the parent menu
          var parent = $this.parents('ul').first();
          var parent_li = $this.parent("li");
          var li_siblings = parent_li.siblings();
          var parent_find_active;
          var sidebar_content_height = parent.height() - parent.find('li.header').outerHeight();
          var treeviewHeight = parent_li.outerHeight();
          li_siblings.not('.header').each(function (index, el) {
            treeviewHeight += $(el).find('a').outerHeight();
          });
          var section_height = sidebar_content_height - treeviewHeight;
          /*checkElement.css({
            'height': section_height + 'px',
            'max-height':section_height + 'px',
            //'overflow-y': 'auto'
          });*/
          //Close all open menus within the parent
          var ul = parent.find('ul.treeview-menu:visible').slideUp(animationSpeed);
          //Remove the menu-open class from the parent
          ul.removeClass('menu-open');
          //Get the parent li
          //Open the target menu and add the menu-open class
          checkElement.slideDown(animationSpeed, function () {
            //Add the class active to the parent li
            checkElement.addClass('menu-open');
            parent_find_active = parent.find('li.treeview.active');
            parent_find_active.removeClass('active');
            parent_li.addClass('active');
            //Fix the layout in case the sidebar stretches over the height of the window
            _this.layout.fix();
          });
        }
      //if this isn't a link, prevent the page from being redirected
      if (checkElement.is('.treeview-menu')) {
        e.preventDefault();
      }

      //$.LayoutManager.layout.fix();
      //$.LayoutManager.layout.fixSidebar();
    });
  };

  /* ControlSidebar
   * ==============
   * Adds functionality to the right sidebar
   *
   * @type Object
   * @usage $.LayoutManager.controlSidebar.activate(options)
   */
  $.LayoutManager.floatBar = $.LayoutManager.controlSidebar = {
    //instantiate the object
    activate: function activate() {
      //Get the object
      var _this = this;
      //Update options
      var o = $.LayoutManager.options.controlSidebarOptions;
      //Get the sidebar
      var sidebar = $(o.selector);
      //The toggle button
      var btn = $(o.toggleBtnSelector);

      //Listen to the click event
      btn.on('click', function (e) {
        e.preventDefault();
        //If the sidebar is not open
        if (!sidebar.hasClass('control-sidebar-open') && !$('body').hasClass('control-sidebar-open')) {
          //Open the sidebar
          _this.open(sidebar, o.slide);
        } else {
          _this.close(sidebar, o.slide);
        }
      });

      //If the body has a boxed layout, fix the sidebar bg position
      var bg = $(".control-sidebar-bg");
      _this._fix(bg);

      //If the body has a fixed layout, make the control sidebar fixed
      if ($('body').hasClass('fixed')) {
        _this._fixForFixed(sidebar);
      } else {
        //If the content height is less than the sidebar's height, force max height
        if ($('.content-wrapper, .right-side').height() < sidebar.height()) {
          _this._fixForContent(sidebar);
        }
      }
    },
    //Open the control sidebar
    open: function open(sidebar, slide) {
      //Slide over content
      if (slide) {
        sidebar.addClass('control-sidebar-open');
      } else {
        //Push the content by adding the open class to the body instead
        //of the sidebar itself
        $('body').addClass('control-sidebar-open');
      }
    },
    //Close the control sidebar
    close: function close(sidebar, slide) {
      if (slide) {
        sidebar.removeClass('control-sidebar-open');
      } else {
        $('body').removeClass('control-sidebar-open');
      }
    },
    _fix: function _fix(sidebar) {
      var _this = this;
      if ($("body").hasClass('layout-boxed')) {
        sidebar.css('position', 'absolute');
        sidebar.height($(".wrapper").height());
        $(window).resize(function () {
          _this._fix(sidebar);
        });
      } else {
        sidebar.css({
          'position': 'fixed',
          'height': 'auto'
        });
      }
    },
    _fixForFixed: function _fixForFixed(sidebar) {
      sidebar.css({
        'position': 'fixed',
        'max-height': '100%',
        //'overflow': 'auto',  // non dovrebbe fare danni questo commento, serve per non nascondere il pulsanti "Chiudi pannello"
        'padding-bottom': '50px'
      });
    },
    _fixForContent: function _fixForContent(sidebar) {
      $(".content-wrapper, .right-side").css('min-height', sidebar.height());
    }
  };

  /* BoxWidget
   * =========
   * BoxWidget is a plugin to handle collapsing and
   * removing boxes from the screen.
   *
   * @type Object
   * @usage $.LayoutManager.boxWidget.activate()
   *        Set all your options in the main $.LayoutManager.options object
   */
  $.LayoutManager.boxWidget = {
    selectors: $.LayoutManager.options.boxWidgetOptions.boxWidgetSelectors,
    icons: $.LayoutManager.options.boxWidgetOptions.boxWidgetIcons,
    animationSpeed: $.LayoutManager.options.animationSpeed,
    activate: function activate(_box) {
      var _this = this;
      if (!_box) {
        _box = document; // activate all boxes per default
      }
      //Listen for collapse event triggers
      $(_box).on('click', _this.selectors.collapse, function (e) {
        e.preventDefault();
        _this.collapse($(this));
      });

      //Listen for remove event triggers
      $(_box).on('click', _this.selectors.remove, function (e) {
        e.preventDefault();
        _this.remove($(this));
      });
    },
    collapse: function collapse(element) {
      var _this = this;
      //Find the box parent
      var box = element.parents(".box").first();
      //Find the body and the footer
      var box_content = box.find("> .box-body, > .box-footer, > form  >.box-body, > form > .box-footer");
      if (!box.hasClass("collapsed-box")) {
        //Convert minus into plus
        element.find(".btn-collapser").removeClass(_this.icons.collapse).addClass(_this.icons.open);
        //Hide the content
        box_content.slideUp(_this.animationSpeed, function () {
          box.addClass("collapsed-box");
        });
      } else {
        //Convert plus into minus
        element.find(".btn-collapser").removeClass(_this.icons.open).addClass(_this.icons.collapse);
        //Show the content
        box_content.slideDown(_this.animationSpeed, function () {
          box.removeClass("collapsed-box");
        });
      }
    },
    remove: function remove(element) {
      //Find the box parent
      var box = element.parents(".box").first();
      box.slideUp(this.animationSpeed);
    }
  };

  return $.LayoutManager;
};

/* ------------------
 * - Custom Plugins -
 * ------------------
 * All custom plugins are defined below.
 */

/*
 * BOX REFRESH BUTTON
 * ------------------
 * This is a custom plugin to use with the component BOX. It allows you to add
 * a refresh button to the box. It converts the box's state to a loading state.
 *
 * @type plugin
 * @usage $("#box-widget").boxRefresh( options );
 */
$.LayoutManager.addRefreshButton = function () {
  "use strict";

  $.fn.boxRefresh = function (options) {

    // Render options
    var settings = $.extend({
      //Refresh button selector
      trigger: ".refresh-btn",
      //File source to be loaded (e.g: ajax/src.php)
      source: "",
      //Callbacks
      onLoadStart: function onLoadStart(box) {
        return box;
      }, //Right after the button has been clicked
      onLoadDone: function onLoadDone(box) {
        return box;
      } //When the source has been loaded

    }, options);

    //The overlay
    var overlay = $('<div class="overlay"><div class="fa fa-refresh fa-spin"></div></div>');

    return this.each(function () {
      //if a source is specified
      if (settings.source === "") {
        if (window.console) {
          window.console.log("Please specify a source first - boxRefresh()");
        }
        return;
      }
      //the box
      var box = $(this);
      //the button
      var rBtn = box.find(settings.trigger).first();

      //On trigger click
      rBtn.on('click', function (e) {
        e.preventDefault();
        //Add loading overlay
        start(box);

        //Perform ajax call
        box.find(".box-body").load(settings.source, function () {
          done(box);
        });
      });
    });

    function start(box) {
      //Add overlay and loading img
      box.append(overlay);

      settings.onLoadStart.call(box);
    }

    function done(box) {
      //Remove overlay and loading img
      box.find(overlay).remove();

      settings.onLoadDone.call(box);
    }
  };
  return $.LayoutManager;
};

/*
 * EXPLICIT BOX ACTIVATION
 * -----------------------
 * This is a custom plugin to use with the component BOX. It allows you to activate
 * a box inserted in the DOM after the app.js was loaded.
 *
 * @type plugin
 * @usage $("#box-widget").activateBox();
 */
$.LayoutManager.activateBox = function () {
  'use strict';

  $.fn.activateBox = function () {
    $.LayoutManager.boxWidget.activate(this);
  };

  return $.LayoutManager;
};

/*
 * TODO LIST CUSTOM PLUGIN
 * -----------------------
 * This plugin depends on iCheck plugin for checkbox and radio inputs
 *
 * @type plugin
 * @usage $("#todo-widget").todolist( options );
 */

$.LayoutManager.listCustomPlugin = function () {

  'use strict';

  $.fn.todolist = function (options) {
    // Render options
    var settings = $.extend({
      //When the user checks the input
      onCheck: function onCheck(ele) {
        return ele;
      },
      //When the user unchecks the input
      onUncheck: function onUncheck(ele) {
        return ele;
      }
    }, options);

    return this.each(function () {

      if (typeof $.fn.iCheck != 'undefined') {
        $('input', this).on('ifChecked', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          settings.onCheck.call(ele);
        });

        $('input', this).on('ifUnchecked', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          settings.onUncheck.call(ele);
        });
      } else {
        $('input', this).on('change', function () {
          var ele = $(this).parents("li").first();
          ele.toggleClass("done");
          if ($('input', ele).is(":checked")) {
            settings.onCheck.call(ele);
          } else {
            settings.onUncheck.call(ele);
          }
        });
      }
    });
  };
  return $.LayoutManager;
};

/* ------------------
 * - Implementation -
 * ------------------
 * The next block of code implements LayoutManager's
 * functions and plugins as specified by the
 * options above.
 */
$.LayoutManager.setup = function () {
  "use strict";

  //Fix for IE page transitions

  $("body").removeClass("hold-transition");

  //Extend options if external options exist
  if (typeof LayoutManagerOptions !== "undefined") {
    $.extend(true, $.LayoutManager.options, LayoutManagerOptions);
  }

  //Easy access to options
  var o = $.LayoutManager.options;

  //Set up the object
  $.LayoutManager._init();

  //Activate the layout maker
  $.LayoutManager.layout.activate();

  //Enable sidebar tree view controls
  $.LayoutManager.tree('.sidebar');

  //Enable control sidebar
  if (o.enableControlSidebar) {
    $.LayoutManager.controlSidebar.activate();
  }

  //Add slimscroll to navbar dropdown
  if (o.navbarMenuSlimscroll && typeof $.fn.slimscroll != 'undefined') {
    $(".navbar .menu").slimscroll({
      height: o.navbarMenuHeight,
      alwaysVisible: false,
      size: o.navbarMenuSlimscrollWidth
    }).css("width", "100%");
  }

  //Activate sidebar push menu
  if (o.sidebarPushMenu) {
    $.LayoutManager.pushMenu.activate(o.sidebarToggleSelector);
  }

  //Activate box widget
  if (o.enableBoxWidget) {
    $.LayoutManager.boxWidget.activate();
  }

  //Activate fast click
  if (o.enableFastclick && typeof FastClick != 'undefined') {
    FastClick.attach(document.body);
  }

  //Activate direct chat widget
  if (o.directChat.enable) {
    $(document).on('click', o.directChat.contactToggleSelector, function () {
      var box = $(this).parents('.direct-chat').first();
      box.toggleClass('direct-chat-contacts-open');
    });
  }

  /*
   * INITIALIZE BUTTON TOGGLE
   * ------------------------
   */
  $('.btn-group[data-toggle="btn-toggle"]').each(function () {
    var group = $(this);
    $(this).find(".btn").on('click', function (e) {
      group.find(".btn.active").removeClass("active");
      $(this).addClass("active");
      e.preventDefault();
    });
  });

  return $.LayoutManager.addRefreshButton().activateBox().listCustomPlugin();
};

$.LayoutManager.loading = function (start) {
  $('#initerror').remove();
  start = _.isBoolean(start) ? start : true;
  if (start) {
    $('body').append("\n         <div id=\"startingspinner\">\n         <div class=\"double-bounce1\"></div>\n         <div class=\"double-bounce2\"></div>\n         </div>");
  } else {
    $('#startingspinner').remove();
  }
};

module.exports = $.LayoutManager;

},{}],549:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');
var compiledTemplate = Vue.compile(require('../html/menu.html'));

var InternalComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null,
      loading: false
    };
  },
  methods: {
    trigger: function trigger(item) {
      if (item.cbk) {
        //set full screen modal
        GUI.showFullModal({
          show: true
        });
        GUI.setLoadingContent(true);
        var gid = item.gid;

        item.cbk.call(item, {
          gid: gid
        }).then(function (promise) {
          //changeProject is a setter so it return a promise
          promise.then(function () {}).fail(function () {
            GUI.notify.error("<h4>" + t("error_map_loading") + "</h4>" + "<h5>" + t("check_internet_connection_or_server_admin") + "</h5>");
          }).always(function () {
            GUI.showFullModal({
              show: false
            });
            GUI.setLoadingContent(false);
          });
        });
      } else if (item.href) window.open(item.href, '_blank');else if (item.route) GUI.goto(item.route);else console.log("No action for " + item.title);
    },
    logoSrc: function logoSrc(src) {
      var fakeImage = '/static/client/images/FakeProjectThumb.png';
      if (src) {
        return src.indexOf(ProjectsRegistry.config.mediaurl) !== -1 ? src : src.indexOf('static') === -1 && src.indexOf('media') === -1 ? '' + ProjectsRegistry.config.mediaurl + src : fakeImage;
      } else return fakeImage;
    }
  },
  mounted: function mounted() {}
}));

function MenuComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.title = options.title || "menu";
  this.state.visible = true;
  this.state.menuitems = options.menuitems;
  merge(this, options);
  this.internalComponent = new InternalComponent({
    service: this
  });
  this.internalComponent.state = this.state;
}
inherit(MenuComponent, Component);

var proto = MenuComponent.prototype;

proto.trigger = function (item) {};

module.exports = MenuComponent;

},{"../html/menu.html":537,"babel-runtime/helpers/extends":22,"core/i18n/i18n.service":572,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/gui":710,"gui/vue/component":806}],550:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var G3WObject = require('sdk/core/g3wobject');
var base = require('sdk/core/utils/utils').base;

// service sidebar
function navbaritemsService() {
  this.state = {
    items: {
      left: [],
      right: []
    }

  };
  this.addItem = function (item, position) {
    position = position || 'right';
    this.state.items[position].push(item);
  };

  base(this);
}

inherit(navbaritemsService, G3WObject);

var navbaritemsservice = new navbaritemsService();
var compiledTemplate = Vue.compile(require('../html/navbarleftitems.html'));

var NavbarLeftItemsComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      items: navbaritemsservice.state.items.left
    };
  },
  computed: {},
  methods: {}
}));

var NavbarRightItemsComponent = Vue.extend({
  template: require('../html/navbarrightitems.html'),
  data: function data() {
    return {
      items: navbaritemsservice.state.items.right
    };
  },
  computed: {},
  methods: {}
});

module.exports = {
  NavbarItemsService: navbaritemsservice,
  components: {
    left: NavbarLeftItemsComponent,
    right: NavbarRightItemsComponent
  }
};

},{"../html/navbarleftitems.html":538,"../html/navbarrightitems.html":539,"babel-runtime/helpers/extends":22,"sdk/core/g3wobject":569,"sdk/core/i18n/i18n.service":572,"sdk/core/utils/utils":630}],551:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectRegistry = require('core/project/projectsregistry');
var MenuComponent = require('./menu');

function ProjectsMenuComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.id = 'projectsmenu';
  base(this, options);
  this.state.menuitems = [];
  var host = options.host;
  var ApplicationService = require('core/applicationservice');
  var projects = options.projects || ProjectRegistry.getListableProjects();
  this.state.menuitems = projects.map(function (project) {
    return {
      title: project.title,
      description: project.description,
      thumbnail: project.thumbnail,
      gid: project.gid,
      cbk: options.cbk || function () {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var gid = options.gid;

        return ApplicationService.changeProject({
          gid: gid,
          host: host
        });
      }
    };
  });
}

inherit(ProjectsMenuComponent, MenuComponent);

module.exports = ProjectsMenuComponent;

},{"./menu":549,"core/applicationservice":560,"core/project/projectsregistry":624,"core/utils/utils":630}],552:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var Stack = require('./barstack.js');
var G3WObject = require('sdk/core/g3wobject');
var base = require('sdk/core/utils/utils').base;
var compiledSideBarItemTemplate = Vue.compile(require('../html/sidebar-item.html'));

var SIDEBAREVENTBUS = new Vue();

//sidebar item is a <li> dom element of the sidebar . Where is possible set
//title, icon type etc ..  is possible to customize component
var SidebarItem = Vue.extend((0, _extends3.default)({}, compiledSideBarItemTemplate, {
  data: function data() {
    return {
      info: this.$options.info || {
        state: null,
        style: null,
        class: null
      },
      main: true,
      component: this.$options.component,
      active: false,
      title: '',
      open: false,
      icon: null,
      iconColor: null,
      collapsible: null
    };
  },
  methods: {
    onClickItem: function onClickItem() {
      var _this = this;

      var sidebarService = this.$options.service;
      // force to close
      if (!this.component.state.open) {
        // set state of opened component
        sidebarService.state.components.forEach(function (component) {
          if (component !== _this.component && (_this.component.collapsible || !_this.component.context)) {
            if (component.state.open) {
              !_this.component.context ? $(component.getInternalComponent().$el).siblings('a').click() : null;
              component.setOpen(false);
            }
          }
        });
      }
      this.component.setOpen(!this.component.state.open);
      if (!this.component.collapsible && isMobile.any) {
        SIDEBAREVENTBUS.$emit('sidebaritemclick');
      }
    }
  },
  created: function created() {
    var _this2 = this;

    this.component.openClose = function () {
      _this2.$refs.anchor_click.click();
    };
  }
}));

function SidebarService() {
  //set sidebar stack
  this.stack = new Stack();
  // set setter for close sidebarpanel to catch event
  // of closing panel of the sidebar
  this.setters = {
    closeSidebarPanel: function closeSidebarPanel() {},
    openCloseItem: function openCloseItem(bool) {}
  };
  //service state
  this.state = {
    components: [],
    gui: {
      title: ''
    }
  };
  //inizialize method
  this.init = function (layout) {
    this.layout = layout;
  };
  // add component to sidebar
  this.addComponents = function (components) {
    var _this3 = this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    //for each component of the sidebar it is call addComponent method
    components.forEach(function (component) {
      _this3.addComponent(component, options);
    });
    return true;
  };
  // add each component to the sidebar
  // add also position insiede the sidebar
  this.addComponent = function (component) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var position = options.position,
        info = options.info;

    if (isMobile.any && !component.mobile) {
      return false;
    }
    var sidebarItem = new SidebarItem({
      service: this,
      info: info,
      component: component
    });
    sidebarItem.title = component.title || sidebarItem.title;
    sidebarItem.info = component.info || sidebarItem.info;
    sidebarItem.open = component.state.open; //(component.open === undefined) ? sidebarItem.open : component.open;
    sidebarItem.icon = component.icon || sidebarItem.icon;
    sidebarItem.iconColor = component.iconColor;
    sidebarItem.state = component.state || true;
    sidebarItem.collapsible = typeof component.collapsible === 'boolean' ? component.collapsible : true;
    sidebarItem.context = typeof component.context === 'boolean' ? component.context : true;
    //append component to  g3w-sidebarcomponents (template sidebar.html)
    var DOMComponent = sidebarItem.$mount().$el;
    this.state.components.push(component);
    if (position === null || position === undefined || position < 0) $('#g3w-sidebarcomponents').append(DOMComponent);else {
      $('#g3w-sidebarcomponents').children().each(function (index, element) {
        if (position === index) {
          $(DOMComponent).insertBefore(element);
        }
      });
    }
    //mount componet to g3w-sidebarcomponent-placeholder (template sidebar-item.html);
    component.mount("#g3w-sidebarcomponent-placeholder");
    // check if componentonent has iniService method
    if (_.has(component, 'initService')) {
      component.initService();
    }
    return true;
  };

  // get component by id
  this.getComponent = function (id) {
    var Component = void 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(this.state.components), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var component = _step.value;

        if (component.getId() === id) {
          Component = component;
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return Component;
  };

  // get all components
  this.getComponents = function () {
    return this.state.components;
  };

  this.reloadComponent = function (id) {
    var component = this.getComponent(id);
    component.reload();
  };

  this.reloadComponents = function () {
    // force close of the panel
    this.closePanel();
    this.state.components.forEach(function (component) {
      if (component.collapsible && component.state.open) {
        $(component.getInternalComponent().$el).siblings().click();
        component.setOpen(false);
      }
      component.reload();
    });
  };
  //remove component
  this.removeComponent = function (component) {
    var _this4 = this;

    this.state.components.forEach(function (sidebarComponent, index) {
      if (component === sidebarComponent) {
        component.unmount();
        _this4.state.components.splice(index, 1);
        return false;
      }
    });
  };
  // show panel on stack
  this.showPanel = function (panel) {
    var _this5 = this;

    return new _promise2.default(function (resolve, reject) {
      _this5.state.gui.title = panel.title;
      var parent = "#g3w-sidebarpanel-placeholder";
      _this5.stack.push(panel, {
        parent: parent
      }).then(function (content) {
        resolve(content);
      });
    });
  };

  // close panel
  this.closePanel = function () {
    this.closeSidebarPanel();
    this.stack.pop().then(function (content) {
      content = null;
    });
  };

  base(this);
}

inherit(SidebarService, G3WObject);

var sidebarService = new SidebarService();
var compiledSideBarTemplate = Vue.compile(require('../html/sidebar.html'));
var SidebarComponent = Vue.extend((0, _extends3.default)({}, compiledSideBarTemplate, {
  props: {
    iframe: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      components: sidebarService.state.components,
      panels: sidebarService.stack.state.contentsdata,
      bOpen: true,
      bPageMode: false,
      header: t('main navigation'),
      gui: sidebarService.state.gui
    };
  },
  computed: {
    // quanti pannelli sono attivi nello stack
    panelsinstack: function panelsinstack() {
      return this.panels.length > 0;
    },
    showmainpanel: function showmainpanel() {
      return this.components.length > 0 && !this.panelsinstack;
    },
    componentname: function componentname() {
      return this.components.length ? this.components.slice(-1)[0].getTitle() : "";
    },
    panelname: function panelname() {
      var name = "";
      if (this.panels.length) {
        name = this.panels.slice(-1)[0].content.getTitle();
      }
      return name;
    }
  },
  methods: {
    closePanel: function closePanel() {
      sidebarService.closePanel();
    }
  },
  created: function created() {
    SIDEBAREVENTBUS.$on('sidebaritemclick', function () {
      $('.sidebar-toggle').click();
    });
  }
}));

module.exports = {
  SidebarService: sidebarService,
  SidebarComponent: SidebarComponent
};

},{"../html/sidebar-item.html":540,"../html/sidebar.html":541,"./barstack.js":544,"babel-runtime/core-js/get-iterator":4,"babel-runtime/core-js/promise":16,"babel-runtime/helpers/extends":22,"sdk/core/g3wobject":569,"sdk/core/i18n/i18n.service":572,"sdk/core/utils/utils":630}],553:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('sdk/core/i18n/i18n.service').t;
var inherit = require('sdk/core/utils/utils').inherit;
var base = require('sdk/core/utils/utils').base;
var G3WObject = require('sdk/core/g3wobject');
var ProjectsMenuComponent = require('./projectsmenu');
var ComponentsRegistry = require('sdk/gui/componentsregistry');
var GUI = require('sdk/gui/gui');
var VueTemplatePlugin = require('./vuetemplateplugin');

// // start to sue composition api
// Vue.use(vueCompositionApi.default);

// install template information library (es. classes etc..)
Vue.use(VueTemplatePlugin, {
  font: {
    name: 'fontawsome',
    version: '5'
  }
});

// set mixins inheriAttrs to avoid tha unused props are setted as attrs
Vue.mixin({
  inheritAttrs: false
});

// get all items needed by application
var sidebar = require('./sidebar');
var floatbar = require('./floatbar');
var viewport = require('./viewport');
var navbaritems = require('./navbaritems');
var AppUI = require('./applicationui');
var layout = require('./layout');

// loading spinner at beginning
layout.loading(true);

var ApplicationTemplate = function ApplicationTemplate(_ref) {
  var ApplicationService = _ref.ApplicationService;

  var appLayoutConfig = ApplicationService.getConfig().layout || {};
  // useful to build a difference layout/component based on mobile or not
  this._isMobile = isMobile.any;
  this._isIframe = appLayoutConfig.iframe;
  this.init = function () {
    // create Vue App
    this._createApp();
  };
  // create application config
  this._createTemplateConfig = function () {
    var G3WTemplate = Vue.prototype.g3wtemplate;
    var appTitle = ApplicationService.getConfig().apptitle || 'G3W Suite';
    // get sdk componets
    var ContentsComponent = require('./contentsviewer');
    var CatalogComponent = require('sdk/gui/catalog/vue/catalog');
    var SearchComponent = require('sdk/gui/search/vue/search');
    var PrintComponent = require('sdk/gui/print/vue/print');
    var MetadataComponent = require('sdk/gui/metadata/vue/metadata');
    var ToolsComponent = require('sdk/gui/tools/vue/tools');
    var MapComponent = require('sdk/gui/map/vue/map');
    var QueryResultsComponent = require('sdk/gui/queryresults/vue/queryresults');
    return {
      title: appTitle,
      placeholders: {
        navbar: {
          components: []
        },
        sidebar: {
          components: [new MetadataComponent({
            id: 'metadata',
            open: false,
            collapsible: false,
            context: false,
            icon: G3WTemplate.getFontClass('file'),
            mobile: true
          }), new PrintComponent({
            id: 'print',
            open: false,
            collapsible: true, //  it used to manage click event if can run setOpen component method
            icon: G3WTemplate.getFontClass('print'),
            mobile: false
          }), new SearchComponent({
            id: 'search',
            open: false,
            collapsible: true,
            icon: G3WTemplate.getFontClass('search'),
            mobile: true
          }),
          // Component that store plugins
          new ToolsComponent({
            id: 'tools',
            open: false,
            collapsible: true,
            icon: G3WTemplate.getFontClass('tools'),
            mobile: false
          }), new CatalogComponent({
            id: 'catalog',
            open: false,
            collapsible: false,
            icon: G3WTemplate.getFontClass('map'),
            mobile: true,
            config: {
              legend: appLayoutConfig.legend
            }
          })]
        },
        floatbar: {
          components: []
        }
      },
      othercomponents: [new QueryResultsComponent({
        id: 'queryresults'
      })],
      viewport: {
        // placeholder of the content (view content). Secondary view (hidden)
        components: {
          map: new MapComponent({
            id: 'map'
          }),
          content: new ContentsComponent({
            id: 'contents'
          })
        }
      }
    };
  };

  //Vue app
  this._createApp = function () {
    var self = this;
    if (isMobile.any || this._isIframe) {
      $('body').addClass('sidebar-collapse');
    }
    return new Vue({
      el: '#app',
      created: function created() {
        // set general metods for the application as  GUI.showForm etc ..
        self._setupInterface();
        // setup layout
        self._setupLayout();
        //register all services fro the application
        self._setUpServices();
        // create templateConfig
        self.templateConfig = self._createTemplateConfig();
      },

      mounted: function mounted() {
        this.$nextTick(function () {
          self._buildTemplate();
          // setup Font, Css class methods
          self._setUpTemplateDependencies(this);
          $(document).localize();
          self._setViewport(self.templateConfig.viewport);
          var skinColor = $('.navbar').css('background-color');
          GUI.skinColor = skinColor && '#' + skinColor.substr(4, skinColor.indexOf(')') - 4).split(',').map(function (color) {
            return parseInt(color).toString(16);
          }).join('');
          this.$nextTick(function () {
            self.emit('ready');
            //getSkinColor
            GUI.ready();
          });
        });
      }
    });
  };

  this._setupLayout = function () {
    Vue.filter('t', function (value) {
      return t(value);
    });

    if (!isMobile.any) {
      // setup map controls
      $("<style type='text/css'> .ol-control-tl {" + "top: 7px;" + "left:43px;" + "}</style>").appendTo("head");
    }
    // Inizialization of the components of the application
    Vue.component('sidebar', sidebar.SidebarComponent);
    //Navbar custom items
    Vue.component('navbarleftitems', navbaritems.components.left);
    Vue.component('navbarrightitems', navbaritems.components.right);
    Vue.component('viewport', viewport.ViewportComponent);
    Vue.component('floatbar', floatbar.FloatbarComponent);
    Vue.component('app', AppUI);
    // dataTable Translations
    $.extend(true, $.fn.dataTable.defaults, {
      "language": {
        "paginate": {
          "previous": t("dataTable.previous"),
          "next": t("dataTable.next")
        },
        "info": t("dataTable.info"),
        "zeroRecords": t("dataTable.nodatafilterd"),
        "infoFiltered": t("dataTable.infoFiltered")
      }
    });
  };

  // route setting att beginning (is an example)
  this._addRoutes = function () {
    var RouterService = ApplicationService.getRouterService();
    var mapService = GUI.getComponent('map').getService();
    RouterService.addRoute('map/zoomto/{coordinate}/:zoom:', function (coordinate, zoom) {
      coordinate = _.map(coordinate.split(','), function (xy) {
        return Number(xy);
      });
      zoom = zoom ? Number(zoom) : null;
      if (coordinate.length) {
        mapService.on('ready', function () {
          this.zoomTo(coordinate, zoom);
        });
      }
    });
  };

  //register all services
  this._setUpServices = function () {
    _.forEach(ApplicationTemplate.Services, function (service, element) {
      ApplicationService.registerService(element, service);
    });
    _.forEach(GUI.getComponents(), function (component) {
      ApplicationService.registerService(component.id, component.getService());
    });
  };
  // build template function
  this._buildTemplate = function () {
    var _this = this;

    floatbar.FloatbarService.init(layout);
    // recupero i plceholders dalla configurazione del template
    var placeholdersConfig = this.templateConfig.placeholders;
    // ciclo su ogni placeholder
    (0, _entries2.default)(placeholdersConfig).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
          placeholder = _ref3[0],
          options = _ref3[1];

      _this._addComponents(options.components, placeholder);
    });
    //register other compoents
    this._addOtherComponents();
  };

  //add component not related to placeholder
  this._addOtherComponents = function () {
    if (this.templateConfig.othercomponents) {
      this._addComponents(this.templateConfig.othercomponents);
    }
  };
  // viewport setting
  this._setViewport = function (viewportOptions) {
    // viewport components
    // es.: map e content
    /*
     components: {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'content',
      })
     }
      */
    if (viewportOptions) {
      ApplicationTemplate.Services.viewport.init(viewportOptions);
      this._addComponents(viewportOptions.components);
    }
  };

  // add component to template
  this._addComponent = function (component, placeholder) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    this._addComponents([component], placeholder, options);
  };

  // registry component
  this._addComponents = function (components, placeholder, options) {
    var register = true;
    if (placeholder && ApplicationTemplate.PLACEHOLDERS.indexOf(placeholder) > -1) {
      var placeholderService = ApplicationTemplate.Services[placeholder];
      if (placeholderService) register = placeholderService.addComponents(components, options);
    }
    (0, _entries2.default)(components).forEach(function (_ref4) {
      var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
          key = _ref5[0],
          component = _ref5[1];

      register && ComponentsRegistry.registerComponent(component);
    });
  };

  this._removeComponent = function (componentId) {
    ComponentsRegistry.unregisterComponent(componentId);
  };

  this._showModalOverlay = function () {
    var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var message = arguments[1];

    var mapService = GUI.getComponent('map').getService();
    if (bool) mapService.startDrawGreyCover(message);else mapService.stopDrawGreyCover();
  };

  this._showSidebar = function () {
    $('body').addClass('sidebar-open');
    $('body').removeClass('sidebar-collapse');
  };

  this._hideSidebar = function () {
    $('body').removeClass('sidebar-open');
    $('body').addClass('sidebar-collapse');
  };

  // setup Fonts Css dependencies methods
  this._setUpTemplateDependencies = function (VueApp) {
    GUI.isMobile = function () {
      return isMobile.any;
    };
    // method that return Template Info
    GUI.getTemplateInfo = function () {
      return VueApp.g3wtemplate.getInfo();
    };
    GUI.getTemplateInfo = function () {
      return VueApp.g3wtemplate.getInfo();
    };
    GUI.getFontClass = function (type) {
      return VueApp.g3wtemplate.getFontClass(type);
    };
  };
  // setup Interaces
  this._setupInterface = function () {
    var _this2 = this;

    /* PLUBLIC INTERFACE */
    /* Common methods */
    GUI.layout = layout;
    GUI.addComponent = this._addComponent.bind(this);
    GUI.removeComponent = this._removeComponent.bind(this);
    /* Metodos to define */
    GUI.getResourcesUrl = _.bind(function () {
      return ApplicationService.getConfig().resourcesurl;
    }, this);
    //LIST
    GUI.showList = _.bind(floatbar.FloatbarService.showPanel, floatbar.FloatbarService);
    GUI.closeList = _.bind(floatbar.FloatbarService.closePanel, floatbar.FloatbarService);
    GUI.hideList = _.bind(floatbar.FloatbarService.hidePanel, floatbar.FloatbarService);
    // TABLE
    GUI.showTable = function () {};
    GUI.closeTable = function () {};
    GUI.showContentFactory = function (type) {
      var showPanelContent = void 0;
      switch (type) {
        case 'query':
          showPanelContent = GUI.showQueryResults;
          break;
        case 'form':
          showPanelContent = GUI.showForm;
          break;
      }
      return showPanelContent;
    };
    GUI.showForm = function (options) {
      var FormComponent = require('sdk').gui.vue.FormComponent;
      // new isnstace every time
      var formComponent = options.formComponent ? new options.formComponent(options) : new FormComponent(options);
      //get service
      var formService = formComponent.getService();
      // parameters : [content, title, push, perc, split, closable]
      GUI.setContent({
        perc: options.perc || null,
        content: formComponent,
        split: options.split || 'h',
        push: !!options.push, //only one( if other delete previous component)
        showgoback: !!options.showgoback,
        closable: false
      });
      // return service
      return formService;
    };
    GUI.closeForm = function () {
      this.emit('closeform', false);
      viewport.ViewportService.removeContent();
      // force set modal to false
      GUI.setModal(false);
    };

    GUI.disableElement = function (_ref6) {
      var element = _ref6.element,
          disable = _ref6.disable;

      disable && $(element).addClass('g3w-disabled') || $(element).removeClass('g3w-disabled');
    };

    GUI.disableContent = function (disable) {
      GUI.disableElement({
        element: "#g3w-view-content #contents",
        disable: disable
      });
    };

    GUI.disablePanel = function () {
      var disable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      GUI.disableElement({
        element: "#g3w-sidebarpanel-placeholder",
        disable: disable
      });
    };

    // hide content
    GUI.hideContent = function (bool, perc) {
      return viewport.ViewportService.hideContent(bool, perc);
    };

    GUI.closeContent = function () {
      this.emit('closecontent', false);
      return viewport.ViewportService.closeContent();
    };

    // show results info/search
    GUI.showQueryResults = function (title, results) {
      var perc = appLayoutConfig.rightpanel ? parseInt(appLayoutConfig.rightpanel.width) : 50;
      var queryResultsComponent = GUI.getComponent('queryresults');
      var queryResultService = queryResultsComponent.getService();
      queryResultService.reset();
      results && queryResultService.setQueryResponse(results);
      GUI.showContextualContent({
        perc: perc,
        content: queryResultsComponent,
        title: [t("info.title"), title].join(' ')
      });
      return queryResultService;
    };

    GUI.addNavbarItem = function (item) {
      navbaritems.NavbarItemsService.addItem(item);
    };

    GUI.removeNavBarItem = function () {};

    GUI.showPanel = sidebar.SidebarService.showPanel.bind(sidebar.SidebarService);
    GUI.closePanel = sidebar.SidebarService.closePanel.bind(sidebar.SidebarService);

    //showusermessage

    GUI.showUserMessage = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      viewport.ViewportService.showUserMessage(options);
    };

    GUI.closeUserMessage = function () {
      viewport.ViewportService.closeUserMessage();
    };

    /* ------------------ */

    GUI.notify = {
      warning: function warning(message) {
        GUI.showUserMessage({
          type: 'warning',
          message: message
        });
      },
      error: function error(message) {
        GUI.showUserMessage({
          type: 'alert',
          message: message
        });
      },
      info: function info(message) {
        GUI.showUserMessage({
          type: 'info',
          message: message
        });
      },
      success: function success(message) {
        GUI.showUserMessage({
          type: 'success',
          message: message,
          autoclose: true
        });
      }
    };
    // proxy  bootbox library
    GUI.dialog = bootbox;
    //modal dialog//
    GUI.showModalDialog = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return GUI.dialog.dialog(options);
    };
    /* spinner */
    GUI.showSpinner = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var container = options.container || 'body';
      var id = options.id || 'loadspinner';
      var where = options.where || 'prepend'; // append | prepend
      var style = options.style || '';
      var transparent = options.transparent ? 'background-color: transparent' : '';
      var center = options.center ? 'margin: auto' : '';
      if (!$("#" + id).length) {
        $(container)[where].call($(container), '<div id="' + id + '" class="spinner-wrapper ' + style + '" style="' + transparent + '"><div class="spinner ' + style + '" style="' + center + '"></div></div>');
      }
    };
    //hide spinner
    GUI.hideSpinner = function (id) {
      $("#" + id).remove();
    };
    /* end spinner*/
    /* end common methods */

    /*  */
    // FLOATBAR //
    GUI.showFloatbar = function () {
      floatbar.FloatbarService.open();
    };
    GUI.hideFloatbar = function () {
      floatbar.FloatbarService.close();
    };
    // SIDEBAR //
    GUI.showSidebar = this._showSidebar.bind(this);
    GUI.hideSidebar = this._hideSidebar.bind(this);

    // RELOAD COMPONENTS
    GUI.reloadComponents = function () {
      ApplicationTemplate.Services.sidebar.reloadComponents();
    };
    // MODAL
    GUI.setModal = this._showModalOverlay.bind(this);
    GUI.showFullModal = function () {
      var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref7$element = _ref7.element,
          element = _ref7$element === undefined ? "#full-screen-modal" : _ref7$element,
          _ref7$show = _ref7.show,
          show = _ref7$show === undefined ? true : _ref7$show;

      show && $(element).modal('show') || $(element).modal('hide');
    };

    // VIEWPORT //
    GUI.setPrimaryView = function (viewName) {
      viewport.ViewportService.setPrimaryView(viewName);
    };
    // only map
    GUI.showMap = function () {
      viewport.ViewportService.showMap();
    };

    GUI.showContextualMap = function (perc, split) {
      perc = perc || 30;
      viewport.ViewportService.showContextualMap({
        perc: perc,
        split: split
      });
    };
    GUI.setContextualMapComponent = function (mapComponent) {
      viewport.ViewportService.setContextualMapComponent(mapComponent);
    };
    GUI.resetContextualMapComponent = function () {
      viewport.ViewportService.resetContextualMapComponent();
    };
    //  (100%) content
    GUI.showContent = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.perc = !_this2._isMobile ? options.perc || 100 : 100;
      GUI.setContent(options);
    };

    GUI.showContextualContent = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.perc = !_this2._isMobile ? options.perc || 50 : 100;
      GUI.setContent(options);
    };
    // add component to stack (append)
    // Differeces between pushContent and setContent are :
    //  - push every componet is added, set is refreshed
    //  - pushContent has a new parameter (backonclose) when is cliccked x
    //  - the contentComponet is close all stack is closed
    GUI.pushContent = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      options.perc = !_this2._isMobile ? options.perc || 100 : 100;
      options.push = true;
      GUI.setContent(options);
    };
    // add content to stack
    GUI.pushContextualContent = function (options) {
      options = options || {};
      options.perc = !_this2._isMobile ? options.perc || 50 : 100;
      options.push = true;
      GUI.setContent(options);
    };
    // remove last content from stack
    GUI.popContent = function () {
      viewport.ViewportService.popContent();
    };
    //return number of component of stack
    GUI.getContentLength = function () {
      return viewport.ViewportService.contentLength();
    };

    GUI.isContentCollapsed = function () {
      return viewport.ViewportService.getContentState().collapsed;
    };

    GUI.collapseContent = function () {
      viewport.ViewportService.collapseContent();
    };

    GUI.getProjectMenuDOM = function () {
      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          projects = _ref8.projects,
          host = _ref8.host,
          cbk = _ref8.cbk;

      var options = {
        projects: projects && Array.isArray(projects) && projects,
        cbk: cbk,
        host: host
      };
      var projectVueMenuComponent = new ProjectsMenuComponent(options).getInternalComponent();
      return projectVueMenuComponent.$mount().$el;
    };

    GUI._setContent = function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      GUI.closeUserMessage();
      options.content = options.content || null;
      options.title = options.title || "";
      options.push = _.isBoolean(options.push) ? options.push : false;
      options.perc = !_this2._isMobile ? options.perc || 50 : 100;
      options.split = options.split || 'h';
      options.backonclose = _.isBoolean(options.backonclose) ? options.backonclose : false;
      options.showtitle = _.isBoolean(options.showtitle) ? options.showtitle : true;
      viewport.ViewportService.showContent(options);
    };

    GUI.hideClientMenu = function () {
      ApplicationService.getConfig().user = null;
    };

    GUI.hideChangeMaps = function () {
      ApplicationService.getConfig().projects = [];
    };

    // return specific classes
    GUI.getTemplateClasses = function () {
      return BootstrapVersionClasses;
    };

    GUI.getTemplateClass = function (_ref9) {
      var element = _ref9.element,
          type = _ref9.type;

      return BootstrapVersionClasses[element][type];
    };

    GUI.setLoadingContent = function () {
      var loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      ApplicationTemplate.Services.viewport.setLoadingContent(loading);
    };

    GUI.openProjectsMenu = function () {
      var contentsComponent = GUI.getComponent('contents');
      // check if is projectmenucomponent
      if (contentsComponent.getComponentById('projectsmenu')) {
        GUI.closeContent();
      } else {
        if (this.isMobile()) {
          GUI.hideSidebar();
          $('#main-navbar.navbar-collapse').removeClass('in');
        }
        GUI.setContent({
          content: new ProjectsMenuComponent(),
          title: '',
          perc: 100
        });
      }
    };

    /* END VIEWPORT */
    /*  */
    /* END PUBLIC INTERFACE */
  };
  base(this);
};

inherit(ApplicationTemplate, G3WObject);

// Placeholder knowed by application
ApplicationTemplate.PLACEHOLDERS = ['navbar', 'sidebar', 'viewport', 'floatbar'];

// service know by the applications (standard)
ApplicationTemplate.Services = {
  navbar: null,
  sidebar: sidebar.SidebarService,
  viewport: viewport.ViewportService,
  floatbar: sidebar.FloatbarService
};

ApplicationTemplate.fail = function (_ref10) {
  var _ref10$language = _ref10.language,
      language = _ref10$language === undefined ? 'en' : _ref10$language,
      error = _ref10.error;

  layout.loading(false);
  var error_page = {
    it: {
      error: error || "Errore di connessione",
      at_moment: "Al momento non  possibile caricare la mappa",
      f5: "Premi Ctrl+F5"
    },
    en: {
      error: error || "Connection error",
      at_moment: "At the moment is not possible show map",
      f5: "Press Ctrl+F5"
    }
  };
  var compiledTemplate = Vue.compile(require('../html/500.html'));
  var app = new Vue((0, _extends3.default)({
    el: '#app'
  }, compiledTemplate, {
    data: {
      messages: error_page[language]
    }
  }));
};

module.exports = ApplicationTemplate;

},{"../html/500.html":532,"./applicationui":543,"./contentsviewer":545,"./floatbar":546,"./layout":548,"./navbaritems":550,"./projectsmenu":551,"./sidebar":552,"./viewport":554,"./vuetemplateplugin":555,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"sdk":820,"sdk/core/g3wobject":569,"sdk/core/i18n/i18n.service":572,"sdk/core/utils/utils":630,"sdk/gui/catalog/vue/catalog":681,"sdk/gui/componentsregistry":691,"sdk/gui/gui":710,"sdk/gui/map/vue/map":759,"sdk/gui/metadata/vue/metadata":769,"sdk/gui/print/vue/print":774,"sdk/gui/queryresults/vue/queryresults":779,"sdk/gui/search/vue/search":791,"sdk/gui/tools/vue/tools":805}],554:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _usermessage = require('../components/vue/usermessage.vue');

var _usermessage2 = _interopRequireDefault(_usermessage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('sdk').core.utils.inherit;
var t = require('sdk').core.i18n.t;
var base = require('sdk').core.utils.base;
var G3WObject = require('sdk').core.G3WObject;
var GUI = require('sdk').gui.GUI;

// calsse servizio della viewport
var ViewportService = function ViewportService() {
  // state of viewport
  this.state = {
    primaryView: 'map', // primary view (default)
    // percentage of secondary view
    secondaryPerc: 0,
    // splitting orientation (h = horizontal, v = vertical)
    split: 'h',
    //map
    map: {
      sizes: {
        width: 0,
        height: 0
      },
      aside: false
    },
    //content
    content: {
      loading: false,
      sizes: {
        width: 0,
        height: 0
      },
      collapsed: false,
      aside: true,
      showgoback: true,
      stack: [], // array elements of  stack contents
      closable: true, // (x) is closable
      backonclose: false, // back on prevoius content
      contentsdata: [] // content data array
    },
    usermessage: {
      show: false,
      title: null,
      message: null,
      position: null,
      type: null,
      draggable: null,
      cloasable: null,
      autoclose: null,
      hooks: {
        header: null,
        body: null,
        footer: null
      }
    }
  };
  // content of viewport (map and content)
  this._components = {
    map: null,
    content: null
  };
  // default contents
  this._defaultMapComponent;
  this._contextualMapComponent;

  // minimun height and width of secondary view
  this._secondaryViewMinWidth = 300;
  this._secondaryViewMinHeight = 200;
  // attributo che serve per
  this._immediateComponentsLayout = true;
  /* PLUBILC INTARFACE */
  this.init = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    // check if it set primary view (map is default)
    this.state.primaryView = options.primaryview ? options.primaryview : 'map';
    // check splitting property
    this.state.split = options.split ? options.split : 'h';
    // add component (map and content)
    this._addComponents(options.components);
  };

  this.showUserMessage = function () {
    var _this = this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        title = _ref.title,
        message = _ref.message,
        type = _ref.type,
        position = _ref.position,
        size = _ref.size,
        draggable = _ref.draggable,
        closable = _ref.closable,
        autoclose = _ref.autoclose,
        _ref$hooks = _ref.hooks,
        hooks = _ref$hooks === undefined ? {} : _ref$hooks;

    this.closeUserMessage();
    requestAnimationFrame(function () {
      _this.state.usermessage.show = true;
      _this.state.usermessage.message = message;
      _this.state.usermessage.title = title;
      _this.state.usermessage.position = position;
      _this.state.usermessage.type = type;
      _this.state.usermessage.show = true;
      _this.state.usermessage.size = size;
      _this.state.usermessage.autoclose = autoclose;
      _this.state.usermessage.closable = closable;
      _this.state.usermessage.draggable = draggable;
      _this.state.usermessage.hooks.header = hooks.header;
      _this.state.usermessage.hooks.body = hooks.body;
      _this.state.usermessage.hooks.footer = hooks.footer;
    });
  };

  this.closeUserMessage = function () {
    this.state.usermessage.show = false;
  };

  this.getState = function () {
    return this.state;
  };

  this.getMapState = function () {
    return this.state.map;
  };

  this.getContentState = function () {
    return this.state.content;
  };

  this.setLoadingContent = function () {
    var loading = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.state.content.loading = loading;
  };

  this._addComponents = function (components) {
    var _this2 = this;

    // components is an object
    //(index.js)
    /*
     {
      map: new MapComponent({
        id: 'map'
      }),
      content: new ContentsComponent({
        id: 'contents'
      })
     }
     */
    (0, _entries2.default)(components).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
          viewName = _ref3[0],
          component = _ref3[1];

      // check if component are map or content
      if (['map', 'content'].indexOf(viewName) > -1) {
        component.mount('#g3w-view-' + viewName, true).then(function () {
          _this2._components[viewName] = component;
          // check if view name is map
          if (viewName === 'map') {
            // sset de fefault component to map
            _this2._defaultMapComponent = component;
          }
        }).fail(function (err) {
          console.log(err);
        });
      }
    });
  };

  this.showMap = function () {
    this._toggleMapComponentVisibility(this._defaultMapComponent, true);
    this._components['map'] = this._defaultMapComponent;
    this._showView('map');
  };

  this.showContextualMap = function (options) {
    var _this3 = this;

    if (!this._contextualMapComponent) {
      this._contextualMapComponent = this._defaultMapComponent;
    }
    if (this._contextualMapComponent != this._defaultMapComponent) {
      this._toggleMapComponentVisibility(this._defaultMapComponent, false);
    }
    if (!this._contextualMapComponent.ismount()) {
      var contextualMapComponent = this._contextualMapComponent;
      contextualMapComponent.mount('#g3w-view-map', true).then(function () {
        _this3._components['map'] = contextualMapComponent;
      });
    } else {
      this._components['map'] = this._contextualMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent, true);
    }
    this._showView('map', options);
  };

  // get default component
  this.recoverDefaultMap = function () {
    if (this._components['map'] !== this._defaultMapComponent) {
      this._components['map'] = this._defaultMapComponent;
      this._toggleMapComponentVisibility(this._contextualMapComponent, false);
      this._toggleMapComponentVisibility(this._defaultMapComponent, true);
    }
    return this._components['map'];
  };

  this.setContextualMapComponent = function (mapComponent) {
    if (mapComponent === this._defaultMapComponent) {
      return;
    }
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = mapComponent;
  };

  this.resetContextualMapComponent = function () {
    if (this._contextualMapComponent) {
      this._contextualMapComponent.unmount();
    }
    this._contextualMapComponent = this._defaultMapComponent;
  };

  this._toggleMapComponentVisibility = function (mapComponent, toggle) {
    mapComponent.internalComponent.$el.style.display = toggle ? 'block' : 'none';
  };

  // close map method
  this.closeMap = function () {
    this.state.secondaryPerc = this.state.primaryView === 'map' ? 100 : 0;
    this.recoverDefaultMap();
    this._layout();
  };

  // show content of the viewport content
  /*
   options: {
     content: (string, jQuery elemento or Vue component)
     title: Title of the content
     push: (opyionale, default false): if yes the content is push on top of the stack (contentStack)
     split: (optional, default 'h'): 'h' || 'v' splitting map and content orientation
     perc: (optional, default 50): percentage of content
   }
   */

  this.showContent = function () {
    var _this4 = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    // check if push i setted
    options.push = options.push || false;
    // set all pcontenty parameters
    this._prepareContentView(options);
    this._immediateComponentsLayout = false;
    this._showView('content', options);
    this._components.content.setContent(options).then(function () {
      _this4._immediateComponentsLayout = true;
      _this4._layoutComponents('show-content');
    });
  };

  // hide content
  this.hideContent = function (bool, perc) {
    var prevContentPerc = this.state.secondaryPerc;
    this.state.secondaryPerc = !!bool ? 0 : perc;
    this.state.secondaryVisible = !bool;
    this._layout('hide-content');
    // return previous percentage
    return prevContentPerc;
  };

  this.contentLength = function () {
    return this.state.content.contentsdata.length;
  };

  // pull the last element of contentStack
  this.popContent = function () {
    var _this5 = this;

    var d = $.Deferred();
    // check if content exist compontentStack
    if (this.state.content.contentsdata.length) {
      this.recoverDefaultMap();
      var data = this._components.content.getPreviousContentData();
      this._prepareContentView(data.options);
      this._immediateComponentsLayout = false;
      this._showView('content', data.options);
      this._components.content.popContent().then(function () {
        _this5.state.secondaryPerc = data.options.perc;
        _this5._immediateComponentsLayout = true;
        _this5._layout('pop-content');
        d.resolve(_this5._components.contentgetCurrentContentData);
      });
    } else d.reject();
    return d.promise();
  };

  this.isContentOpen = function () {
    return !!this.state.content.contentsdata.length;
  };

  // close  content
  this.closeContent = function () {
    var _this6 = this;

    var d = $.Deferred();
    if (this.isContentOpen()) {
      this._components.content.removeContent();
      // close secondari view( return a promise)
      this.closeSecondaryView('close-content').then(function () {
        //recover default map
        var mapComponent = _this6.recoverDefaultMap();
        d.resolve(mapComponent);
      });
    } else {
      var mapComponent = this.recoverDefaultMap();
      d.resolve(mapComponent);
    }
    return d.promise();
  };

  this.collapseContent = function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref4$perc = _ref4.perc,
        perc = _ref4$perc === undefined ? 50 : _ref4$perc;

    var options = this.state.content.collapsed ? { split: 'h', perc: 100 } : { split: 'v', perc: perc };
    var contentData = this.state.content.contentsdata[0];
    contentData.options.split = options.split;
    contentData.options.perc = options.perc;
    this._showView('content', options);
    this.state.content.collapsed = !this.state.content.collapsed;
  };

  this.removeContent = function () {
    // check if backonclose proprerty is  true o false
    // to remove all content stack or just last component
    if (this.state.content.backonclose && this.state.content.contentsdata.length > 1) this.popContent();else return this.closeContent();
  };

  this.isPrimaryView = function (viewName) {
    return this.state.primaryView == viewName;
  };

  this.setPrimaryView = function (viewTag) {
    if (this.state.primaryView !== viewTag) this.state.primaryView = viewTag;
    this._layout();
  };

  this.showPrimaryView = function () {
    var perc = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    if (perc && this.state.secondaryVisible && this.state.secondaryPerc === 100) {
      this.state.secondaryPerc = 100 - perc;
      this._layout();
    }
  };

  this.showSecondaryView = function (split, perc) {
    this.state.secondaryVisible = true;
    this.state.split = split ? split : this.state.split;
    this.state.secondaryPerc = perc ? perc : this.state.perc;
    this._layout();
  };

  // close secondary view
  this.closeSecondaryView = function () {
    var _this7 = this;

    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var d = $.Deferred();
    var secondaryViewComponent = this._components[this._otherView(this.state.primaryView)];
    if (secondaryViewComponent.clearContents) {
      secondaryViewComponent.clearContents().then(function () {
        _this7.state.secondaryVisible = false;
        _this7._layout(event);
        Vue.nextTick(function () {
          d.resolve();
        });
      });
    } else {
      this.state.secondaryVisible = false;
      this._layout(event);
      Vue.nextTick(function () {
        d.resolve();
      });
    }
    return d.promise();
  };

  this.getDefaultViewPerc = function (viewName) {
    return this.isPrimaryView(viewName) ? 100 : 50;
  };

  // return the opposite view
  this._otherView = function (viewName) {
    return viewName === 'map' ? 'content' : 'map';
  };

  this._isSecondary = function (view) {
    return this.state.primaryView !== view;
  };

  this._setPrimaryView = function (viewTag) {
    if (this.state.primaryView !== viewTag) {
      this.state.primaryView = viewTag;
    }
  };

  this._prepareContentView = function (options) {
    this.state.content.preferredPerc = options.perc || this.getDefaultViewPerc('content');
    this.state.content.title = options.title;
    this.state.content.split = options.split ? options.split : null;
    this.state.content.closable = _.isNil(options.closable) ? true : options.closable;
    this.state.content.backonclose = _.isNil(options.backonclose) ? true : options.backonclose;
    this.state.content.contentsdata = this._components.content.contentsdata;
    this.state.content.showgoback = _.isNil(options.showgoback) ? true : options.showgoback;
  };

  // manage all layout logic
  // viewName: map or content
  //options.  percentage , splitting title etc ..
  this._showView = function (viewName) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var perc = options.perc || this.getDefaultViewPerc(viewName);
    var split = options.split || 'h';
    var aside = void 0;
    if (this.isPrimaryView(viewName)) {
      aside = typeof options.aside == 'undefined' ? false : options.aside;
    } else {
      aside = true;
    }
    this.state[viewName].aside = aside;
    var secondaryPerc = this.isPrimaryView(viewName) ? 100 - perc : perc;
    if (secondaryPerc > 0) {
      this.showSecondaryView(split, secondaryPerc);
    } else {
      return this.closeSecondaryView();
    }
  };

  this._getReducedSizes = function () {
    var contentEl = $('.content');
    var reducedWidth = 0;
    var reducedHeight = 0;
    if (contentEl && this.state.secondaryVisible && this.state.secondaryPerc === 100) {
      var sideBarToggleEl = $('.sidebar-aside-toggle');
      if (sideBarToggleEl && sideBarToggleEl.is(':visible')) {
        var toggleWidth = sideBarToggleEl.outerWidth();
        contentEl.css('padding-left', toggleWidth + 5);
        reducedWidth = toggleWidth - 5;
      }
    } else contentEl.css('padding-left', 15);
    return {
      reducedWidth: reducedWidth,
      reducedHeight: reducedHeight
    };
  };

  //main layout function
  this._layout = function () {
    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    var splitClassToAdd = this.state.split === 'h' ? 'split-h' : 'split-v';
    var splitClassToRemove = this.state.split === 'h' ? 'split-v' : 'split-c';
    var viewportViewElement = $(".g3w-viewport .g3w-view");
    viewportViewElement.addClass(splitClassToAdd).removeClass(splitClassToRemove);
    var reducesdSizes = this._getReducedSizes();
    this._setViewSizes(reducesdSizes.reducedWidth, reducesdSizes.reducedHeight);
    if (this._immediateComponentsLayout) this._layoutComponents(event);
  };

  this._setViewSizes = function () {
    var primaryView = this.state.primaryView;
    var secondaryView = this._otherView(primaryView);
    var viewportWidth = Math.round(this._viewportWidth()) - 0.5; // remove  for zoom in zoom out issue
    //all viewport height
    var viewportHeight = this._viewportHeight();
    // assign all width and height of the view to primary view (map)
    var primaryWidth = viewportWidth;
    var primaryHeight = viewportHeight;
    var secondaryWidth = void 0;
    var secondaryHeight = void 0;
    // percentage of secondary view (content)
    var scale = this.state.secondaryPerc / 100;
    if (this.state.split === 'h') {
      secondaryWidth = this.state.secondaryVisible ? Math.max(viewportWidth * scale, this._secondaryViewMinWidth) : 0;
      secondaryHeight = viewportHeight;
      primaryWidth = viewportWidth - secondaryWidth;
      primaryHeight = viewportHeight;
    } else {
      secondaryWidth = viewportWidth;
      secondaryHeight = this.state.secondaryVisible ? Math.max(viewportHeight * scale, this._secondaryViewMinHeight) : 0;
      primaryWidth = viewportWidth;
      primaryHeight = viewportHeight - secondaryHeight;
    }
    this.state[primaryView].sizes.width = primaryWidth + 0.1;
    this.state[primaryView].sizes.height = primaryHeight;
    this.state[secondaryView].sizes.width = secondaryWidth;
    this.state[secondaryView].sizes.height = secondaryHeight;
  };

  this._viewportHeight = function () {
    var topHeight = $(".navbar").innerHeight();
    return $(window).innerHeight() - topHeight;
  };

  this._viewportWidth = function () {
    var main_sidebar = $(".main-sidebar");
    var offset = main_sidebar.length && main_sidebar.offset().left;
    var width = main_sidebar.length && main_sidebar.innerWidth();
    var sideBarSpace = width + offset;
    return $(window).innerWidth() - sideBarSpace;
  };

  // load components of  viewport
  // after right size setting
  this._layoutComponents = function () {
    var _this8 = this;

    var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

    requestAnimationFrame(function () {
      var reducesdSizes = _this8._getReducedSizes();
      var reducedWidth = reducesdSizes.reducedWidth || 0;
      var reducedHeight = reducesdSizes.reducedHeight || 0;
      // for each components
      (0, _entries2.default)(_this8._components).forEach(function (_ref5) {
        var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
            name = _ref6[0],
            component = _ref6[1];

        var width = _this8.state[name].sizes.width - reducedWidth;
        var height = _this8.state[name].sizes.height - reducedHeight;
        component.layout(width, height);
      });
      if (event) setTimeout(function () {
        _this8.emit(event);
      }, 0);
    });
  };

  this._firstLayout = function () {
    var _this9 = this;

    var drawing = false;
    var resizeFired = false;

    function triggerResize() {
      resizeFired = true;
      drawResize();
    }

    var drawResize = function drawResize() {
      if (resizeFired === true) {
        resizeFired = false;
        drawing = true;
        _this9._layout('resize');
        requestAnimationFrame(drawResize);
      } else {
        drawing = false;
      }
    };
    // GUI ready event
    GUI.on('ready', function () {
      var primaryView = _this9.state.primaryView;
      var secondaryView = _this9._otherView(primaryView);
      var secondaryEl = $(".g3w-viewport ." + secondaryView);
      var secondaryViewMinWidth = secondaryEl.css('min-width');
      if (secondaryViewMinWidth != "" && !_.isNaN(parseFloat(secondaryViewMinWidth))) {
        _this9._secondaryViewMinWidth = parseFloat(secondaryViewMinWidth);
      }
      var secondaryViewMinHeight = secondaryEl.css('min-height');
      if (secondaryViewMinHeight != "" && !_.isNaN(parseFloat(secondaryViewMinHeight))) {
        _this9._secondaryViewMinHeight = parseFloat(secondaryViewMinHeight);
      }
      _this9._layout();
      GUI.on('guiresized', function () {
        triggerResize();
      });
      // resize della window
      $(window).resize(function () {
        // set resizedFired to true and execute drawResize if it's not already running
        if (drawing === false) {
          triggerResize();
        }
      });
      // resize on main siedemar open close sidebar
      $('.main-sidebar').on('webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd', function (event) {
        //be sure that is the main sidebar that is transitioned non his child
        if (event.target === this) {
          $(this).trigger('trans-end');
          triggerResize();
        }
      });
    });
  };
  this._firstLayout();
  base(this);
};

inherit(ViewportService, G3WObject);

//singleton
var viewportService = new ViewportService();
var compiledTemplate = Vue.compile(require('../html/viewport.html'));

// COMPONENTE VUE VIEWPORT
var ViewportComponent = Vue.extend((0, _extends3.default)({
  components: {
    userMessage: _usermessage2.default
  }
}, compiledTemplate, {
  data: function data() {
    return {
      state: viewportService.state,
      media: {
        matches: true
      }
    };
  },
  computed: {
    hooks: function hooks() {
      return this.usermessage.hooks;
    },
    usermessage: function usermessage() {
      return this.state.usermessage;
    },

    showtitle: function showtitle() {
      var showtitle = true;
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        var options = contentsData[contentsData.length - 1].options;
        if (_.isBoolean(options.showtitle)) showtitle = options.showtitle;
      }
      return showtitle;
    },
    showContent: function showContent() {
      return this.state.content.show;
    },
    collapsedContent: function collapsedContent() {
      return this.state.content.collapsed;
    },
    showCollapseButton: function showCollapseButton() {
      return this.isMobile() && this.state.content.contentsdata.length === 1 && this.media.matches;
    },

    contentTitle: function contentTitle() {
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length) {
        return contentsData[contentsData.length - 1].options.title;
      }
    },
    previousTitle: function previousTitle() {
      var contentsData = this.state.content.contentsdata;
      if (contentsData.length > 1 && this.state.content.showgoback) {
        if (!contentsData[contentsData.length - 2].options.title) {
          return t('back');
        }
        return ' ' + t('backto') + ' ' + contentsData[contentsData.length - 2].options.title;
      }
      return false;
    },
    contentSmallerThenPreferred: function contentSmallerThenPreferred() {
      return this.state.secondaryPerc < this.state.content.preferredPerc;
    }
  },
  watch: {
    'state.content.contentsdata': function stateContentContentsdata(newContentDataArray, oldContentDataArray) {
      if (this.isMobile() && !oldContentDataArray.length) this.state.content.collapsed = false;
    },
    'media.matches': function mediaMatches(newMatches, oldMatches) {
      if (this.state.content.contentsdata.length === 1 && oldMatches != newMatches) {
        this.state.content.collapsed = true;
        viewportService.collapseContent();
      }
    }
  },
  methods: {
    closeContent: function closeContent() {
      GUI.closeContent();
    },
    collapseContent: function collapseContent() {
      viewportService.collapseContent();
    },
    closeMap: function closeMap() {
      viewportService.closeMap();
    },
    gotoPreviousContent: function gotoPreviousContent() {
      viewportService.popContent();
    },
    closeUserMessage: function closeUserMessage() {
      viewportService.closeUserMessage();
    }
  },
  mounted: function mounted() {
    var _this10 = this;

    this.$nextTick(function () {
      var mediaQueryEventMobile = window.matchMedia("(min-height: 300px)");
      _this10.media.matches = mediaQueryEventMobile.matches;
      mediaQueryEventMobile.addListener(function (event) {
        if (event.type === 'change') {
          _this10.media.matches = event.currentTarget.matches;
        }
      });
    });
  }
}));

module.exports = {
  ViewportService: viewportService,
  ViewportComponent: ViewportComponent
};

},{"../components/vue/usermessage.vue":528,"../html/viewport.html":542,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"sdk":820}],555:[function(require,module,exports){
var Fonts = require('../config/frameworks/fonts');
var VueTemplatePlugin = {
  install: function install(Vue) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$font = _ref.font,
        font = _ref$font === undefined ? { name: 'fontawsome', version: '4' } : _ref$font;

    // set g3wtemplate property to all instances
    Vue.prototype.g3wtemplate = {
      font: Fonts[font.name].versions[font.version],
      get: function get() {},
      getInfo: function getInfo() {
        return {
          font: this.font
        };
      },
      getInfoString: function getInfoString() {},
      getFontClass: function getFontClass(type) {
        return this.font[type];
      }
    };
    // set isMobile method to all Vue instances
    Vue.mixin({
      methods: {
        isMobile: function (_isMobile) {
          function isMobile() {
            return _isMobile.apply(this, arguments);
          }

          isMobile.toString = function () {
            return _isMobile.toString();
          };

          return isMobile;
        }(function () {
          return isMobile.any;
        })
      }
    });
  }
};

module.exports = VueTemplatePlugin;

},{"../config/frameworks/fonts":529}],556:[function(require,module,exports){
var ProjectsRegistry = require('core/project/projectsregistry');
var ApplicationService = require('core/applicationservice');
var GUI = require('gui/gui');

// Handle ApplicationService on ready event
ApplicationService.once('ready', function () {});

// Handle project configuration to insert custom element on project
ProjectsRegistry.oncebefore('setCurrentProject', function (project) {});

//Ready GUI
GUI.once('ready', function () {});

},{"core/applicationservice":560,"core/project/projectsregistry":624,"gui/gui":710}],557:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  "it": {
    "sdk": {
      search: {
        all: 'TUTTE',
        layer_not_searchable: "Il layer non  ricercabile"
      },
      print: {
        no_layers: 'Nessun Layer visibile',
        scale: "Scala",
        format: "Formato",
        rotation: "Rotazione"
      },
      errors: {
        layers: {
          load: "Alcuni layers presenti nel progetto non sono attualmente disponibili e quindi non compaiono nell'attuale visualizzazione"
        }
      },
      metadata: {
        "title": "Metadati",
        'groups': {
          'general': {
            'title': 'GENERALE',
            'fields': {
              'title': 'TITOLO',
              'name': 'NOME',
              'description': "DESCRIZIONE",
              'abstract': "ABSTRACT",
              'keywords': 'LISTA DELLE PAROLE CHIAVE',
              "fees": "CANONI",
              "accessconstraints": "VINCOLI DI ACCESSO",
              'contactinformation': "CONTATTI",
              'subfields': {
                'contactinformation': {
                  'contactelectronicmailaddress': "E-mail",
                  'personprimary': 'Riferimenti',
                  'contactvoicetelephone': 'Telefono',
                  'contactorganization': 'Organizzazione',
                  'contactposition': 'Posizione',
                  'contactperson': 'Persona'
                }
              },
              'wms_url': "WMS"
            }
          },
          'spatial': {
            'title': 'INFO SPAZIALI',
            'fields': {
              'crs': 'EPSG',
              'extent': 'BBOX'
            }
          },
          'layers': {
            'title': 'STRATI',
            'groups': {
              'general': 'GENERALE',
              'spatial': 'INFO SPAZIALI'
            },
            'fields': {
              'layers': 'STRATI',
              'subfields': {
                'crs': 'EPSG',
                'bbox': 'BBOX',
                'title': "TITOLO",
                'name': 'NOME',
                'geometrytype': 'GEOMETRIA',
                'source': 'SORGENTE',
                'attributes': 'ATTRIBUTI',
                'abstract': 'ABSTRACT',
                'attribution': 'ATTRIBUTION',
                'keywords': "PAROLE CHIAVE",
                'metadataurl': 'METADATA URL',
                'dataurl': "DATA URL"
              }
            }
          }
        }
      },
      mapcontrols: {
        query: {
          actions: {
            show_map: {
              hint: "Visualizza sulla mappa"
            }
          }
        },
        querybypolygon: {
          help: "<h4>Guida - Query By Polygon</h4>\n                  <ul style=\"padding-left: 10px;\">\n                    <li style=\"font-size:0.8em;\">Seleziona uno strato poligonale in legenda.</li>\n                    <li style=\"font-size:0.8em;\">Assicurati che lo strato sia visibile in mappa.</li>\n                    <li style=\"font-size:0.8em;\">Clicca su una geometria dello strato selezionato.</li>\n                  </ul>"
        },
        querybybbox: {
          help: "<h4>Guida - Query BBox layer</h4>\n                   <ul style=\"padding-left: 10px;\">\n                    <li style=\"font-size:0.8em;\">Disegna un rettangolo per interrogare gli strati evidenziati in giallo</li>\n                   </ul>"
        },
        measures: {
          length: {
            tooltip: "Lunghezza",
            help: "Clicca sulla mappa per continuare a disegnare la linea.<br>CANC se si vuole cancellare l\'ultimo vertice inserito"
          },
          area: {
            tooltip: "Area",
            help: "Click per continuare a disegnare il poligono.<br>CANC se si vuole cancellare l'ultimo vertice inserito"
          }
        }
      },
      relations: {
        relation_data: 'Dati Relazione',
        no_relations_found: 'Nessuna relazione trovata',
        back_to_relations: 'Ritorna alle relazioni',
        list_of_relations_feature: 'Lista delle relazioni della feature',
        error_missing_father_field: "Il campo relazionato non esiste"
      },
      workflow: {
        steps: {
          title: 'Passi'
        }
      },
      form: {
        loading: 'Caricamento ...',
        inputs: {
          input_validation_mutually_exclusive: "Campo mutualmente esclusivo con ",
          input_validation_error: "Campo obbligatorio o tipo valore non corretto",
          input_validation_min_field: "Valore deve essere magiore uguale a quello del camp ",
          input_validation_max_field: "Valore deve essere minore uguale a quello del campo ",
          input_validation_exclude_values: "Campo deve contenere un valore diverso",
          integer: "intero",
          text: "testuale",
          textarea: "testuale",
          string: "stringa",
          date: "data",
          float: "float",
          table: "table"
        },
        footer: {
          required_fields: "Campi richiesti"
        },
        messages: {
          qgis_input_widget_relation: "Gestisci le relazioni tramite form dedicato"
        }
      },
      catalog: {
        menu: {
          wms: {
            title: "",
            copy: "Clicca qui per copiare url",
            copied: "Copiato"
          }
        }
      },
      wps: {
        list_process: "Lista dei processi",
        tooltip: 'Clicca sulla mappa'
      }
    }
  },
  "en": {
    "sdk": {
      search: {
        all: 'ALL',
        layer_not_searchable: "Layer not searchable"
      },
      print: {
        no_layers: 'No Layer to print',
        scale: "Scale",
        format: "Format",
        rotation: "Rotation"
      },
      errors: {
        layers: {
          load: "Some layers are not available"
        }
      },
      metadata: {
        'title': 'Metadata',
        'groups': {
          'general': {
            'title': 'GENERAL',
            'fields': {
              'title': 'TITLE',
              'name': 'NAME',
              'description': "DESCRIPTION",
              'abstract': "ABASTRACT",
              'keywords': 'KEYWORDS',
              "fees": "FEES",
              "accessconstraints": "ACCESS CONSTRAINT",
              'contactinformation': "CONTACTS",
              'subfields': {
                'contactinformation': {
                  'contactelectronicmailaddress': "Email",
                  'personprimary': 'Refereces',
                  'contactvoicetelephone': 'Phone',
                  'contactorganization': 'Organization',
                  'contactposition': 'Position',
                  'contactperson': 'Person'
                }
              },
              'wms_url': "WMS"
            }
          },
          'spatial': {
            'title': 'SPATIAL',
            'fields': {
              'crs': 'EPSG',
              'extent': 'BBOX'
            }
          },
          'layers': {
            'title': 'LAYERS',
            'fields': {
              'layers': 'LAYERS',
              'subfields': {
                'crs': 'EPSG',
                'bbox': 'BBOX',
                'title': "TITLE",
                'name': 'NAME',
                'geometrytype': 'GEOMETRY',
                'source': 'SOURCE',
                'attributes': 'ATTRIBUTES',
                'abstract': 'ABSTRACT',
                'attribution': 'ATTRIBUTION',
                'keywords': "PAROLE CHIAVE",
                'metadataurl': 'METADATA URL',
                'dataurl': "DATA URL"
              }
            },
            'groups': {
              'general': 'GENERAL',
              'spatial': 'SPATIAL'
            }
          }
        }
      },
      mapcontrols: {
        query: {
          actions: {
            show_map: {
              hint: "Show on map"
            }
          }
        },
        querybypolygon: {
          help: "<h4>Guide - Query By Polygon</h4>\n                  <ul style=\"padding-left: 10px;\">\n                    <li style=\"font-size:0.8em;\">Select a polygon layer on TOC.</li>\n                    <li style=\"font-size:0.8em;\">Be sure that layer is visible.</li>\n                    <li style=\"font-size:0.8em;\">Click on a feature of selected layer.</li>\n                  </ul>"
        },
        querybybbox: {
          help: "<h4>Guide - Query BBox layer</h4>\n                   <ul style=\"padding-left: 10px;\">\n                    <li style=\"font-size:0.8em;\">Draw a square on map to query underlined layers on TOC</li>\n                   </ul>"
        },
        measures: {
          length: {
            tooltip: "Length",
            help: "Click on map to draw the line. Press <br>CANC if you want delete last vertex"
          },
          area: {
            tooltip: "Area",
            help: "Click to draw poligon.Press <br>CANC if you want delete last vertex"
          }
        }
      },
      relations: {
        relation_data: 'Relation data',
        no_relations_found: 'No relations found',
        back_to_relations: 'Back to relations',
        list_of_relations_feature: 'List of relations of feature',
        error_missing_father_field: "Field is missing"
      },
      workflow: {
        steps: {
          title: 'Steps'
        }
      },
      form: {
        loading: 'Loading ...',
        inputs: {
          input_validation_mutually_exclusive: "Field mutually exclusive with ",
          input_validation_error: "Mandatory Field or wrong data type",
          input_validation_min_field: "Value has to be more/equal to field value  ",
          input_validation_max_field: "Value has to be less/equal to field value ",
          input_validation_exclude_values: "Value has to be unique",
          integer: "integer",
          text: "text",
          textarea: "text",
          string: "string",
          date: "date",
          float: "float",
          table: "table"
        },
        footer: {
          "required_fields": "Required fields"
        },
        messages: {
          qgis_input_widget_relation: "Use relation specific form to work with relation"
        }
      },
      catalog: {
        menu: {
          wms: {
            titel: "",
            copy: "Click here to copy url",
            copied: "Copied"
          }
        }
      },
      wps: {
        list_process: "List of process",
        tooltip: 'Click on map'
      }
    }
  }
};

},{}],558:[function(require,module,exports){
arguments[4][531][0].apply(exports,arguments)
},{"./i18n":557,"dup":531}],559:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var reject = require('core/utils/utils').reject;

// Class Api Service
function ApiService() {
  this._config = null;
  this._baseUrl = null;
  this.init = function (config) {
    var d = $.Deferred();
    this._config = config;
    // prende l'url base delle api dal config dell'applicazione
    this._baseUrl = config.urls.api;
    this._apiEndpoints = config.urls.apiEndpoints;
    d.resolve();
    return d.promise();
  };
  var howManyAreLoading = 0;
  this._incrementLoaders = function () {
    if (howManyAreLoading == 0) {
      this.emit('apiquerystart');
    }
    howManyAreLoading += 1;
  };

  this._decrementLoaders = function () {
    howManyAreLoading -= 1;
    if (howManyAreLoading == 0) {
      this.emit('apiqueryend');
    }
  };
  this.get = function (api, options) {
    var _this = this;

    var apiEndPoint = this._apiEndpoints[api];
    if (apiEndPoint) {
      var completeUrl = this._baseUrl + '/' + apiEndPoint;
      if (options.request) {
        completeUrl = completeUrl + '/' + options.request;
      }
      var params = options.params || {};

      this.emit(api + 'querystart');
      this._incrementLoaders();
      return $.get(completeUrl, params).done(function (response) {
        _this.emit(api + 'queryend', response);
        return response;
      }).fail(function (e) {
        _this.emit(api + 'queryfail', e);
        return e;
      }).always(function () {
        _this._decrementLoaders();
      });
    } else {
      return reject();
    }
  };
  base(this);
}

inherit(ApiService, G3WObject);

module.exports = new ApiService();

},{"core/g3wobject":569,"core/utils/utils":630}],560:[function(require,module,exports){
var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var XHR = require('core/utils/utils').XHR;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ApiService = require('core/apiservice');
var RouterService = require('core/router');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('core/plugin/pluginsregistry');
var ClipboardService = require('core/clipboardservice');
var GlobalComponents = require('gui/vue/vue.globalcomponents');
var GlobalDirective = require('gui/vue/vue.directives');
var GUI = require('gui/gui');
var G3W_VERSION = "{G3W_VERSION}";
// install global components
Vue.use(GlobalComponents);
// install gloabl directive
Vue.use(GlobalDirective);

//Manage Application
var ApplicationService = function ApplicationService() {
  var production = false;
  this.version = G3W_VERSION.indexOf("G3W_VERSION") === -1 ? G3W_VERSION : "";
  this.ready = false;
  this.iframe = window.top !== window.self;
  this.complete = false;
  // store all services sidebar etc..
  this._applicationServices = {};
  this.config = {};
  this._initConfigUrl = null;
  this._initConfig = {};
  this._groupId = null;
  this._gid = null;
  this.setters = {
    changeProject: function changeProject() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          gid = _ref.gid,
          host = _ref.host;

      return this._changeProject({ gid: gid, host: host });
    }
  };
  base(this);
  // init from server
  this.init = function () {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._config = config;
    this._groupId = this._config.group.name.replace(/\s+/g, '-').toLowerCase();
    // run bbotstrap
    return this._bootstrap();
  };

  //check if is in Iframe
  this.isIframe = function () {
    return this.iframe;
  };

  // get config
  this.getConfig = function () {
    return this._config;
  };

  // router service
  this.getRouterService = function () {
    return RouterService;
  };

  // clipboard service
  this.getClipboardService = function () {
    return ClipboardService;
  };

  this.obtainInitConfig = function () {
    var _this = this;

    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        initConfigUrl = _ref2.initConfigUrl,
        url = _ref2.url,
        host = _ref2.host;

    var d = $.Deferred();
    if (!this._initConfigUrl) this._initConfigUrl = initConfigUrl;else this.clearInitConfig();
    // if exist a global initiConfig (in production)
    if (window.initConfig) {
      production = true;
      this._initConfig = window.initConfig;
      return d.resolve(window.initConfig);
      // case development need to ask to api
    } else {
      var projectPath = void 0;
      var queryTuples = void 0;
      var locationsearch = url ? url.split('?')[1] : location.search ? location.search.substring(1) : null;
      if (locationsearch) {
        queryTuples = locationsearch.split('&');
        queryTuples.forEach(function (queryTuple) {
          //check if exist project in url
          if (queryTuple.indexOf("project") > -1) {
            projectPath = queryTuple.split("=")[1];
          }
        });
      } else {
        var type_id = this._gid.split(':').join('/');
        projectPath = this._groupId + '/' + type_id;
      }
      if (projectPath) {
        var initUrl = (host || '') + '/' + this._initConfigUrl + '/' + projectPath;
        // get configuration from server (return a promise)
        XHR.get({
          url: initUrl
        }).then(function (initConfig) {
          //initConfig conatin mai configuration
          //group, mediaurl, staticurl, user
          initConfig.staticurl = "../dist/"; // in development force  asset
          initConfig.clienturl = "../dist/"; // in development force  asset
          _this._initConfig = initConfig;
          // set initConfig
          window.initConfig = initConfig;
          d.resolve(initConfig);
        }).catch(function (error) {
          d.reject(error);
        });
      }
    }
    return d.promise();
  };

  this.getInitConfig = function () {
    return this._initConfig;
  };

  this.getInitConfigUrl = function () {
    return this._initConfigUrl;
  };

  this.setInitConfigUrl = function (initConfigUrl) {
    this._initConfigUrl = initConfigUrl;
  };

  // post boostratp
  this.postBootstrap = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (this.complete) {
              _context.next = 13;
              break;
            }

            _context.prev = 1;

            RouterService.init();
            // once the projects are inizilized and also api service
            // register  plugins
            _context.next = 5;
            return this._bootstrapPlugins();

          case 5:
            _context.next = 9;
            break;

          case 7:
            _context.prev = 7;
            _context.t0 = _context['catch'](1);

          case 9:
            _context.prev = 9;

            this.complete = true;
            this.emit('complete');
            return _context.finish(9);

          case 13:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this, [[1, 7, 9, 13]]);
  }));

  //boostrap plugins
  this._bootstrapPlugins = function () {
    return PluginsRegistry.init({
      pluginsBaseUrl: this._config.urls.staticurl,
      pluginsConfigs: this._config.plugins,
      otherPluginsConfig: ProjectsRegistry.getCurrentProject().getState()
    });
  };

  //  bootstrap (when called init)
  this._bootstrap = function () {
    var _this2 = this;

    var d = $.Deferred();
    //first time l'application service is not ready
    if (!this.ready) {
      // LOAD DEVELOPMENT CONFIGURATION
      if (!production) require('../config/dev/index');
      $.when(
      // register project
      ProjectsRegistry.init(this._config),
      // inizialize api service
      ApiService.init(this._config)).then(function () {
        _this2.emit('ready');
        _this2.ready = _this2.initialized = true;
        d.resolve();
      }).fail(function (error) {
        d.reject(error);
      });
    }
    return d.promise();
  };

  this.registerWindowEvent = function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        evt = _ref4.evt,
        cb = _ref4.cb;

    window.addEventListener(evt, cb);
  };

  this.unregisterWindowEvent = function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        evt = _ref5.evt,
        cb = _ref5.cb;

    window.removeEventListener(evt, cb);
  };

  this.registerService = function (element, service) {
    this._applicationServices[element] = service;
  };

  this.unregisterService = function (element) {
    delete this._applicationServices[element];
  };

  this.getService = function (element) {
    return this._applicationServices[element];
  };

  this.errorHandler = function (error) {
    console.log(error);
  };

  this.clearInitConfig = function () {
    window.initConfig = null;
  };

  this._changeProject = function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        gid = _ref6.gid,
        host = _ref6.host;

    var d = $.Deferred();
    this._gid = gid;
    var aliasUrl = ProjectsRegistry.getProjectAliasUrl(gid);
    var mapUrl = ProjectsRegistry.getProjectUrl(gid);
    // change url using history
    production && aliasUrl && history.replaceState(null, null, aliasUrl) || history.replaceState(null, null, mapUrl);
    //remove tools
    this.obtainInitConfig({
      host: host
    }).then(function (initConfig) {
      ProjectsRegistry.getProject(gid).then(function (project) {
        GUI.closeUserMessage();
        GUI.closeContent().then(function () {
          // change current project project
          ProjectsRegistry.setCurrentProject(project);
          // remove all toos
          GUI.getComponent('tools').getService().reload();
          // reload metadati
          GUI.getComponent('metadata').getService().reload();
          // reload plugins
          PluginsRegistry.reloadPlugins(initConfig, project).then(function () {}).catch(function () {}).finally(function () {
            // reload components
            GUI.reloadComponents();
            d.resolve(project);
          });
        }).fail(function (err) {
          console.log(err);
        });
      }).fail(function () {
        d.reject();
      });
    }).fail(function (err) {
      //TODO
    });
    return d.promise();
  };
};

inherit(ApplicationService, G3WObject);

module.exports = new ApplicationService();

},{"../config/dev/index":556,"babel-runtime/helpers/asyncToGenerator":20,"babel-runtime/regenerator":26,"core/apiservice":559,"core/clipboardservice":562,"core/g3wobject":569,"core/plugin/pluginsregistry":618,"core/project/projectsregistry":624,"core/router":628,"core/utils/utils":630,"gui/gui":710,"gui/vue/vue.directives":813,"gui/vue/vue.globalcomponents":814}],561:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function CatalogLayersStoresRegistry() {
  base(this);
}

inherit(CatalogLayersStoresRegistry, LayersStoresRegistry);

module.exports = new CatalogLayersStoresRegistry();

},{"core/layers/layersstoresregistry":591,"core/utils//utils":630,"core/utils/utils":630}],562:[function(require,module,exports){
function ClipboardService() {
  this._data = {};
  this.set = function (formId, data) {
    var formLayer = formId.split('form')[0];
    this._data[formLayer] = data;
  };

  this.get = function (formLayer) {
    var data = this._data[formLayer] || {};
    this._data[formLayer] = {};
    return data;
  };
}
module.exports = new ClipboardService();

},{}],563:[function(require,module,exports){
//lass that is usefult to apply changes to features (undo/redo) singleton
function ChangesManager() {
  this.execute = function (object, items, reverse) {
    var fnc = void 0;
    var feature = void 0;
    items.forEach(function (item) {
      feature = item.feature;
      if (reverse) {
        // change to opposite
        feature[ChangesManager.Actions[feature.getState()].opposite]();
      }
      // get method from object
      fnc = ChangesManager.Actions[feature.getState()].fnc;
      object[fnc](feature);
    });
  };
}

// know actions
ChangesManager.Actions = {
  'add': {
    fnc: 'addFeature',
    opposite: 'delete'
  },
  'delete': {
    fnc: 'removeFeature',
    opposite: 'add'
  },
  'update': {
    fnc: 'updateFeature',
    opposite: 'update'
  }
};

module.exports = new ChangesManager();

},{}],564:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// class Editor bind editor to layer to do main actions
function Editor() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.setters = {
    save: function save() {
      this._save();
    },
    addFeature: function addFeature(feature) {
      this._addFeature(feature);
    },
    updateFeature: function updateFeature(feature) {
      this._updateFeature(feature);
    },
    deleteFeature: function deleteFeature(feature) {
      this._deleteFeature(feature);
    },
    setFeatures: function setFeatures(features) {
      this._setFeatures(features);
    },
    getFeatures: function getFeatures(options) {
      return this._getFeatures(options);
    }
  };
  base(this);
  // referred layer
  this._layer = options.layer;
  // editor is active or not
  this._started = false;
}

inherit(Editor, G3WObject);

var proto = Editor.prototype;

proto.getLayer = function () {
  return this._layer;
};

proto.setLayer = function (layer) {
  this._layer = layer;
  return this._layer;
};

// fget features methods
proto._getFeatures = function (options) {
  var d = $.Deferred();
  this._layer.getFeatures(options).then(function (promise) {
    promise.then(function (features) {
      return d.resolve(features);
    }).fail(function (err) {
      return d.reject(err);
    });
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

// run after server apply chaged to origin resource
proto.commit = function (commitItems, featurestore) {
  var d = $.Deferred();
  this._layer.commit(commitItems, featurestore).then(function (promise) {
    promise.then(function (response) {
      // update features after new insert
      return d.resolve(response);
    }).fail(function (err) {
      return d.reject(err);
    });
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

//start editing function
proto.start = function (options) {
  var _this = this;

  var d = $.Deferred();
  // load features of layer based on filter type
  this.getFeatures(options).then(function (promise) {
    promise.then(function (features) {
      // the features are already inside featuresstore
      d.resolve(features);
      //if all ok set to started
      _this._started = true;
    }).fail(function (err) {
      d.reject(err);
    });
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

//action to layer

proto._addFeature = function (feature) {
  this._layer.addFeature(feature);
};

proto._deleteFeature = function (feature) {
  this._layer.deleteFeature(feature);
};

proto._updateFeature = function (feature) {
  this._layer.updateFeature(feature);
};

proto._setFeatures = function (features) {
  this._layer.setFeatures(features);
};

// stop editor
proto.stop = function () {
  var _this2 = this;

  var d = $.Deferred();
  this._layer.unlock().then(function (response) {
    _this2._started = false;
    _this2.clear();
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

//run save layer
proto._save = function () {
  this._layer.save();
};

proto.isStarted = function () {
  return this._started;
};

proto.clear = function () {
  this._layer.getFeaturesStore().clear();
};

module.exports = Editor;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],565:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function History() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.id = options.id;
  base(this);
  // registered all changes
  /*
  *{
  * _states: [
  *     {
  *       id: unique key
  *       state: [state] // example: history contsins features state
  *                      // array because a tool can apply changes to more than one features at time (split di una feature)
  *     },
  *     {
  *       id: unique key
  *       state: [state]
  *     },
  *   ]
  *     ....
  *
  *  _current: unique key // usefult to undo redo
  *
  *
  * */
  // set maximun "buffer history" lenght for  undo redo
  this._maxSteps = 10;
  this._states = [];
  // reactive state of histrory
  this.state = {
    commit: false,
    undo: false,
    redo: false
  };
  this._current = null; // store the current state of history (useful for undo /redo)
}

inherit(History, G3WObject);

var proto = History.prototype;

proto.add = function (uniqueId, items) {
  var _this = this;

  //state object is an array of feature/features changed in a transaction
  var d = $.Deferred();
  // before insert an item into the history
  // check if are at last state step (no redo was done)
  // in this way avoid starge barch in the history
  //If we are in the middle of undo, delete all changes in the histroy from the current "state"
  // so i can create a new history
  if (this._states.length && this._current !== this.getLastState().id) {
    this._states.find(function (state, idx) {
      if (_this._current === state.id) {
        //substitute new state
        _this._states = _this._states.slice(0, idx + 1);
        return true;
      }
    });
  }

  this._states.push({
    id: uniqueId,
    items: items
  });
  this._current = uniqueId;
  this._setState();
  // return unique id key
  // it can be used in save relation
  d.resolve(uniqueId);
  return d.promise();
};

proto.getRelationStates = function (layerId) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$clear = _ref.clear,
      clear = _ref$clear === undefined ? false : _ref$clear;

  var relationStates = [];
  for (var _i = 0; _i < this._states.length; _i++) {
    var state = this._states[_i];
    var relationItems = state.items.filter(function (item) {
      var _layerId = Array.isArray(item) ? item[0].layerId : item.layerId;
      return _layerId === layerId;
    });
    relationItems.length && relationStates.push({
      id: state.id,
      items: relationItems
    });
  }
  return relationStates;
};

proto.insertState = function (state) {
  var stateId = state.id;
  var index = this._states.length;
  for (var _i2 = 0; _i2 < this._states.length; _i2++) {
    var _state = this._states[_i2];
    if (_state.id > stateId) {
      index = _i2;
      break;
    } else if (_state.id === stateId) index = -1;
    break;
  }
  if (index > -1) {
    if (this._current < stateId) this._current = stateId;
    this._states.splice(index, 0, state);
  }
};

proto.removeState = function (stateId) {
  var index = void 0;
  for (i = 0; i < this._states.length; i++) {
    var state = this._states[i];
    if (state.id === stateId) {
      index = i;
      break;
    }
  }
  if (this._current === stateId) this._current = this._states.length > 1 ? this._states[index - 1].id : null;
  this._states.splice(index, 1);
};

proto.removeStates = function () {
  var stateIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  for (var _i3 = 0; _i3 < stateIds.length; _i3++) {
    var stateId = stateIds[_i3];
    this.removeState(stateId);
  }
};

proto.insertStates = function () {
  var states = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  for (var _i4 = 0; _i4 < states.length; _i4++) {
    this.insertState(states[_i4]);
  }
  this.canCommit();
};

// internal method to change the state of the  history when we check
// a call to a function that modify the hsitory state
proto._setState = function () {
  this.canUndo();
  this.canCommit();
  this.canRedo();
};

//check if was did an update (update are array contains two items , old e new value)
proto._checkItems = function (items, action) {
  var _this2 = this;

  /**
   * action: <reffererd to array index>
   *  0: undo;
   *  1: redo;
   **/
  var newItems = {
    own: [], //array of changes of layer of the current session
    dependencies: {} // dependencies
  };
  items.forEach(function (item) {
    if (Array.isArray(item)) item = item[action];
    // check if belong to session
    if (_this2.id === item.layerId) {
      newItems.own.push(item);
    } else {
      if (!newItems.dependencies[item.layerId]) newItems.dependencies[item.layerId] = {
        own: [],
        dependencies: {}
      };
      newItems.dependencies[item.layerId].own.push(item);
    }
  });
  return newItems;
};

// method undo
proto.undo = function () {
  var _this3 = this;

  var items = void 0;
  if (this._current === this.getFirstState().id) {
    this._current = null;
    items = this._states[0].items;
  } else {
    this._states.find(function (state, idx) {
      if (state.id === _this3._current) {
        items = _this3._states[idx].items;
        _this3._current = _this3._states[idx - 1].id;
        return true;
      }
    });
  }
  items = this._checkItems(items, 0);
  this._setState();
  return items;
};

//method redo
proto.redo = function () {
  var _this4 = this;

  var items = void 0;
  // if not set get first state
  if (!this._current) {
    items = this._states[0].items;
    // set current to first
    this._current = this._states[0].id;
  } else {
    this._states.find(function (state, idx) {
      if (_this4._current === state.id) {
        _this4._current = _this4._states[idx + 1].id;
        items = _this4._states[idx + 1].items;
        return true;
      }
    });
  }
  items = this._checkItems(items, 1);
  this._setState();
  return items;
};

// ripulisce tutta la storia se non  stato specificato nessun ids
// ids: array di id
proto.clear = function (ids) {
  var _this5 = this;

  if (ids) this._states.forEach(function (state, idx) {
    if (ids.indexOf(state.id) !== -1) {
      if (_this5._current && _this5._current == state.id())
        //faccio un undo
        _this5.undo();
      _this5._states.splice(idx, 1);
    }
  });else this._clearAll();
};

// funzione che pulisce tutto states
proto._clearAll = function () {
  this._states = [];
  this._current = null;
  this.state.commit = false;
  this.state.redo = false;
  this.state.undo = false;
};

// ritorna lo stato a seconda dell'id
proto.getState = function (id) {
  var state = null;
  this._states.forEach(function (state) {
    if (state.id === id) {
      state = state;
      return false;
    }
  });
  return state;
};

proto.getFirstState = function () {
  return this._states.length ? this._states[0] : null;
};

//restituisce l'ultimo state registrato (che non  detto sia quello corrente)
proto.getLastState = function () {
  var length = this._states.length;
  return length ? this._states[length - 1] : null;
};

// funzione che mi permette di ricavare stato corrente del layer
// attualmente nella storia
proto.getCurrentState = function () {
  var _this6 = this;

  var currentState = null;
  if (this._current && this._states.length) {
    this._states.forEach(function (state) {
      if (_this6._current == state.id) {
        currentState = state;
        return false;
      }
    });
  }
  return currentState;
};

// funzione che mi permette di ricavarel'indice dello stato corrente
proto.getCurrentStateIndex = function () {
  var _this7 = this;

  var currentStateIndex = null;
  if (this._current && this._states.length) {
    this._states.forEach(function (state, idx) {
      if (_this7._current == state.id) {
        currentStateIndex = idx;
        return false;
      }
    });
  }
  return currentStateIndex;
};

// funzione che mi dice se ci sono cose da committare
proto.canCommit = function () {
  var checkCommitItems = this.commit();
  var canCommit = false;
  for (var layerId in checkCommitItems) {
    var commitItem = checkCommitItems[layerId];
    canCommit = canCommit || !!commitItem.length;
  }
  this.state.commit = canCommit;
  return this.state.commit;
};

//funzione che mi dice se posso fare l'undo sulla history
proto.canUndo = function () {
  var steps = this._states.length - 1 - this.getCurrentStateIndex();
  this.state.undo = !_.isNull(this._current) && this._maxSteps > steps;
  return this.state.undo;
};

// funzione che mi dice se posso fare il redo sulla history
proto.canRedo = function () {
  this.state.redo = this.getLastState() && this.getLastState().id != this._current || _.isNull(this._current) && this._states.length > 0;
  return this.state.redo;
};

proto._getStatesToCommit = function () {
  var _this8 = this;

  return this._states.filter(function (state) {
    return state.id <= _this8._current;
  });
};

//get all changes to send to server (mandare al server)
proto.commit = function () {
  var commitItems = {};
  var statesToCommit = this._getStatesToCommit();
  statesToCommit.forEach(function (state) {
    state.items.forEach(function (item) {
      var add = true;
      if (Array.isArray(item)) item = item[1];
      commitItems[item.layerId] && commitItems[item.layerId].forEach(function (commitItem, index) {
        // check if already inserted feature
        if (commitItem.getUid() === item.feature.getUid()) {
          if (item.feature.isNew() && !commitItem.isDeleted() && item.feature.isUpdated()) {
            var _item = item.feature.clone();
            _item.add();
            commitItems[item.layerId][index] = _item;
          } else if (item.feature.isNew() && item.feature.isDeleted()) {
            commitItems[item.layerId].splice(index, 1);
          } else if (item.feature.isUpdated() || item.feature.isDeleted()) commitItems[item.layerId][index] = item.feature;
          add = false;
          return false;
        }
      });
      if (add) {
        var feature = item.feature;
        var layerId = item.layerId;
        if (!(!feature.isNew() && feature.isAdded())) {
          if (!commitItems[layerId]) commitItems[layerId] = [];
          commitItems[layerId].push(feature);
        }
      }
    });
  });
  return commitItems;
};

module.exports = History;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],566:[function(require,module,exports){
var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var History = require('./history');
var FeaturesStore = require('core/layers/features/featuresstore');
var ChangesManager = require('./changesmanager');
var SessionsRegistry = require('./sessionsregistry');

function Session() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.setters = {
    start: function start() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._start(options);
    },
    getFeatures: function getFeatures() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._getFeatures(options);
    },
    stop: function stop() {
      this._stop();
    }
  };
  base(this, options);

  this.state = {
    id: options.id, // id session is the same of id layer
    started: false
  };
  // editor
  this._editor = options.editor || null;
  // featuresstore it's a temprary features source of the layer
  this._featuresstore = options.featuresstore || new FeaturesStore({
    provider: this._editor && this._editor.getLayer() && this._editor.getLayer().getProvider('data')
  });
  // history -- oggetto che contiene gli stati dei layers
  this._history = new History({
    id: this.state.id
  });
  // this is usefult in case of using a features store of editing layer
  this._add = options.add === undefined ? true : options.add;
  ///tempraray changes before save iit on history object
  this._temporarychanges = [];
}

inherit(Session, G3WObject);

var proto = Session.prototype;

proto.getId = function () {
  return this.state.id;
};

proto.getLastStateId = function () {
  return this._history.getLastState().id;
};

proto.deleteState = function (stateId) {
  this._history.removeState(stateId);
};

proto.register = function () {
  SessionsRegistry.register(this);
};

proto.unregister = function () {
  SessionsRegistry.unregister(this.getId());
};

proto._start = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  this.register();
  this._editor.start(options).then(function (features) {
    if (_this._add) {
      // return feature from server - clone it
      features = _this._cloneFeatures(features);
      // set clone feature to internal features store
      _this._featuresstore.setFeatures(features);
    }
    _this.state.started = true;
    d.resolve(features);
  }).fail(function (err) {
    _this.state.started = true;
    d.reject(err);
  });
  return d.promise();
};

//method to getFeature from server by editor
proto._getFeatures = function () {
  var _this2 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  this._editor.getFeatures(options).then(function (promise) {
    promise.then(function (features) {
      if (_this2._add) {
        features = _this2._cloneFeatures(features);
        _this2._featuresstore.addFeatures(features);
      }
      d.resolve(features);
    }).fail(function (err) {
      d.reject(err);
    });
  });
  return d.promise();
};

//clone features method
proto._cloneFeatures = function (features) {
  return features.map(function (feature) {
    return feature.clone();
  });
};

proto.isStarted = function () {
  return this.state.started;
};

proto.getEditor = function () {
  return this._editor;
};

proto.setEditor = function (editor) {
  this._editor = editor;
};

proto.getFeaturesStore = function () {
  return this._featuresstore;
};

// it used to save temporary changes to the layer
// in history instance and feature store
proto.save = function () {
  var _this3 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  //fill history
  //console.log("Session Saving .... ");
  var d = $.Deferred();
  // add temporary modify to history
  if (this._temporarychanges.length) {
    var uniqueId = options.id || Date.now();
    this._history.add(uniqueId, this._temporarychanges).then(function () {
      // clear to temporary changes
      _this3._temporarychanges = [];
      // resolve if uniqeu id
      d.resolve(uniqueId);
    });
  } else {
    d.resolve(null);
  }
  return d.promise();
};

proto.updateTemporaryChanges = function (feature) {
  this._temporarychanges.forEach(function (change) {
    change.feature.setProperties(feature.getProperties());
  });
};

// method to add temporary feature
proto.pushAdd = function (layerId, feature) {
  var newFeature = feature.clone();
  this.push({
    layerId: layerId,
    feature: newFeature.add()
  });
  return newFeature;
};

// delete temporary feature
proto.pushDelete = function (layerId, feature) {
  this.push({
    layerId: layerId,
    feature: feature.delete()
  });
  return feature;
};

// add temporary feature changes
proto.pushUpdate = function (layerId, newFeature, oldFeature) {
  // in case of change attribute immediately after create feature
  if (newFeature.isNew()) {
    var temporarynewfeatureIndex = this._temporarychanges.findIndex(function (change) {
      return change.layerId === layerId && change.feature.getId() === newFeature.getId();
    });
    if (temporarynewfeatureIndex !== -1) {
      var feature = newFeature.clone();
      feature.add();
      this._temporarychanges[temporarynewfeatureIndex].feature = feature;
      return;
    }
  }
  this.push({
    layerId: layerId,
    feature: newFeature.update()
  }, {
    layerId: layerId,
    feature: oldFeature.update()
  });
};

proto.removeChangesFromHistory = function () {
  var changeIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  this._history.removeStates(changeIds);
};

proto.moveRelationStatesOwnSession = function () {
  var statesIds = {};

  var _getCommitItems = this.getCommitItems(),
      relationItems = _getCommitItems.relations;

  for (var relationLayerId in relationItems) {
    var relationStates = this._history.getRelationStates(relationLayerId);
    var relationSession = SessionsRegistry.getSession(relationLayerId);
    relationSession._history.insertStates(relationStates);
    statesIds[relationLayerId] = relationStates.map(function (state) {
      return state.id;
    });
  }
  return statesIds;
};

// it used to add temporary features
// that will be added with save method
proto.push = function (New, Old) {
  /*
  New e Old saranno oggetti contenti {
      layerId: xxxx,
      feature: feature
    }
   */
  // check is set old (edit)
  var feature = Old ? [Old, New] : New;
  this._temporarychanges.push(feature);
};

proto._applyChanges = function (items) {
  var reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  ChangesManager.execute(this._featuresstore, items, reverse);
};

// method to revert (cancel) all changes in history and clen session
proto.revert = function () {
  var _this4 = this;

  var d = $.Deferred();
  this._editor.getFeatures().then(function (promise) {
    promise.then(function (features) {
      features = _this4._cloneFeatures(features);
      _this4.getFeaturesStore().setFeatures(features);
      _this4._history.clear();
      d.resolve();
    }).fail(function (err) {
      d.reject(err);
    });
  });
  return d.promise();
};

// handle temporary changes of layer
proto._filterChanges = function () {
  var id = this.getId();
  var changes = {
    own: [],
    dependencies: {}
  };
  this._temporarychanges.forEach(function (temporarychange) {
    var change = Array.isArray(temporarychange) ? temporarychange[0] : temporarychange;
    if (change.layerId === id) changes.own.push(change);else {
      if (!changes.dependencies[change.layerId]) changes.dependencies[change.layerId] = [];
      // FILO
      changes.dependencies[change.layerId].unshift(change);
    }
  });
  return changes;
};

proto.rollback = function (changes) {
  var d = $.Deferred();
  if (changes) {
    this._applyChanges(changes, true);
    d.resolve();
  } else {
    changes = this._filterChanges();
    // apply changes to featurestore (rollback temporary changes)
    this._applyChanges(changes.own, true);
    this._temporarychanges = [];
    d.resolve(changes.dependencies);
  }
  return d.promise();
};

// method undo
proto.undo = function (items) {
  items = items || this._history.undo();
  this._applyChanges(items.own, true);
  this._history.canCommit();
  return items.dependencies;
};

// method redo
proto.redo = function (items) {
  items = items || this._history.redo();
  this._applyChanges(items.own, true);
  this._history.canCommit();
  return items.dependencies;
};

proto._serializeCommit = function (itemsToCommit) {
  var id = this.getId();
  var state = void 0;
  var layer = void 0;
  var commitObj = {
    add: [],
    update: [],
    delete: [],
    relations: {}
  };
  for (var key in itemsToCommit) {
    var isRelation = false;
    var items = itemsToCommit[key];
    if (key !== id) {
      isRelation = true;
      var lockids = SessionsRegistry.getSession(key) ? SessionsRegistry.getSession(key).getEditor().getLayer().getFeaturesStore().getLockIds() : [];
      commitObj.relations[key] = {
        lockids: lockids,
        add: [],
        update: [],
        delete: []
      };
      layer = commitObj.relations[key];
    } else {
      layer = commitObj;
    }
    items.forEach(function (item) {
      state = item.getState();
      var GeoJSONFormat = new ol.format.GeoJSON();
      switch (state) {
        case 'delete':
          if (!item.isNew()) layer.delete.push(item.getId());
          break;
        default:
          var value = GeoJSONFormat.writeFeatureObject(item);
          var childs_properties = item.getProperties();
          for (var _key in value.properties) {
            if (value.properties[_key] && (0, _typeof3.default)(value.properties[_key]) === 'object' && value.properties[_key].constructor === Object) value.properties[_key] = value.properties[_key].value;
            if (value.properties[_key] === undefined && childs_properties[_key]) value.properties[_key] = childs_properties[_key];
          }
          var action = item.isNew() ? 'add' : item.getState();
          layer[action].push(value);
          break;
      }
    });
    // check in case of no edit remove relation key
    if (isRelation && !layer.add.length && !layer.update.length && !layer.delete.length) {
      delete commitObj.relations[key];
    }
  }
  return commitObj;
};

proto.getCommitItems = function () {
  var commitItems = this._history.commit();
  return this._serializeCommit(commitItems);
};

proto.commit = function () {
  var _this5 = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$ids = _ref.ids,
      ids = _ref$ids === undefined ? null : _ref$ids,
      _ref$relations = _ref.relations,
      relations = _ref$relations === undefined ? true : _ref$relations;

  var d = $.Deferred();
  var commitItems = void 0;
  if (ids) {
    commitItems = this._history.commit(ids);
    this._history.clear(ids);
  } else {
    commitItems = this._history.commit();
    commitItems = this._serializeCommit(commitItems);
    if (!relations) commitItems.relations = {};
    this._editor.commit(commitItems, this._featuresstore).then(function (response) {
      if (response && response.result)
        // if the response of server is correct clear history
        _this5._featuresstore.readFeatures().forEach(function (feature) {
          feature.clearState();
        });
      _this5._history.clear();
      d.resolve(commitItems, response);
    }).fail(function (err) {
      d.reject(err);
    });
  }
  return d.promise();
};

//stop session
proto._stop = function () {
  var d = $.Deferred();
  // unregister a session
  this.unregister();
  //console.log('Sessione stopping ..');
  this._editor.stop().then(function () {
    d.resolve();
  }).fail(function (err) {
    d.reject(err);
  });
  this.clear();
  return d.promise();
};

// clear all things bind to session
proto.clear = function () {
  this.state.started = false;
  // clar related history
  this._clearHistory();
  // clear a learestor
  this._featuresstore.clear();
};

//return l'history
proto.getHistory = function () {
  return this._history;
};

// clear history
proto._clearHistory = function () {
  this._history.clear();
};

module.exports = Session;

},{"./changesmanager":563,"./history":565,"./sessionsregistry":567,"babel-runtime/helpers/typeof":25,"core/g3wobject":569,"core/layers/features/featuresstore":581,"core/utils//utils":630,"core/utils/utils":630}],567:[function(require,module,exports){
var SessionsRegistry = function SessionsRegistry() {
  this._sessions = {};

  this.register = function (session) {
    var id = session.getId();
    this._sessions[id] = session;
  };

  this.unregister = function (id) {
    delete this._sessions[id];
  };

  this.getSession = function (id) {
    return this._sessions[id];
  };

  this.setSession = function (id, session) {
    this._sessions[id] = session;
  };

  this.getSessions = function () {
    return this._sessions;
  };
};

module.exports = new SessionsRegistry();

},{}],568:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;

var serverErrorParser = function serverErrorParser(options) {
  this._error = options.error;
};

var proto = serverErrorParser.prototype;

proto.parse = function () {
  var error_message = null;
  function traverseErrorMessage(obj) {
    _.forIn(obj, function (val, key) {
      if (_.isArray(val)) {
        error_message = val[0];
      }
      if (_.isObject(val)) {
        traverseErrorMessage(obj[key]);
      }
      if (error_message) {
        return false;
      }
    });
  }
  var error_obj = this._error && this._error.responseJSON && this._error.responseJSON.error.data ? this._error.responseJSON.error.data : null;
  if (error_obj) {
    error_message = "";
    traverseErrorMessage(error_obj);
    error_message = "<h4>" + t("server_saver_error") + "</h4>" + "<h5>" + error_message + "</h5>";
  } else {
    error_message = t("server_saver_error");
  }
  return error_message;
};

module.exports = serverErrorParser;

},{"core/i18n/i18n.service":572}],569:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var noop = require('core/utils/utils').noop;
var debounce = require('core/utils/utils').debounce;
var throttle = require('core/utils/utils').throttle;

/**
 * Base object to handle a setter and its listeners.
 * @constructor
 */

var G3WObject = function G3WObject() {
  //check if setters property is set. Register the chain of events
  if (this.setters) {
    this._setupListenersChain(this.setters);
  }
  // check debounces
  if (this.debounces) {
    this._setupDebounces(this.debounces);
  }
  //check throttles
  if (this.throttles) {
    this._setupThrottles(this.throttles);
  }
};

inherit(G3WObject, EventEmitter);

var proto = G3WObject.prototype;

/**
 * Insert a listener on afeter setter was executed
 * @param {string} setter - IMethod name to register a listener function
 * @param {function} listener - listener function (only syncron)
 * @param {number} priority - Priorit di esecuzione: valore minore viene eseuito prima
 */
proto.onafter = function (setter, listener, priority) {
  return this._onsetter('after', setter, listener, false, priority);
};

proto.onceafter = function (setter, listener, priority) {
  return this._onsetter('after', setter, listener, false, priority, true);
};

/**
 * Listern before cal sesster
 * @param {string} setter - Method name setter
 * @param {function} listener - function to call
 * @param {number} priority - Priority
 */
proto.onbefore = function (setter, listener, priority) {
  return this._onsetter('before', setter, listener, false, priority);
};

// once before
proto.oncebefore = function (setter, listener, priority) {
  return this._onsetter('before', setter, listener, false, priority, true);
};

/**
 * @param {string} setter - Method name setter
 * @param {function} listener - function to call
 * @param {number} priority - Priority
 */
proto.onbeforeasync = function (setter, listener, priority) {
  return this._onsetter('before', setter, listener, true, priority);
};

proto.un = function (setter, key) {
  // cicle on after before (key) and for each settersListeners (array) find key
  (0, _entries2.default)(this.settersListeners).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        _key = _ref2[0],
        settersListeners = _ref2[1];

    settersListeners[setter].forEach(function (setterListener, idx) {
      if (setterListener.key === key) {
        settersListeners[setter].splice(idx, 1);
      }
    });
  });
};

// base function to handle onafter or before listeners
/*
  when=before|after,
  type=sync|async
*/
proto._onsetter = function (when, setter, listener, async) {
  var priority = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  var once = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;

  var settersListeners = this.settersListeners[when];
  var listenerKey = '' + (Math.floor(Math.random() * 1000000) + Date.now());
  var settersListeneres = settersListeners[setter];
  settersListeneres.push({
    key: listenerKey,
    fnc: listener,
    async: async,
    priority: priority,
    once: once
  });
  // reader array based on priority
  settersListeners[setter] = _.sortBy(settersListeneres, function (setterListener) {
    return setterListener.priority;
  });
  // return key
  return listenerKey;
};

proto._setupListenersChain = function (setters) {
  var _this = this;

  // initialize all methods inside object "setters" of child class.
  this.settersListeners = {
    after: {},
    before: {}
  };

  var _loop = function _loop(setter) {
    var setterOption = setters[setter];
    var setterFnc = noop;
    var setterFallback = noop;
    if (_.isFunction(setterOption)) setterFnc = setterOption;else {
      setterFnc = setterOption.fnc;
      setterFallback = setterOption.fallback || noop; // method called in case of error
    }
    // create array to push before and after subscribers
    _this.settersListeners.after[setter] = [];
    _this.settersListeners.before[setter] = [];
    // assign the property settern name to the object as own method
    _this[setter] = function () {
      var _this2 = this;

      for (var _len = arguments.length, args = Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var deferred = $.Deferred();
      var returnVal = null;
      var counter = 0;
      // function to call original function(setter function)
      var callSetter = function callSetter() {
        // run setter function
        returnVal = setterFnc.apply(_this2, args);
        // resolve promise
        deferred.resolve(returnVal);
        //call all subscribed methods afet setter
        var onceListenerKeys = [];
        var afterListeners = _this2.settersListeners.after[setter];
        afterListeners.forEach(function (listener) {
          listener.fnc.apply(_this2, args);
          listener.once && onceListenerKeys.push(listener.key);
        });
        onceListenerKeys.forEach(function (key) {
          return _this2.un(setter, key);
        });
      };
      //  abort function
      var abort = function abort() {
        setterFallback.apply(_this2, args);
        deferred.reject();
      };
      // get all before listeners functions of setter
      var beforeListeners = this.settersListeners['before'][setter];
      // listener counter
      counter = 0;
      var next = function next(bool) {
        // initilize cont to true (continue)
        var cont = true;
        // check if bool is Boolean
        if (_.isBoolean(bool)) {
          cont = bool;
        }
        // check if count is false or we are arrived to the end of onbefore subscriber
        if (cont === false) {
          // found an error so we can abort
          abort.apply(_this2, args);
        } else if (counter === beforeListeners.length) {
          // call complete method methods
          var completed = callSetter();
          //verifico che cosa ritorna
          if (completed === undefined || completed === true) {
            _this2.emitEvent('set:' + setter, args);
          }
        } else if (cont) {
          var listenerObj = beforeListeners[counter];
          var currentCounter = counter;
          // if is async functtion
          if (beforeListeners[counter].async) {
            //add function next to argument of listnerFunction
            args.push(next);
            // update counter
            counter += 1;
            listenerObj.fnc.apply(_this2, args);
          } else {
            // return or undefine or a boolen to tell if ok(true) can conitnue or not (false)
            var _bool = listenerObj.fnc.apply(_this2, args);
            //update counter
            counter += 1;
            next(_bool);
          }
          listenerObj.once && beforeListeners.splice(currentCounter, 1);
        }
      };
      // run next to start to run all the subscribers and setrer its self
      next();
      // retun a promise
      return deferred.promise();
    };
  };

  for (var setter in setters) {
    _loop(setter);
  }
  return this.settersListeners;
};

proto._setupDebounces = function (debounces) {
  for (var name in debounces) {
    var delay = debounces[name].delay;
    var fnc = debounces[name].fnc;
    this[name] = debounce(fnc, delay);
  }
};

proto._setupThrottles = function (throttles) {
  for (var name in throttles) {
    var delay = throttles[name].delay;
    var fnc = throttles[name].fnc;
    this[name] = throttle(fnc, delay);
  }
};

//method get
proto.get = function (key) {
  return this[key] && !(this[key] instanceof Function) ? this[key] : null;
};

//method set
proto.set = function (key, value) {
  this[key] = value;
};

module.exports = G3WObject;

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/utils/utils":630}],570:[function(require,module,exports){
var geom = {
  distance: function distance(c1, c2) {
    return Math.sqrt(geom.squaredDistance(c1, c2));
  },
  squaredDistance: function squaredDistance(c1, c2) {
    var x1 = c1[0];
    var y1 = c1[1];
    var x2 = c2[0];
    var y2 = c2[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    return dx * dx + dy * dy;
  },
  closestOnSegment: function closestOnSegment(coordinate, segment) {
    var x0 = coordinate[0];
    var y0 = coordinate[1];
    var start = segment[0];
    var end = segment[1];
    var x1 = start[0];
    var y1 = start[1];
    var x2 = end[0];
    var y2 = end[1];
    var dx = x2 - x1;
    var dy = y2 - y1;
    var along = dx === 0 && dy === 0 ? 0 : (dx * (x0 - x1) + dy * (y0 - y1)) / (dx * dx + dy * dy || 0);
    var x = void 0,
        y = void 0;
    if (along <= 0) {
      x = x1;
      y = y1;
    } else if (along >= 1) {
      x = x2;
      y = y2;
    } else {
      x = x1 + along * dx;
      y = y1 + along * dy;
    }
    return [x, y];
  }
};

module.exports = geom;

},{}],571:[function(require,module,exports){
var Geometry = {};

Geometry.GeometryTypes = {
  POINT: "Point",
  MULTIPOINT: "MultiPoint",
  LINESTRING: "LineString", // per seguire la definizione di QGis.GeometryType, che definisce Line invece di Linestring.
  LINE: "Line",
  MULTILINESTRING: "MultiLineString",
  MULTILINE: "MultiLine",
  POLYGON: "Polygon",
  MULTIPOLYGON: "MultiPolygon",
  GEOMETRYCOLLECTION: "GeometryCollection"
};

Geometry.SupportedGeometryTypes = [Geometry.GeometryTypes.POINT, Geometry.GeometryTypes.MULTIPOINT, Geometry.GeometryTypes.LINE, Geometry.GeometryTypes.LINESTRING, Geometry.GeometryTypes.MULTILINE, Geometry.GeometryTypes.LINESTRING, Geometry.GeometryTypes.POLYGON, Geometry.GeometryTypes.MULTIPOLYGON];

module.exports = Geometry;

},{}],572:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// main object content for i18n
var plugins18nConfig = {
  it: {
    plugins: {}
  },
  en: {
    plugins: {}
  }
};

function init(config) {
  i18next.use(i18nextXHRBackend).init({
    lng: config.lng,
    ns: 'app',
    fallbackLng: 'en',
    resources: config.resources
  });
  return new _promise2.default(function (resolve, reject) {
    jqueryI18next.init(i18next, $, {
      tName: 't', // --> appends $.t = i18next.t
      i18nName: 'i18n', // --> appends $.i18n = i18next
      handleName: 'localize', // --> appends $(selector).localize(opts);
      selectorAttr: 'data-i18n', // selector for translating elements
      targetAttr: 'data-i18n-target', // element attribute to grab target element to translate (if diffrent then itself)
      optionsAttr: 'data-i18n-options', // element attribute that contains options, will load/set if useOptionsAttr = true
      useOptionsAttr: false, // see optionsAttr
      parseDefaultValueFromContent: true // parses default values from content ele.val or ele.text
    });
    addI18n(plugins18nConfig);
    resolve();
  });
}
var getAppLanguage = function getAppLanguage() {
  var ApplicationService = require('core/applicationservice');
  var config = ApplicationService.getConfig();
  return config.user.i18n || "en";
};

// function to translate
var t = function t(text) {
  return i18next.t(text);
};

// function to translate plugins
var tPlugin = function tPlugin(text) {
  return i18next.t('plugins.' + text);
};

var tTemplate = function tTemplate(text) {
  return i18next.t('template.' + text);
};

var tPrefix = function tPrefix(filter) {
  return function (text) {
    return i18next.t(filter + '.' + text);
  };
};

var addI18nPlugin = function addI18nPlugin(_ref) {
  var name = _ref.name,
      config = _ref.config;

  for (var language in config) {
    plugins18nConfig[language].plugins[name] = config[language];
  }
  addI18n(plugins18nConfig);
};

var addI18n = function addI18n(i18nObject) {
  for (var lng in i18nObject) {
    var lngObj = i18nObject[lng];
    for (var key in lngObj) {
      i18next.addResource(lng, 'translation', key, lngObj[key]);
    }
  }
};

module.exports = {
  init: init,
  t: t,
  tPlugin: tPlugin,
  tTemplate: tTemplate,
  tPrefix: tPrefix,
  addI18n: addI18n,
  addI18nPlugin: addI18nPlugin,
  getAppLanguage: getAppLanguage
};

},{"babel-runtime/core-js/promise":16,"core/applicationservice":560}],573:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var BaseLayer = require('core/layers/baselayers/baselayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function ARCGISMAPSERVERLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = options;
  base(this, options);
}

inherit(ARCGISMAPSERVERLayer, BaseLayer);

var proto = ARCGISMAPSERVERLayer.prototype;

proto._makeOlLayer = function () {
  // here configuration to create TMS
  var _config = this.config,
      url = _config.url,
      attributions = _config.attributions,
      _config$crs = _config.crs,
      crs = _config$crs === undefined ? 3857 : _config$crs;

  var olLayer = BasesLayers.TMS.get({
    url: url,
    source_type: 'arcgismapserver',
    projection: 'EPSG:' + crs,
    attributions: attributions
  });
  return olLayer;
};

module.exports = ARCGISMAPSERVERLayer;

},{"core/layers/baselayers/baselayer":574,"core/utils/utils":630,"g3w-ol3/src/layers/bases":672}],574:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var WMSLayer = require('../map/wmslayer');
var ImageLayer = require('core/layers/imagelayer');

function BaseLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  if (this.isWMS()) {
    var config = {
      url: this.getWmsUrl(),
      id: this.state.id,
      tiled: this.state.tiled
    };
    this._mapLayer = new WMSLayer(config);
    this._mapLayer.addLayer(this);
  } else {
    this._mapLayer = this;
  }
}

inherit(BaseLayer, ImageLayer);

var proto = BaseLayer.prototype;

proto._makeOlLayer = function () {
  //TO OVERWRITE
};

proto._registerLoadingEvent = function () {
  var _this = this;

  this._olLayer.getSource().on('imageloadstart', function () {
    _this.emit("loadstart");
  });
  this._olLayer.getSource().on('imageloadend', function () {
    _this.emit("loadend");
  });
};

proto.getSource = function () {
  return this.getOLLayer().getSource();
};

proto.toggleLayer = function () {
  this._updateLayers();
};

proto.update = function (mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.getOLLayer = function () {
  var olLayer = this._olLayer;
  if (!olLayer) {
    olLayer = this._olLayer = this._makeOlLayer();
    this._registerLoadingEvent();
    if (this._mapLayer.config.attributions) {
      this._olLayer.getSource().setAttributions(this._mapLayer.config.attributions);
    }
    olLayer.setVisible(this._mapLayer.state.visible);
  }
  return olLayer;
};

proto._updateLayer = function (mapState, extraParams) {
  if (this.isWMS()) {
    this._mapLayer.update(mapState, extraParams);
  }
};

proto.setVisible = function (bool) {
  this.getOLLayer().setVisible(bool);
};

proto.getMapLayer = function () {
  return this._mapLayer;
};

module.exports = BaseLayer;

},{"../map/wmslayer":599,"core/layers/imagelayer":587,"core/utils/utils":630}],575:[function(require,module,exports){
var BaseLayers = {
  'OSM': require('./osmlayer'),
  'Bing': require('./binglayer'),
  'TMS': require('./tmslayer'),
  'ARCGISMAPSERVER': require('./arcgislayer'),
  'WMTS': require('./wmtslayer')
};

module.exports = BaseLayers;

},{"./arcgislayer":573,"./binglayer":576,"./osmlayer":577,"./tmslayer":578,"./wmtslayer":579}],576:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var BaseLayer = require('core/layers/baselayers/baselayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function BingLayer(options) {
  base(this, options);
}

inherit(BingLayer, BaseLayer);

var proto = BingLayer.prototype;

proto._makeOlLayer = function () {
  var olLayer = void 0;
  var subtype = this.config.source ? this.config.source.subtype : null;
  switch (subtype) {
    case 'streets':
      olLayer = BasesLayers.BING.Road;
      break;
    case 'aerial':
      olLayer = BasesLayers.BING.Aerial;
      break;
    case 'aerialwithlabels':
      olLayer = BasesLayers.BING.AerialWithLabels;
      break;
    default:
      olLayer = BasesLayers.BING.Aerial;
      break;
  }

  return olLayer;
};

module.exports = BingLayer;

},{"core/layers/baselayers/baselayer":574,"core/utils/utils":630,"g3w-ol3/src/layers/bases":672}],577:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var BaseLayer = require('core/layers/baselayers/baselayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function OSMLayer(options) {
  base(this, options);
}

inherit(OSMLayer, BaseLayer);

var proto = OSMLayer.prototype;

proto._makeOlLayer = function () {
  var olLayer = BasesLayers.OSM;
  return olLayer;
};

module.exports = OSMLayer;

},{"core/layers/baselayers/baselayer":574,"core/utils/utils":630,"g3w-ol3/src/layers/bases":672}],578:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var BaseLayer = require('core/layers/baselayers/baselayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function TMSLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = options;
  base(this, options);
}

inherit(TMSLayer, BaseLayer);

var proto = TMSLayer.prototype;

proto._makeOlLayer = function () {
  // here configuration to create TMS
  var _config = this.config,
      url = _config.url,
      attributions = _config.attributions,
      minZoom = _config.minZoom,
      maxZoom = _config.maxZoom;

  var olLayer = BasesLayers.TMS.get({
    url: url,
    minZoom: minZoom,
    maxZoom: maxZoom,
    attributions: attributions,
    projection: 'EPSG:' + this.config.crs
  });
  return olLayer;
};

module.exports = TMSLayer;

},{"core/layers/baselayers/baselayer":574,"core/utils/utils":630,"g3w-ol3/src/layers/bases":672}],579:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var BaseLayer = require('core/layers/baselayers/baselayer');
var BasesLayers = require('g3w-ol3/src/layers/bases');

function WMTSLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = options;
  base(this, options);
}

inherit(WMTSLayer, BaseLayer);

var proto = WMTSLayer.prototype;

proto._makeOlLayer = function () {
  //use this config to get params
  var _config = this.config,
      url = _config.url,
      layer = _config.layer,
      attributions = _config.attributions,
      crs = _config.crs;

  var olLayer = BasesLayers.WMTS.get({
    url: url,
    layer: layer,
    attributions: attributions,
    crs: crs
  });
  return olLayer;
};

module.exports = WMTSLayer;

},{"core/layers/baselayers/baselayer":574,"core/utils/utils":630,"g3w-ol3/src/layers/bases":672}],580:[function(require,module,exports){
var uniqueId = require('core/utils/utils').uniqueId;
var Feature = function Feature() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  ol.Feature.call(this);
  this._uid = uniqueId();
  this._newPrefix = '_new_';
  this._pk = options.pk || "id";
  var feature = options.feature;
  if (feature) {
    this.setProperties(feature.getProperties());
    this.setId(feature.getId());
    this.setGeometryName(feature.getGeometryName());
    var geometry = feature.getGeometry();
    geometry && this.setGeometry(geometry);
    var style = this.getStyle();
    style && this.setStyle(style);
  }
  this.state = {
    new: false,
    state: null
  };
};

ol.inherits(Feature, ol.Feature);

var proto = Feature.prototype;

// vado a cambiare il costruttore
proto.constructor = 'Feature';

proto.getUid = function () {
  return this._uid;
};

proto._setUid = function (uid) {
  this._uid = uid;
};

proto.clone = function () {
  // clono la feature
  var feature = ol.Feature.prototype.clone.call(this);
  feature.setId(this.getId());
  var clone = new Feature({
    feature: feature,
    pk: this._pk
  });
  clone._setUid(this.getUid());
  clone.setState(this.getState());
  this.isNew() && clone.setNew();
  return clone;
};

proto.setTemporaryId = function () {
  var newValue = this._newPrefix + Date.now();
  this.setId(newValue);
  //this.get(this._pk) === null && this.set(this._pk, newValue);
  this.setNew();
};

proto.setNew = function () {
  this.state.new = true;
};

proto.getPk = function () {
  return this._pk;
};

proto.isPk = function (field) {
  return field === this.getPk();
};

// setta la feature a state 2 delete
proto.delete = function () {
  this.state.state = 'delete';
  return this;
};

//setta lo stato a feature aggiornata
proto.update = function () {
  this.state.state = 'update';
  return this;
};

// setta lo stato a nuovo 0
proto.add = function () {
  this.state.state = 'add';
  return this;
};

proto.isNew = function () {
  return this.state.new;
};

proto.isAdded = function () {
  return this.state.state === 'add';
};

proto.isUpdated = function () {
  return this.state.state === 'update';
};

proto.isDeleted = function () {
  return this.state.state === 'delete';
};

proto.setFullState = function (state) {
  this.state = state;
};

proto.getFullState = function () {
  return this.state;
};

proto.setState = function (state) {
  this.state.state = state;
};

proto.getState = function () {
  return this.state.state;
};

proto.getAlphanumericProperties = function () {
  var properties = this.getProperties();
  var alphanumericproperties = {};
  for (var name in properties) {
    if (['boundedBy', 'geom', 'the_geom', 'geometry', 'bbox', 'GEOMETRY'].indexOf(name) === -1) alphanumericproperties[name] = properties[name];
  }
  alphanumericproperties[this._pk] = this.getId();
  return alphanumericproperties;
};

//clean state of the features
proto.clearState = function () {
  this.state.state = null;
  this.state.new = false;
};

module.exports = Feature;

},{"core/utils/utils":630}],581:[function(require,module,exports){
var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Object to store and handle features of layer
function FeaturesStore() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._features = options.features || [];
  this._provider = options.provider || null;
  this._loadedIds = []; // store loeckedids
  this._lockIds = []; // store locked features
  this.setters = {
    addFeatures: function addFeatures(features) {
      var _this = this;

      features.forEach(function (feature) {
        _this._addFeature(feature);
      });
    },
    addFeature: function addFeature(feature) {
      this._addFeature(feature);
    },
    removeFeature: function removeFeature(feature) {
      this._removeFeature(feature);
    },
    updateFeature: function updateFeature(feature) {
      this._updateFeature(feature);
    },
    clear: function clear() {
      this._clearFeatures();
      this._lockIds = [];
      this._loadedIds = [];
    },
    getFeatures: function getFeatures() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      return this._getFeatures(options);
    },
    commit: function commit(commitItems, featurestore) {
      return this._commit(commitItems, featurestore);
    }
  };

  base(this);
}

inherit(FeaturesStore, G3WObject);

var proto = FeaturesStore.prototype;

proto.clone = function () {
  return _.cloneDeep(this);
};

proto.setProvider = function (provider) {
  this._provider = provider;
};

proto.getProvider = function () {
  return this._provider;
};

// method unlock features
proto.unlock = function () {
  return this._provider.unlock();
};

// method get all features from server or attribute _features
proto._getFeatures = function () {
  var _this2 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  if (this._provider && options) {
    this._provider.getFeatures(options).then(function (options) {
      var features = _this2._filterFeaturesResponse(options);
      _this2.addFeatures(features);
      d.resolve(features);
    }).fail(function (err) {
      d.reject(err);
    });
  } else {
    d.resolve(this._readFeatures());
  }
  return d.promise();
};

//filter features to add
proto._filterFeaturesResponse = function () {
  var _this3 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var features = options.features || [];
  var featurelocks = options.featurelocks || [];
  var featuresToAdd = features.filter(function (feature) {
    var featureId = feature.getId();
    var added = _this3._loadedIds.indexOf(featureId) !== -1;
    if (!added) _this3._loadedIds.push(featureId);
    return !added;
  });
  this._filterLockIds(featurelocks);
  return featuresToAdd;
};

// method cget fetaures locked
proto._filterLockIds = function (featurelocks) {
  var _lockIds = this._lockIds.map(function (lockid) {
    return lockid.featureid;
  });
  var toAddLockId = featurelocks.filter(function (featurelock) {
    return _lockIds.indexOf(featurelock.featureid) === -1;
  });
  this._lockIds = [].concat((0, _toConsumableArray3.default)(this._lockIds), (0, _toConsumableArray3.default)(toAddLockId));
};

proto.addLoadedIds = function (pk) {
  this._loadedIds.push(pk);
};

proto.getLockIds = function () {
  return this._lockIds;
};

//method to add new lockid
proto.addLockIds = function (lockIds) {
  this._lockIds = _.union(this._lockIds, lockIds);
};

proto._readFeatures = function () {
  return this._features;
};

proto._commit = function (commitItems) {
  var d = $.Deferred();
  if (commitItems && this._provider) {
    commitItems.lockids = this._lockIds;
    this._provider.commit(commitItems).then(function (response) {
      d.resolve(response);
    }).fail(function (err) {
      d.reject(err);
    });
  } else {
    d.reject();
  }
  return d.promise();
};

// get feature from id
proto.getFeatureById = function (featureId) {
  return this._features.find(function (feature) {
    return feature.getId() === featureId;
  });
};

proto._addFeature = function (feature) {
  this._features.push(feature);
};

//substitute feature after update
proto._updateFeature = function (feature) {
  var _this4 = this;

  this._features.find(function (feat, idx) {
    if (feat.getUid() === feature.getUid()) {
      _this4._features[idx] = feature;
      return true;
    }
  });
};

proto.updatePkFeature = function (newValue, oldValue) {
  //TODO
};

proto.setFeatures = function (features) {
  this._features = features;
};

proto._removeFeature = function (feature) {
  this._features = this._features.filter(function (feat) {
    return feature.getUid() !== feat.getUid();
  });
};

proto._clearFeatures = function () {
  this._features = null;
  this._features = [];
};

proto.getDataProvider = function () {
  return this._provider;
};

// only read downloaded features
proto.readFeatures = function () {
  return this._features;
};

module.exports = FeaturesStore;

},{"babel-runtime/helpers/toConsumableArray":24,"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],582:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var FeaturesStore = require('./featuresstore');

// Storage of the feature in vector layer
function OlFeaturesStore() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._features = new ol.Collection();
}

inherit(OlFeaturesStore, FeaturesStore);

proto = OlFeaturesStore.prototype;

proto.getLength = function () {
  return this._features.getLength();
};

//overwrite
proto.setFeatures = function () {
  var _this = this;

  var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  features.forEach(function (feature) {
    _this._features.push(feature);
  });
};
// overwrite
proto.readFeatures = function () {
  return this._features.getArray();
};

proto.getFeaturesCollection = function () {
  return this._features;
};

proto.getFeatureById = function (featureId) {
  return this._features.getArray().find(function (feature) {
    return feature.getId() === featureId;
  });
};

proto._addFeature = function (feature) {
  this._features.push(feature);
  this._features.dispatchEvent('change');
};

//sobtitute the feature after modify
proto._updateFeature = function (feature) {
  // set index at -1
  var index = -1;
  var featuresArray = this._features.getArray();
  for (var i = 0; featuresArray.length; i++) {
    var _feature = featuresArray[i];
    if (_feature.getId() === feature.getId()) {
      index = i;
      break;
    }
  }
  if (index >= 0) {
    this._features.removeAt(index);
    this._features.insertAt(index, feature);
    this._features.dispatchEvent('change');
  }
};

// remove feature from store
proto._removeFeature = function (feature) {
  var featuresArray = this._features.getArray();
  for (var i = 0; i < featuresArray.length; i++) {
    var feat = featuresArray[i];
    if (feature.getId() === feat.getId()) {
      this._features.removeAt(i);
      break;
    }
  }
  this._features.dispatchEvent('change');
};

proto._clearFeatures = function () {
  this._features.clear({
    fast: true
  });
  // needed if we use Modify or snap interaction in ol to remove listerner on add or remove event on collection
  this._features = null;
  this._features = new ol.Collection();
};

module.exports = OlFeaturesStore;

},{"./featuresstore":581,"core/utils//utils":630,"core/utils/utils":630}],583:[function(require,module,exports){
var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

//Expression
function Expression() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._layerName = options.layerName;
  this._expression = '';
}

var proto = Expression.prototype;

proto.and = function (field, value) {
  this._expression = this._expression ? this._expression + ' AND ' : this._expression;
  if (field && value) {
    this.eq(field, value);
  }
  return this;
};

proto.or = function () {
  if (field && value) {
    this._expression = this._expression ? this._expression + ' OR ' : this._expression;
    this.eq(field, value);
  }
  return this;
};

proto.eq = function (field, value) {
  this._expression = this._expression + this._build('eq', field, value);
  return this;
};

proto.like = function (field, value) {
  this._expression = this._expression + this._build('LIKE', field, value);
  return this;
};

proto.ilike = function (field, value) {
  this._expression = this._expression + this._build('ILIKE', field, value);
  return this;
};

proto.not = function (field, value) {
  this._expression = this._expression + this._build('NOT', field, value);
  return this;
};

proto.gt = function (field, value) {
  this._expression = this._expression + this._build('gt', field, value);
  return this;
};

proto.gte = function (field, value) {
  this._expression = this._expression + this._build('gte', field, value);
  return this;
};

proto.lt = function (field, value) {
  this._expression = this._expression + this._build('lt', field, value);
  return this;
};

proto.lte = function (field, value) {
  this._expression = this._expression + this._build('lte', field, value);
  return this;
};

proto.clear = function () {
  this._expression = '';
  return this;
};

// get expression method to get the realt value of the expression
proto.get = function () {
  return this._layerName ? this._layerName + ': ' + this._expression : this._expression;
};

proto._build = function (operator, field, value) {
  return ['"' + field + '"', Expression.OPERATORS[operator], '' + value].join(' ');
};

proto.createExpressionFromFilter = function (filterObject, layername) {
  function createSingleFilter(booleanObject) {
    var filterElements = [];
    var rootFilter = void 0;
    for (var operator in booleanObject) {
      rootFilter = Expression.OPERATORS[operator];
      var inputs = booleanObject[operator];
      inputs.forEach(function (input) {
        for (var _operator in input) {
          var _value2 = input[_operator];
          if (Array.isArray(_value2)) {
            filterElement = createSingleFilter(input);
          } else {
            var valueExtra = _operator === 'LIKE' || _operator === 'ILIKE' ? "%" : "";
            filterOp = Expression.OPERATORS[_operator];
            for (var _operator2 in input) {
              var _field = input[_operator2];
              for (var name in _field) {
                var _value3 = _field[name];
                if (_operator2 === 'IN') {
                  var _value = Array.isArray(_value3) ? _value3 : [_value3];
                  var filterValue = '( ' + _value.join(',').replace(/,/g, ' , ') + ' )';
                  var _filterElement = '"' + name + '" ' + filterOp + ' ' + filterValue;
                  filterElements.push(_filterElement);
                } else if (_value3 !== null && _value3 !== undefined && !((0, _isNan2.default)(_value3) || !_value3.toString().trim())) {
                  var singolequote = typeof _value3 !== 'number' ? _value3.split("'") : [];
                  if (singolequote.length > 1) {
                    var _filterElements = [];
                    for (var i = 0; i < singolequote.length; i++) {
                      var _value4 = singolequote[i];
                      if (!_value4) continue;
                      var _filterOp = 'ILIKE';
                      var _filterValue = ('%' + _value4 + '%').trim();
                      var _filterElement2 = '"' + name + '" ' + _filterOp + ' \'' + _filterValue + '\'';
                      _filterElements.push(_filterElement2);
                    }
                    filterElements.push(_filterElements.join(' AND '));
                  } else {
                    var _filterValue2 = '' + valueExtra + _value3 + valueExtra;
                    var _filterElement3 = '"' + name + '" ' + filterOp + ' \'' + _filterValue2 + '\'';
                    filterElements.push(_filterElement3);
                  }
                }
              }
            }
          }
        }
      });
      rootFilter = filterElements.length > 0 ? filterElements.join(" " + rootFilter + " ") : false;
    }
    return rootFilter;
  }
  var filter = createSingleFilter(filterObject);
  if (filter) this._expression = layername + ':' + filter;
  return this;
};

// map object between operator
Expression.OPERATORS = {
  IN: 'IN',
  eq: '=',
  gt: '>',
  gte: '>=',
  lt: '<',
  lte: '<=',
  'lte=': '<=',
  ltgt: '!=',
  LIKE: 'LIKE',
  ILIKE: 'ILIKE',
  AND: 'AND',
  OR: 'OR',
  NOT: '!='
};

module.exports = Expression;

},{"babel-runtime/core-js/number/is-nan":8}],584:[function(require,module,exports){
var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// class Filter to build filter
// useful by provider providers to get data
function Filter() {
  this._filter = null;
  this._type = null;
}

var proto = Filter.prototype;

proto.getAll = function () {
  this._type = Filter.TYPES.all;
  this._filter = null;
};

// to create complex filter
proto.setExpression = function (expression) {
  this._type = Filter.TYPES.expression;
  this._filter = expression;
};

proto.setGeometry = function (geometry) {
  this._type = Filter.TYPES.geometry;
  this._filter = geometry;
  return this;
};

proto.setBBOX = function (bbox) {
  this._type = Filter.TYPES.bbox;
  this._filter = bbox;
  return this;
};

proto.setFids = function (ids) {
  this._type = Filter.TYPES.fids;
  this._filter = ids;
  return this;
};

proto.serialize = function () {
  return (0, _stringify2.default)(this);
};

// get filter value
proto.get = function () {
  return this._filter;
};

proto.getType = function () {
  return this._type;
};

proto.clear = function () {
  this._filter = null;
};

Filter.TYPES = {
  bbox: 'bbox',
  geometry: 'geometry',
  expression: 'expression',
  fids: 'fids',
  all: 'all'
};

module.exports = Filter;

},{"babel-runtime/core-js/json/stringify":6}],585:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var VectorLayer = require('./vectorlayer');
var GeojsonMapLayer = require('./map/geojson');

function GeojsonLayer(config, options) {
  base(this, config, options);
  this.config.style = config.style;
  this.setup(config);
}

inherit(GeojsonLayer, VectorLayer);

var proto = GeojsonLayer.prototype;

proto.getMapLayer = function () {
  if (this._mapLayer) return this._mapLayer;
  var url = this.get('source').url;
  var name = this.getName();
  var id = this.getId();
  var style = this.get('style');
  var provider = this.getProvider('data');
  var options = {
    url: url,
    projection: this.getProjection().getCode(),
    id: id,
    name: name,
    style: style,
    provider: provider
  };
  this._mapLayer = new GeojsonMapLayer(options);
  return this._mapLayer;
};

module.exports = GeojsonLayer;

},{"./map/geojson":596,"./vectorlayer":611,"core/utils//utils":630,"core/utils/utils":630}],586:[function(require,module,exports){
var Projections = require('g3w-ol3/src/projection/projections');

var _require = require('g3w-ol3/src/utils/utils'),
    getScaleFromResolution = _require.getScaleFromResolution;

var _require2 = require('core/utils/utils'),
    sanitizeUrl = _require2.sanitizeUrl;

var RESERVERDPARAMETRS = {
  wms: ['VERSION', 'REQUEST', 'BBOX', 'LAYERS', 'WIDTH', 'HEIGHT', 'DPI', 'FORMAT', 'CRS']
};

function GeoLayerMixin() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
}

var proto = GeoLayerMixin.prototype;

proto.setup = function () {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var ProjectsRegistry = require('core/project/projectsregistry');
  ProjectsRegistry.onceafter('setCurrentProject', function (project) {
    _this.config.map_crs = 1 * project.getProjection().getCode().split('EPSG:')[1];
  });
  if (!this.config) {
    console.log("GeoLayerMixin must be used from a valid (geo) Layer instance");
    return;
  }
  this.config.multilayerid = config.multilayer;
  // state extend of layer setting geolayer property to true
  // and adding informations of bbox
  _.extend(this.state, {
    geolayer: true,
    external: config.source && config.source.external || false,
    bbox: config.bbox || null,
    visible: config.visible || false,
    checked: config.visible || false,
    hidden: config.hidden || false,
    scalebasedvisibility: config.scalebasedvisibility || false,
    minscale: config.minscale,
    maxscale: config.maxscale,
    ows_method: config.ows_method,
    exclude_from_legend: typeof config.exclude_from_legend == 'boolean' ? config.exclude_from_legend : true
  });
  if (config.projection) {
    if (config.projection.getCode() === config.crs) this.config.projection = config.projection;else this.config.projection = Projections.get(config.crs, config.proj4);
  } else if (config.attributions) {
    this.config.attributions = config.attributions;
  }
  config.source && config.source.url && this._sanitizeSourceUrl();
};

proto._sanitizeSourceUrl = function () {
  var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'wms';

  var sanitizedUrl = sanitizeUrl({
    url: this.config.source.url,
    reserverParameters: RESERVERDPARAMETRS[type]
  });
  this.config.source.url = sanitizedUrl;
};

proto.setChecked = function (bool) {
  this.state.checked = bool;
};

proto.isChecked = function () {
  return this.state.checked;
};

proto.setVisible = function (visible) {
  this.state.visible = visible;
};

proto.getStyle = function () {
  return this.config.style;
};

proto.setStyle = function (style) {
  this.config.style = style;
};

proto.isDisabled = function () {
  return this.state.disabled;
};

proto.isPrintable = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      scale = _ref.scale;

  var ProjectsRegistry = require('core/project/projectsregistry');
  var QGISVERSION = ProjectsRegistry.getCurrentProject().getQgisVersion({
    type: 'major'
  });
  var visible = QGISVERSION === 3 ? !this.state.groupdisabled : true;
  return this.isChecked() && visible && (!this.state.scalebasedvisibility || scale >= this.state.maxscale && scale <= this.state.minscale);
};

proto.setDisabled = function (resolution) {
  var mapUnits = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'm';

  var ProjectsRegistry = require('core/project/projectsregistry');
  var QGISVERSION = ProjectsRegistry.getCurrentProject().getQgisVersion({
    type: 'major'
  });
  if (this.state.scalebasedvisibility) {
    var mapScale = getScaleFromResolution(resolution, mapUnits);
    this.state.disabled = !(mapScale >= this.state.maxscale && mapScale <= this.state.minscale);
    this.state.disabled = QGISVERSION === 3 && this.state.minscale === 0 ? !(mapScale >= this.state.maxscale) : this.state.disabled;
  } else {
    this.state.disabled = false;
  }
};

proto.getMultiLayerId = function () {
  return this.config.multilayerid;
};

proto.getGeometryType = function () {
  return this.config.geometrytype;
};

proto.getOwsMethod = function () {
  return this.config.ows_method;
};

proto.setProjection = function (crs, proj4) {
  this.config.projection = Projections.get(crs, proj4);
};

proto.getProjection = function () {
  return this.config.projection;
};

proto.getCrs = function () {
  if (this.config.projection) {
    return this.config.projection.getCode();
  }
};

proto.isCached = function () {
  return this.config.cache_url && this.config.cache_url !== '';
};

proto.getCacheUrl = function () {
  if (this.isCached()) {
    return this.config.cache_url;
  }
};

// return if layer has inverted axis
proto.hasAxisInverted = function () {
  var projection = this.getProjection();
  var axisOrientation = projection.getAxisOrientation ? projection.getAxisOrientation() : "enu";
  return axisOrientation.substr(0, 2) === 'ne';
};

proto.getMapLayer = function () {
  console.log('overwrite by single layer');
};

proto.setMapProjection = function (mapProjection) {
  this._mapProjection = mapProjection;
};

proto.getMapProjection = function () {
  return this._mapProjection;
};

module.exports = GeoLayerMixin;

},{"core/project/projectsregistry":624,"core/utils/utils":630,"g3w-ol3/src/projection/projections":676,"g3w-ol3/src/utils/utils":678}],587:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var Layer = require('core/layers/layer');
var VectorLayer = require('./vectorlayer');
var WMSLayer = require('./map/wmslayer');
var ARCGISMAPSERVERLayer = require('./map/arcgismapserverlayer');
var XYZLayer = require('./map/xyzlayer');
var LegendService = require('./legend/legendservice');
var GeoLayerMixin = require('./geolayermixin');

function ImageLayer() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  /*{
    id,
    title,
    name,
    origname,
    multilayerid,
    servertype,
    source,
    crs,
    projection,
    bbox,
    capabilities,
    cache_url,
    baselayer,
    geometrytype,
    editops,
    expanded,
    fields,
    wmsUrl,
    infoformat,
    infourl,
    maxscale,
    minscale,
    visible,
    scalebasedvisibility,
    wfscapabilities
    ows_method
    wms_use_layer_ids
  }*/
  base(this, config);
  this.config.baselayer = config.baselayer || false;
  this.type = Layer.LayerTypes.IMAGE;
  this.setup(config);
}

inherit(ImageLayer, Layer);

mixin(ImageLayer, GeoLayerMixin);

var proto = ImageLayer.prototype;

proto.getLayerForEditing = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$force = _ref.force,
      force = _ref$force === undefined ? false : _ref$force,
      vectorurl = _ref.vectorurl,
      project_type = _ref.project_type;

  if (this.isEditable() || force) {
    //return istance of vectorlayer
    var editingLayer = new VectorLayer(this.config, {
      vectorurl: vectorurl,
      project_type: project_type
    });
    // set editing layer
    this.setEditingLayer(editingLayer);
    return editingLayer;
  } else {
    return null;
  }
};

proto.isBaseLayer = function () {
  return this.config.baselayer;
};

proto.isWMS = function () {
  return ImageLayer.WMSServerTypes.indexOf(this.config.servertype) > -1;
};

proto.isLayerProjectionASMapProjection = function () {
  return this.config.crs === this.config.map_crs;
};

proto.getCrs = function () {
  return this.config.crs;
};

proto.isExternalWMS = function () {
  return !!(this.config.source && this.config.source.external && this.config.source.url);
};

proto.isArcgisMapserver = function () {
  return this.isExternalWMS() && this.config.source.type === 'arcgismapserver';
};

proto._getBaseLayerName = function () {
  var baseLayerName = (!this.isExternalWMS() || this.isExternalWMS() && !this.isLayerProjectionASMapProjection()) && this.isWmsUseLayerIds() ? this.getId() : this.getName();
  return baseLayerName;
};

proto.getWMSLayerName = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$type = _ref2.type,
      type = _ref2$type === undefined ? 'map' : _ref2$type;

  var legendMapBoolean = type === 'map' ? this.isExternalWMS() && this.isLayerProjectionASMapProjection() : true;
  var layerName = this._getBaseLayerName();
  if (legendMapBoolean && this.config.source && (type === 'legend' || this.config.source.external) && (this.config.source.layers || this.config.source.layer)) {
    layerName = this.config.source.layers || this.config.source.layer;
  }
  return layerName;
};

proto.getWMSInfoLayerName = function () {
  return this._getBaseLayerName();
};

proto.getPrintLayerName = function () {
  return this.isWmsUseLayerIds() ? this.getId() : this.getName();
};

proto.getStringBBox = function () {
  var bbox = this.config.bbox;
  return bbox.minx + ',' + bbox.miny + ',' + bbox.maxx + ',' + bbox.maxy;
};

proto.getFullWmsUrl = function () {
  var ProjectsRegistry = require('core/project/projectsregistry');
  var metadata_wms_url = ProjectsRegistry.getCurrentProject().getState().metadata.wms_url;
  return this.isExternalWMS() || !metadata_wms_url ? this.getWmsUrl() : metadata_wms_url;
};

// values: map, legend
proto.getWmsUrl = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$type = _ref3.type,
      type = _ref3$type === undefined ? 'map' : _ref3$type;

  var legendMapBoolean = type === 'map' ? this.isExternalWMS() && this.isLayerProjectionASMapProjection() : true;
  return legendMapBoolean && this.config.source && (type === 'legend' || this.config.source.external) && this.config.source.type === 'wms' && this.config.source.url ? this.config.source.url : this.config.wmsUrl;
};

proto.getQueryUrl = function () {
  var url = base(this, 'getQueryUrl');
  if (this.getServerType() === 'QGIS' && this.isExternalWMS() && this.isLayerProjectionASMapProjection()) {
    url = url + 'SOURCE=' + this.config.source.type;
  }
  return url;
};

proto.getIconUrlFromLegend = function () {
  return this.getLegendUrl({
    layertitle: false
  });
};

proto.getLegendUrl = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return LegendService.get({
    layer: this,
    params: params
  });
};

proto.getWFSLayerName = function () {
  var layerName = this.config.origname;
  if (this.config.source && this.config.source.layers) {
    layerName = this.config.source.layers;
  }
  return layerName;
};

proto.getWfsCapabilities = function () {
  return this.config.wfscapabilities || this.config.capabilities === 1;
};

proto.getMapLayer = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extraParams = arguments[1];

  var mapLayer = void 0;
  var method = this.isExternalWMS() ? 'GET' : this.getOwsMethod();
  if (this.isCached()) {
    mapLayer = new XYZLayer(options, method);
  } else {
    if (this.isExternalWMS() && this.config.source && this.config.source.type === 'arcgismapserver') {
      options = (0, _extends3.default)({}, options, this.config.source);
      mapLayer = new ARCGISMAPSERVERLayer(options, extraParams);
    } else {
      options.url = options.url || this.getWmsUrl();
      mapLayer = new WMSLayer(options, extraParams, method);
    }
  }
  return mapLayer;
};

ImageLayer.WMSServerTypes = [Layer.ServerTypes.QGIS, Layer.ServerTypes.Mapserver, Layer.ServerTypes.Geoserver, Layer.ServerTypes.OGC];

module.exports = ImageLayer;

},{"./geolayermixin":586,"./legend/legendservice":593,"./map/arcgismapserverlayer":595,"./map/wmslayer":599,"./map/xyzlayer":600,"./vectorlayer":611,"babel-runtime/helpers/extends":22,"core/layers/layer":588,"core/project/projectsregistry":624,"core/utils//utils":630,"core/utils/utils":630}],588:[function(require,module,exports){
var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var t = require('core/i18n/i18n.service').t;
var XHR = require('core/utils/utils').XHR;
var G3WObject = require('core/g3wobject');
var Filter = require('core/layers/filter/filter');
var ProviderFactory = require('core/layers/providers/providersfactory');

// Base Class of all Layer
function Layer() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var ProjectsRegistry = require('core/project/projectsregistry');
  ProjectsRegistry.onceafter('setCurrentProject', function (project) {
    var qgisVersion = project.getQgisVersion({
      type: 'major'
    });
    var projectType = project.getType();
    var projectId = project.getId();
    var suffixUrl = projectType + '/' + projectId + '/' + config.id + '/';
    var vectorUrl = initConfig.vectorurl;
    _this.config.urls.data = vectorUrl + 'data/' + suffixUrl;
    _this.config.urls.shp = vectorUrl + 'shp/' + suffixUrl;
    //set custom parameters based on project qgis version
    _this.config.customParams = {
      search: {
        I: qgisVersion === 2 ? null : 0,
        J: qgisVersion === 2 ? null : 0
      }
    };
  });
  // assign some attribute
  config.id = config.id || 'Layer';
  config.title = config.title || config.name;
  config.download = !!config.download;
  config.geolayer = false;
  config.baseLayer = false;
  config.fields = config.fields || {};
  config.urls = (0, _extends3.default)({
    query: config.infourl && config.infourl !== '' ? config.infourl : config.wmsUrl
  }, config.urls || {});
  this.config = config;
  // dinamic layer values
  this.state = {
    id: config.id,
    title: config.title,
    selected: config.selected | false,
    disabled: config.disabled | false,
    metadata: config.metadata,
    metadata_querable: this.isQueryable({ onMap: false }),
    openattributetable: this.canShowTable(),
    removable: config.removable || false,
    source: config.source,
    infoformat: this.getInfoFormat(),
    geolayer: false
  };

  this._editingLayer = null;
  // refferred to (layersstore);
  this._layersstore = config.layersstore || null;
  /*
    Providers that layer can use
     Three type of provider:
      1 - query
      2 - filter
      3 - data -- raw data del layer (editing)
   */
  // server type
  var serverType = this.config.servertype;
  // source layer
  var sourceType = this.config.source ? this.config.source.type : null;
  if (serverType && sourceType) {
    this.providers = {
      query: ProviderFactory.build('query', serverType, sourceType, {
        layer: this
      }),
      filter: ProviderFactory.build('filter', serverType, sourceType, {
        layer: this
      }),
      search: ProviderFactory.build('search', serverType, sourceType, {
        layer: this
      }),
      data: ProviderFactory.build('data', serverType, sourceType, {
        layer: this
      })
    };
  }
  base(this);
}

inherit(Layer, G3WObject);

var proto = Layer.prototype;

proto.getWMSLayerName = function () {
  return this.isWmsUseLayerIds() ? this.getId() : this.getName();
};

proto.isWmsUseLayerIds = function () {
  return this.config.wms_use_layer_ids;
};

proto.getShp = function () {
  var url = this.getUrl('shp');
  return XHR.fileDownload({
    url: url,
    httpMethod: "GET"
  });
};

proto.getSourceType = function () {
  return this.config.source ? this.config.source.type : null;
};

proto.isGeoLayer = function () {
  return this.state.geolayer;
};

proto.getDataTable = function () {
  var _this2 = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$page = _ref.page,
      page = _ref$page === undefined ? null : _ref$page,
      _ref$page_size = _ref.page_size,
      page_size = _ref$page_size === undefined ? null : _ref$page_size,
      _ref$ordering = _ref.ordering,
      ordering = _ref$ordering === undefined ? null : _ref$ordering,
      _ref$search = _ref.search,
      search = _ref$search === undefined ? null : _ref$search,
      _ref$suggest = _ref.suggest,
      suggest = _ref$suggest === undefined ? null : _ref$suggest;

  var d = $.Deferred();
  var provider = void 0;
  var params = {
    page: page,
    page_size: page_size,
    ordering: ordering,
    search: search,
    suggest: suggest
  };
  if (!(this.getProvider('filter') || this.getProvider('data'))) {
    d.reject();
  } else {
    if (this.getServerType() === 'QGIS' && [Layer.SourceTypes.POSTGIS, Layer.SourceTypes.SPATIALITE].indexOf(this.config.source.type) !== -1) {
      provider = this.getProvider('data');
      provider.getFeatures({ editing: false }, params).done(function (response) {
        var pkProperties = void 0;
        var data = response.data;
        var count = response.count;
        var title = _this2.getTitle();
        var headers = void 0,
            features = void 0;
        if (_this2.getType() === 'table') {
          features = data.map(function (feature) {
            return {
              properties: feature
            };
          });
          headers = _this2.getAttributes();
        } else if (_this2.get('source').type === 'geojson') {
          var _data = provider.digestFeaturesForLayers([{
            layer: _this2,
            features: response
          }]);
          headers = _data[0].attributes;
          features = _data[0].features;
        } else {
          pkProperties = _this2.getFields().find(function (field) {
            return response.pk === field.name && field.show;
          });
          features = data.features;
          headers = features.length ? features[0].properties : [];
          headers = provider._parseAttributes(_this2.getAttributes(), headers);
          if (pkProperties) headers.unshift(pkProperties);
        }
        var dataTableObject = {
          pk: !!pkProperties,
          pkField: response.pk,
          headers: headers,
          features: features,
          title: title,
          count: count
        };
        d.resolve(dataTableObject);
      }).fail(function (err) {
        d.reject(err);
      });
    } else if (this.isFilterable()) {
      provider = this.getProvider('filter');
      var filter = new Filter();
      filter.getAll();
      provider.query({
        filter: filter
      }).done(function (response) {
        var data = provider.digestFeaturesForLayers(response.data);
        var dataTableObject = {
          pkField: response.pk,
          headers: data[0].attributes,
          features: data[0].features,
          title: _this2.getTitle()
        };
        d.resolve(dataTableObject);
      }).fail(function (err) {
        d.reject(err);
      });
    } else {
      d.reject();
    }
  }
  return d.promise();
};

// search method
proto.search = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // check option feature_count
  options.feature_count = options.feature_count || 10;
  //for qgis 2 / 3 purpose
  options = (0, _extends3.default)({}, options, this.config.customParams.search);
  var d = $.Deferred();
  var provider = this.getProvider('search');
  if (provider) {
    provider.query(options).done(function (response) {
      d.resolve(response);
    }).fail(function (err) {
      d.reject(err);
    });
  } else {
    d.reject(t('sdk.search.layer_not_searchable'));
  }
  return d.promise();
};

//Info from layer (only for querable layers)
proto.query = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var provider = this.getProvider('query');
  // in case filter
  if (options.filter) {
    provider = this.providers.filter;
  }
  // if is intanced provider
  if (provider) {
    provider.query(options).done(function (response) {
      d.resolve(response);
    }).fail(function (err) {
      d.reject(err);
    });
  } else {
    d.reject('Il layer non  interrogabile');
  }
  return d.promise();
};

// generel way to get an attribute
proto.get = function (property) {
  return this.config[property] ? this.config[property] : this.state[property];
};

proto.getFields = function () {
  return this.config.fields;
};

proto.getEditingFields = function () {
  return this.config.editing.fields;
};

proto.getTableFields = function () {
  return this.config.fields.filter(function (field) {
    return field.show;
  });
};

proto.getProject = function () {
  return this.config.project;
};

proto.getConfig = function () {
  return this.config;
};

proto.getEditorFormStructure = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$all = _ref2.all,
      all = _ref2$all === undefined ? false : _ref2$all;

  return this.config.editor_form_structure && !all ? this.config.editor_form_structure.filter(function (structure) {
    return !structure.field_name;
  }) : this.config.editor_form_structure;
};

proto.getFieldsOutOfFormStructure = function () {
  return this.config.editor_form_structure ? this.config.editor_form_structure.filter(function (structure) {
    return structure.field_name;
  }) : [];
};

proto.hasFormStructure = function () {
  return !!this.config.editor_form_structure;
};

proto.getState = function () {
  return this.state;
};

proto.getSource = function () {
  return this.state.source;
};

proto.getSourceType = function () {
  return this.state.source ? this.state.source.type : null;
};

proto.isShpDownlodable = function () {
  return this.config.download;
};

proto.getEditingLayer = function () {
  return this._editingLayer;
};

proto.setEditingLayer = function (editingLayer) {
  this._editingLayer = editingLayer;
};

proto.isHidden = function () {
  return this.state.hidden;
};

proto.setHidden = function (bool) {
  this.state.hidden = _.isBoolean(bool) ? bool : true;
};

proto.isModified = function () {
  return this.state.modified;
};

proto.getId = function () {
  return this.config.id;
};

proto.getMetadata = function () {
  return this.state.metadata;
};

proto.getTitle = function () {
  return this.config.title;
};

proto.getName = function () {
  return this.config.name;
};

proto.getOrigName = function () {
  return this.config.origname;
};

proto.getServerType = function () {
  return this.config.servertype && this.config.servertype !== '' ? this.config.servertype : ServerTypes.QGIS;
};

proto.getType = function () {
  return this.type;
};

proto.isType = function (type) {
  return this.getType() === type;
};

proto.setType = function (type) {
  this.type = type;
};

proto.isSelected = function () {
  return this.state.selected;
};

proto.setSelected = function (bool) {
  this.state.selected = bool;
};

proto.setDisabled = function (bool) {
  this.state.disabled = bool;
};

proto.isDisabled = function () {
  return this.state.disabled;
};

proto.isVisible = function () {
  return !this.state.groupdisabled && this.state.checked && !this.isDisabled();
};

proto.setVisible = function (bool) {
  this.state.visible = bool;
};

// set a parametre map to check if request from map point of view or just a capabilities info layer
proto.isQueryable = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { onMap: false },
      onMap = _ref3.onMap;

  var queryEnabled = false;
  var queryableForCababilities = !!(this.config.capabilities && this.config.capabilities & Layer.CAPABILITIES.QUERYABLE);
  if (!onMap) return queryableForCababilities;
  // if querable check if is visible or disabled
  if (queryableForCababilities) {
    queryEnabled = this.isVisible() && !this.isDisabled();
    if (!_.isUndefined(this.config.infowhennotvisible) && this.config.infowhennotvisible === true) {
      queryEnabled = true;
    }
  }
  return queryEnabled;
};

proto.isFilterable = function () {
  return !!(this.config.capabilities && this.config.capabilities & Layer.CAPABILITIES.FILTERABLE);
};

proto.isEditable = function () {
  return !!(this.config.capabilities && this.config.capabilities & Layer.CAPABILITIES.EDITABLE);
};

proto.isBaseLayer = function () {
  return this.config.baselayer;
};

// get url by type ( data, editing..etc..)
proto.getUrl = function (type) {
  return this.config.urls[type];
};

// return urls
proto.getUrls = function () {
  return this.config.urls;
};

proto.getQueryUrl = function () {
  return this.config.urls.query;
};

proto.setQueryUrl = function (queryUrl) {
  this.config.urls.query = queryUrl;
};

proto.getQueryLayerName = function () {
  return this.config.infolayer && this.config.infolayer !== '' ? this.config.infolayer : this.getName();
};

proto.getQueryLayerOrigName = function () {
  var queryLayerName = void 0;
  if (this.state.infolayer && this.config.infolayer !== '') {
    queryLayerName = this.config.infolayer;
  } else {
    queryLayerName = this.config.origname;
  }
  return queryLayerName;
};

proto.getInfoFormat = function (ogcService) {
  return this.config.infoformat && this.config.infoformat !== '' && ogcService !== 'wfs' ? this.config.infoformat : 'application/vnd.ogc.gml';
};

proto.getInfoUrl = function () {
  return this.config.infourl;
};

proto.setInfoFormat = function (infoFormat) {
  this.state.infoformat = infoFormat;
};

proto.getAttributes = function () {
  return this.config.fields;
};

proto.changeAttribute = function (attribute, type, options) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(this.config.fields), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var field = _step.value;

      if (field.name === attribute) {
        field.type = type;
        field.options = options;
        break;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

proto.getAttributeLabel = function (name) {
  var field = this.getAttributes().find(function (field) {
    return field.name === name;
  });
  return field && field.label;
};

proto.getProvider = function (type) {
  return this.providers[type];
};

proto.getProviders = function () {
  return this.providers;
};

proto.getLayersStore = function () {
  return this._layersstore;
};

proto.setLayersStore = function (layerstore) {
  this._layersstore = layerstore;
};

proto.canShowTable = function () {
  if (this.getServerType() === 'QGIS') {
    if ([Layer.SourceTypes.POSTGIS, Layer.SourceTypes.SPATIALITE].indexOf(this.config.source.type) > -1 && this.isQueryable()) {
      return true;
    }
  } else if (this.getServerType() === 'G3WSUITE') {
    if (this.get('source').type === "geojson") return true;
  } else if (this.isFilterable()) return true;
  return false;
};

/// LAYER PROPERTIES

// Layer Types
Layer.LayerTypes = {
  TABLE: "table",
  IMAGE: "image",
  VECTOR: "vector"
};

// Server Types
Layer.ServerTypes = {
  OGC: "OGC",
  QGIS: "QGIS",
  Mapserver: "Mapserver",
  Geoserver: "Geoserver",
  ARCGISMAPSERVER: "ARCGISMAPSERVER",
  OSM: "OSM",
  BING: "Bing",
  LOCAL: "Local",
  TMS: "TMS",
  WMTS: "WMTS",
  G3WSUITE: "G3WSUITE"

};

// Source Types
Layer.SourceTypes = {
  POSTGIS: 'postgres',
  SPATIALITE: 'spatialite',
  CSV: 'delimitedtext',
  OGR: 'ogr',
  WMS: 'wms',
  GEOJSON: "geojson"
};

// Layer Capabilities
Layer.CAPABILITIES = {
  QUERYABLE: 1,
  FILTERABLE: 2,
  EDITABLE: 4
};

//Editing types
Layer.EDITOPS = {
  INSERT: 1,
  UPDATE: 2,
  DELETE: 4
};

module.exports = Layer;

},{"babel-runtime/core-js/get-iterator":4,"babel-runtime/helpers/extends":22,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/layers/filter/filter":584,"core/layers/providers/providersfactory":604,"core/project/projectsregistry":624,"core/utils/utils":630}],589:[function(require,module,exports){
var Layer = require('./layer');
var TableLayer = require('./tablelayer');
var VectorLayer = require('./vectorlayer');
var ImageLayer = require('./imagelayer');
var BaseLayers = require('./baselayers/baselayers');
var GeojsonLayer = require('./geojson');

// Class to build layer based on configuration
function LayerFactory() {
  this.build = function (config, options) {
    // return the layer instance
    var layerClass = this.get(config);
    if (layerClass) {
      return new layerClass(config, options);
    }
    return null;
  };

  this.get = function (config) {
    var LayerClass = void 0;
    var serverType = config.servertype;
    switch (serverType) {
      case Layer.ServerTypes.QGIS:
        LayerClass = ImageLayer;
        if (config.source && config.geometrytype) {
          if ([Layer.SourceTypes.POSTGIS, Layer.SourceTypes.SPATIALITE, Layer.SourceTypes.CSV, Layer.SourceTypes.OGR].indexOf(config.source.type) > -1) {
            if (config.geometrytype && config.geometrytype === 'No geometry') {
              // if no geometry retun Table Layer
              LayerClass = TableLayer;
            }
          }
        }
        break;
      case Layer.ServerTypes.OGC:
        if (config.source) {
          var type = config.source.type;
          switch (type) {
            case 'wms':
              LayerClass = ImageLayer;
              break;
            case 'wfs':
              LayerClass = VectorLayer;
          }
        }
        break;
      case Layer.ServerTypes.LOCAL:
        LayerClass = VectorLayer;
        break;
      case Layer.ServerTypes.OSM:
      case Layer.ServerTypes.BING:
      case Layer.ServerTypes.TMS:
      case Layer.ServerTypes.WMTS:
      case Layer.ServerTypes.ARCGISMAPSERVER:
        LayerClass = BaseLayers[serverType];
        break;
      case Layer.ServerTypes.G3WSUITE:
        LayerClass = VectorLayer;
        if (config.source) {
          switch (config.source.type) {
            case 'geojson':
              LayerClass = GeojsonLayer;
              break;
          }
        }
        break;
    }
    return LayerClass;
  };
}

module.exports = new LayerFactory();

},{"./baselayers/baselayers":575,"./geojson":585,"./imagelayer":587,"./layer":588,"./tablelayer":610,"./vectorlayer":611}],590:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Interface for Layers
function LayersStore() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = {
    id: config.id || Date.now(),
    projection: config.projection,
    extent: config.extent,
    initextent: config.initextent,
    wmsUrl: config.wmsUrl,
    //set catalogable property
    catalog: _.isBoolean(config.catalog) ? config.catalog : true
  };

  this.state = {
    //useful to build layerstree
    layerstree: [],
    relations: null // useful to build tree of relations
  };
  this._isQueryable = _.isBoolean(config.queryable) ? config.queryable : true;
  this._layers = this.config.layers || {};
  this.setters = {
    setLayersVisible: function setLayersVisible(layersIds, visible) {
      var _this = this;

      var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

      var layers = [];
      layersIds.forEach(function (layerId) {
        var layer = _this.getLayerById(layerId);
        layer.setVisible(visible);
        checked && layer.setChecked(visible);
        layers.push(layer);
      });
      return layers;
    },
    setLayerSelected: function setLayerSelected(layerId, selected) {
      var layers = this.getLayers();
      layers.forEach(function (layer) {
        layer.state.selected = layerId === layer.getId() && selected || false;
      });
    },
    addLayers: function addLayers(layers) {
      var _this2 = this;

      layers.forEach(function (layer) {
        _this2.addLayer(layer);
      });
    },
    addLayer: function addLayer(layer) {
      this._addLayer(layer);
    },
    removeLayer: function removeLayer(layerId) {
      this._removeLayer(layerId);
    }
  };

  base(this);
}

inherit(LayersStore, G3WObject);

proto = LayersStore.prototype;

proto.isQueryable = function () {
  return this._isQueryable;
};

proto.setQueryable = function (bool) {
  this._isQueryable = !!bool;
};

proto.showOnCatalog = function () {
  return this.config.catalog;
};

proto.setOptions = function (config) {
  this.config = config;
};

proto.getId = function () {
  return this.config.id;
};

proto._addLayer = function (layer) {
  this._layers[layer.getId()] = layer;
};

proto._removeLayer = function (layer) {
  var layerId = layer.getId();
  delete this._layers[layerId];
};

proto.removeLayers = function () {
  var _this3 = this;

  (0, _entries2.default)(this._layers).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        layerId = _ref2[0],
        layer = _ref2[1];

    _this3.removeLayer(layer);
  });
};

proto.getLayersDict = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!options) {
    return this._layers;
  }
  var filterPrintable = options.PRINTABLE;
  var filterActive = options.ACTIVE;
  var filterQueryable = options.QUERYABLE;
  var filterFilterable = options.FILTERABLE;
  var filterEditable = options.EDITABLE;
  var filterVisible = options.VISIBLE;
  var filterSelected = options.SELECTED;
  var filterCached = options.CACHED;
  var filterSelectedOrAll = options.SELECTEDORALL;
  var filterAllNotSelected = options.ALLNOTSELECTED;
  var filterServerType = options.SERVERTYPE;
  var filterBaseLayer = options.BASELAYER;
  var filterGeoLayer = options.GEOLAYER;
  var filterVectorLayer = options.VECTORLAYER;
  var filterHidden = options.HIDDEN;
  var filterDisabled = options.DISABLED;
  var filterIds = options.IDS;
  if (_.isUndefined(filterQueryable) && _.isUndefined(filterFilterable) && _.isUndefined(filterEditable) && _.isUndefined(filterVisible) && _.isUndefined(filterActive) && _.isUndefined(filterSelected) && _.isUndefined(filterCached) && _.isUndefined(filterSelectedOrAll) && _.isUndefined(filterServerType) && _.isUndefined(filterGeoLayer) && _.isUndefined(filterHidden) && _.isUndefined(filterDisabled) && _.isUndefined(filterBaseLayer) && _.isUndefined(filterVectorLayer) && _.isUndefined(filterPrintable) && _.isUndefined(filterIds)) {
    return this._layers;
  }
  var layers = [];

  for (var key in this._layers) {
    layers.push(this._layers[key]);
  }

  // return only selected
  if (filterSelectedOrAll) {
    var _layers = layers;
    layers = layers.filter(function (layer) {
      return layer.isSelected();
    });
    layers = layers.length ? layers : _layers;
  }

  if (filterIds) {
    var ids = Array.isArray(filterIds) ? filterIds : [filterIds];
    layers = layers.filter(function (layer) {
      return ids.indexOf(layer.getId()) !== -1;
    });
  }

  if (typeof filterActive === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterActive === !layer.isDisabled();
    });
  }

  if (typeof filterQueryable === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterQueryable === layer.isQueryable();
    });
  }

  if (typeof filterFilterable === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterFilterable === layer.isFilterable();
    });
  }

  if (typeof filterEditable === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterEditable === layer.isEditable();
    });
  }

  if (typeof filterVisible === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterVisible === layer.isVisible();
    });
  }

  if (typeof filterCached === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterCached === layer.isCached();
    });
  }

  if (typeof filterSelected === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterSelected === layer.isSelected();
    });
  }

  if (typeof filterBaseLayer === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterBaseLayer === layer.isBaseLayer();
    });
  }

  if (typeof filterGeoLayer === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterGeoLayer === layer.state.geolayer;
    });
  }

  if (typeof filterVectorLayer === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterVectorLayer === layer.isType('vector');
    });
  }

  if (typeof filterHidden === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterHidden == layer.isHidden();
    });
  }

  if (typeof filterDisabled === 'boolean') {
    layers = layers.filter(function (layer) {
      return filterDisabled === layer.isDisabled();
    });
  }

  if (typeof filterServerType === 'string' && filterServerType !== '') {
    layers = layers.filter(function (layer) {
      return filterServerType === layer.getServerType();
    });
  }

  if (filterPrintable) {
    layers = layers.filter(function (layer) {
      return layer.state.geolayer && layer.isPrintable({
        scale: filterPrintable.scale
      });
    });
  }

  // return only not selected
  if (filterAllNotSelected) {
    layers = layers.filter(function (layer) {
      return !layer.isSelected();
    });
  }
  return layers;
};

// return layers array
proto.getLayers = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var layers = this.getLayersDict(options);
  return _.values(layers);
};

proto.getBaseLayers = function () {
  return this.getLayersDict({
    BASELAYER: true
  });
};

proto.getLayerById = function (layerId) {
  return this.getLayersDict()[layerId];
};

proto.getLayerByName = function (name) {
  return this._layers.find(function (layer) {
    return layer.getName() === name;
  });
};

proto.getLayerAttributes = function (layerId) {
  return this.getLayerById(layerId).getAttributes();
};

proto.getLayerAttributeLabel = function (layerId, name) {
  return this.getLayerById(layerId).getAttributeLabel(name);
};

proto.getGeoLayers = function () {
  return this.getLayers({
    GEOLAYER: true
  });
};

proto._getAllSiblingsChildrenLayersId = function (layerstree) {
  var nodeIds = [];
  var traverse = function traverse(layerstree) {
    layerstree.nodes.forEach(function (node) {
      if (node.id) nodeIds.push(node.id);else traverse(node);
    });
  };
  traverse(layerstree);
  return nodeIds;
};

proto._getAllParentLayersId = function (layerstree, node) {
  var nodeIds = [];
  var traverse = function traverse(layerstree) {
    layerstree.nodes.forEach(function (node) {
      if (node.id) nodeIds.push(node.id);else traverse(node);
    });
  };

  traverse({
    nodes: layerstree.nodes.filter(function (_node) {
      return _node !== node;
    })
  });
  return nodeIds;
};

proto._mutuallyExclude = function (layerId) {
  var _this4 = this;

  var parentLayersTree = this.state.layerstree;
  var traverse = function traverse(obj) {
    (0, _entries2.default)(obj).forEach(function (_ref3) {
      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
          key = _ref4[0],
          layer = _ref4[1];

      if (!_.isNil(layer.nodes)) {
        var found = layer.nodes.reduce(function (previous, node) {
          return node.id === layerId || previous;
        }, false);
        // if found mean that a found a group that contain layer with layerId
        if (found) {
          var checked_node = void 0;
          var nodeIds = [];
          layer.nodes.forEach(function (node) {
            if (node.id) {
              if (node.id !== layerId && node.geolayer) nodeIds.push(node.id);else checked_node = node;
            } else {
              nodeIds = nodeIds.concat(_this4._getAllSiblingsChildrenLayersId(node));
            }
          });
          if (parentLayersTree.mutually_exclusive) {
            nodeIds = nodeIds.concat(_this4._getAllParentLayersId(parentLayersTree));
          }
          _this4.setLayersVisible(nodeIds, false);
          parentLayersTree = layer;
        }
        traverse(layer.nodes);
      }
    });
  };
  traverse(this.state.layerstree);
};

proto.toggleLayer = function (layerId, visible, mutually_exclusive) {
  var layer = this.getLayerById(layerId);
  var checked = layer.isChecked();
  visible = visible !== null ? checked : !checked;
  mutually_exclusive && this._mutuallyExclude(layerId);
  if (layer.isDisabled()) layer.setVisible(false);else this.setLayersVisible([layerId], visible);
  layer.setChecked(!checked);
  return layer;
};

proto.toggleLayers = function (layersIds, visible) {
  var checked = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

  return this.setLayersVisible(layersIds, visible, checked);
};

proto.selectLayer = function (layerId) {
  this.setLayerSelected(layerId, true);
};

proto.unselectLayer = function (layerId) {
  this.setLayerSelected(layerId, false);
};

proto.getProjection = function () {
  return this.config.projection;
};

proto.getExtent = function () {
  return this.config.extent;
};

proto.getInitExtent = function () {
  return this.config.initextent;
};

proto.getWmsUrl = function () {
  return this.config.wmsUrl;
};

// set layersstree of layers inside the laysstore
proto.setLayersTree = function (layerstree, name) {
  var _this5 = this;

  var parentDisabled = false;
  var traverse = function traverse(obj) {
    (0, _entries2.default)(obj).forEach(function (_ref5) {
      var _ref6 = (0, _slicedToArray3.default)(_ref5, 2),
          key = _ref6[0],
          layer = _ref6[1];

      //check if lis layer and not a folder
      if (layer.id !== undefined) {
        obj[key] = _this5.getLayerById(layer.id).getState();
        obj[key].groupdisabled = parentDisabled;
      }
      if (layer.nodes) {
        traverse(layer.nodes);
      }
    });
  };
  if (layerstree.length) {
    traverse(layerstree);
    this.state.layerstree.splice(0, 0, {
      title: name || this.config.id,
      expanded: true,
      disabled: false,
      checked: true,
      nodes: layerstree
    });
  }
};

// used by from plugin (or external code) to build layerstree
// layer groupNem is a ProjectName
proto.createLayersTree = function (groupName) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var full = options.full || false;
  var _layerstree = options.layerstree || null;
  var layerstree = [];
  if (_layerstree) {
    if (full === true) {
      return this.state.layerstree;
    } else {
      var traverse = function traverse(obj, newobj) {
        _.forIn(obj, function (layer) {
          var lightlayer = {};
          if (!_.isNil(layer.id)) {
            lightlayer.id = layer.id;
          }
          if (!_.isNil(layer.nodes)) {
            lightlayer.title = layer.name;
            lightlayer.expanded = layer.expanded;
            lightlayer.nodes = [];
            lightlayer.checked = layer.checked;
            lightlayer.mutually_exclusive = layer["mutually-exclusive"];
            traverse(layer.nodes, lightlayer.nodes);
          }
          newobj.push(lightlayer);
        });
      };
      traverse(_layerstree, layerstree);
    }
  } else {
    var geoLayers = this.getGeoLayers();
    geoLayers.forEach(function (layer) {
      layerstree.push({
        id: layer.getId(),
        name: layer.getName(),
        title: layer.getTitle(),
        visible: layer.isVisible() || false
      });
    });
  }
  this.setLayersTree(layerstree, groupName);
};

proto.removeLayersTree = function () {
  this.state.layerstree.splice(0, this.state.layerstree.length);
};

proto.getLayersTree = function () {
  return this.state.layerstree;
};

module.exports = LayersStore;

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],591:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

// Registy Layers
function LayersStoresRegistry() {
  this.stores = {};
  this.storesArray = [];
  // to react some application components that are binding to Layerstore
  this.setters = {
    addLayersStore: function addLayersStore(layersStore, idx) {
      this._addLayersStore(layersStore, idx);
    },
    removeLayersStore: function removeLayersStore(layerStore) {
      this._removeLayersStore(layerStore);
    },
    removeLayersStores: function removeLayersStores() {
      this._removeLayersStores();
    }
  };

  base(this);
}

inherit(LayersStoresRegistry, G3WObject);

var proto = LayersStoresRegistry.prototype;

proto.getLayerById = function (layerId) {
  var layer = void 0;
  for (var storeId in this.stores) {
    var layerStore = this.stores[storeId];
    layer = layerStore.getLayerById(layerId);
    if (layer) break;
  }
  return layer;
};

proto.getLayers = function (filter) {
  var layers = [];
  (0, _entries2.default)(this.stores).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        storeId = _ref2[0],
        layersStore = _ref2[1];

    layers = layers.concat(layersStore.getLayers(filter));
  });
  return layers;
};

proto.getQuerableLayersStores = function () {
  return this.getLayersStores().filter(function (layersStore) {
    return layersStore.isQueryable();
  });
};

proto.getLayersStore = function (id) {
  return this.stores[id];
};

proto.getLayersStores = function () {
  var _this = this;

  var stores = [];
  this.storesArray.forEach(function (storeId) {
    stores.push(_this.stores[storeId]);
  });
  return stores;
};

proto._addLayersStore = function (layersStore, idx) {
  var storeId = layersStore.getId();
  this.stores[storeId] = layersStore;
  if (!_.isNil(idx)) {
    this.storesArray.splice(idx, 0, storeId);
  } else {
    this.storesArray.push(storeId);
  }
};

proto._removeLayersStore = function (layerStore) {
  if (layerStore) {
    var storeId = layerStore.getId();
    this.storesArray = this.storesArray.filter(function (_storeId) {
      return _storeId != storeId;
    });
    delete this.stores[storeId];
  }
};

proto._removeLayersStores = function () {
  this.storesArray = [];
  this.stores = {};
};

module.exports = LayersStoresRegistry;

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],592:[function(require,module,exports){
function ARGISMAPSERVERLegend(_ref) {
  var layer = _ref.layer,
      params = _ref.params;
  var _layer$getConfig$sour = layer.getConfig().source,
      url = _layer$getConfig$sour.url,
      layername = _layer$getConfig$sour.layer;

  var serviceUrl = url.replace('/rest/', '/');
  return serviceUrl + '/WMSServer?request=GetLegendGraphic&version=1.3.0&format=image/png&LAYER=' + layername;
};

module.exports = ARGISMAPSERVERLegend;

},{}],593:[function(require,module,exports){
var TYPES = {
  'wms': require('./wmslegend'),
  'argismapserver': require('./arcgismapserverlegend')
};

var Legendservice = {
  get: function get() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        layer = _ref.layer,
        params = _ref.params;

    var type = layer.isArcgisMapserver() ? 'argismapserver' : 'wms';
    return TYPES[type]({
      layer: layer,
      params: params
    });
  }
};

module.exports = Legendservice;

},{"./arcgismapserverlegend":592,"./wmslegend":594}],594:[function(require,module,exports){
function WMSLegend(_ref) {
  var layer = _ref.layer,
      params = _ref.params;
  var _params$color = params.color,
      color = _params$color === undefined ? "white" : _params$color,
      _params$fontsize = params.fontsize,
      fontsize = _params$fontsize === undefined ? 10 : _params$fontsize,
      _params$transparent = params.transparent,
      transparent = _params$transparent === undefined ? true : _params$transparent,
      boxspace = params.boxspace,
      layerspace = params.layerspace,
      _params$layertitle = params.layertitle,
      layertitle = _params$layertitle === undefined ? true : _params$layertitle,
      layertitlespace = params.layertitlespace,
      symbolspace = params.symbolspace,
      iconlabelspace = params.iconlabelspace,
      symbolwidth = params.symbolwidth,
      symbolheight = params.symbolheight,
      _params$sld_version = params.sld_version,
      sld_version = _params$sld_version === undefined ? '1.1.0' : _params$sld_version;

  var LAYER = layer.getWMSLayerName({
    type: 'legend'
  });
  var url = layer.getWmsUrl({ type: 'legend' });
  var sep = url.indexOf('?') > -1 ? '&' : '?';
  return ['' + url + sep + 'SERVICE=WMS&VERSION=1.3.0&REQUEST=GetLegendGraphic&SLD_VERSION=' + sld_version + '&WIDTH=300', '&FORMAT=image/png', '&TRANSPARENT=' + transparent, '&ITEMFONTCOLOR=' + color, '&LAYERFONTCOLOR=' + color, '&LAYERTITLE=' + layertitle, '&ITEMFONTSIZE=' + fontsize, '' + (boxspace ? '&BOXSPACE=' + boxspace : ''), '' + (layerspace ? '&LAYERSPACE=' + layerspace : ''), '' + (layertitlespace ? '&LAYERTITLESPACE=' + layertitlespace : ''), '' + (symbolspace ? '&SYMBOLSPACE=' + symbolspace : ''), '' + (iconlabelspace ? '&ICONLABELSPACE=' + iconlabelspace : ''), '' + (symbolwidth ? '&SYMBOLWIDTH=' + symbolwidth : ''), '' + (symbolheight ? '&SYMBOLHEIGHT=' + symbolheight : ''), '&LAYER=' + LAYER].join('');
}

module.exports = WMSLegend;

},{}],595:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var WMSLAYER = require('./wmslayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function ARCGISMAPSERVERLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  base(this, options, extraParams);
}

inherit(ARCGISMAPSERVERLayer, WMSLAYER);

var proto = ARCGISMAPSERVERLayer.prototype;

proto._makeOlLayer = function () {
  var _this = this;

  var config = {
    url: this.config.url,
    id: this.config.id,
    projection: this.config.projection,
    format: this.config.format
  };
  var olLayer = new RasterLayers.TiledArgisMapServer(config);
  olLayer.getSource().on('imageloadstart', function () {
    _this.emit("loadstart");
  });
  olLayer.getSource().on('imageloadend', function () {
    _this.emit("loadend");
  });

  olLayer.getSource().on('imageloaderror', function () {
    _this.emit("loaderror");
  });
  return olLayer;
};

module.exports = ARCGISMAPSERVERLayer;

},{"./wmslayer":599,"core/utils/utils":630,"g3w-ol3/src/layers/rasters":673}],596:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var VectorLayer = require('./vectorlayer');

function GeojsonLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var provider = options.provider;
  this.setProvider(provider);
  base(this, options);
  this.getFeatures({
    url: options.url,
    mapProjection: this.mapProjection
  });
}

inherit(GeojsonLayer, VectorLayer);

module.exports = GeojsonLayer;

},{"./vectorlayer":598,"core/utils//utils":630,"core/utils/utils":630}],597:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function MapLayer() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = config;
  this.id = config.id;
  this.projection = config.projection;
  base(this);
}

inherit(MapLayer, G3WObject);

var proto = MapLayer.prototype;

proto.getId = function () {
  return this.id;
};

proto.getOLLayer = function () {
  console.log('every sub classes has to be override');
};

module.exports = MapLayer;

},{"core/g3wobject":569,"core/utils/utils":630}],598:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var createOlLayer = require('core/utils/geo').createOlLayer;
var createLayerStyle = require('core/utils/geo').createLayerStyle;
var GUI = require('gui/gui');

var G3WObject = require('core/g3wobject');

function VectorLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.mapService = GUI.getComponent('map').getService();
  this.geometrytype = options.geometrytype || null;
  this.type = options.type || null;
  this.crs = options.crs || null;
  this.id = options.id;
  this.name = options.name || "";
  this.style = options.style;
  this.color = options.color;
  this.geometryType = options.geometryType;
  this.mapProjection = this.mapService.getProjection().getCode();
  this.projection = options.projection || this.mapProjection;
  this.url = options.url;
  this.data = options.data;
  this.provider = options.provider;
  this._olLayer = null;
}

inherit(VectorLayer, G3WObject);

module.exports = VectorLayer;

var proto = VectorLayer.prototype;

proto.setProvider = function (provider) {
  this._provider = provider;
};

proto.getProvider = function () {
  return this._provider;
};

proto._makeOlLayer = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      style = _ref.style;

  var _style = this._makeStyle(style);
  this._olLayer = new ol.layer.Vector({
    name: this.name,
    id: this.id,
    style: _style,
    source: new ol.source.Vector({})
  });
};

proto._makeStyle = function (styleConfig) {
  var style = void 0;
  var styles = {};
  if (styleConfig) {
    (0, _entries2.default)(styleConfig).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
          type = _ref3[0],
          config = _ref3[1];

      switch (type) {
        case 'point':
          if (config.icon) {
            styles.image = new ol.style.Icon({
              src: config.icon.url,
              imageSize: config.icon.width
            });
          }
          break;
        case 'line':
          styles.stroke = new ol.style.Stroke({
            color: config.color,
            width: config.width
          });
          break;
        case 'polygon':
          styles.fill = new ol.style.Fill({
            color: config.color
          });
          break;
      }
    });
    style = new ol.style.Style(styles);
  }
  return style;
};

proto.getFeatures = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  this.provider.getFeatures(options).then(function (features) {
    _this.addFeatures(features);
    d.resolve(features);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.addFeatures = function () {
  var features = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  this.getSource().addFeatures(features);
};

proto.addFeature = function (feature) {
  if (feature) {
    this.getSource().addFeature(feature);
  }
};

proto.getOLLayer = function () {
  if (this._olLayer) {
    return this._olLayer;
  } else {
    var id = this.id;
    var geometryType = this.geometryType;
    var color = this.color;
    var style = this.style ? createLayerStyle(this.style) : null;
    this._olLayer = createOlLayer({
      id: id,
      geometryType: geometryType,
      color: color,
      style: style
    });
  }
  return this._olLayer;
};

proto.setOLLayer = function (olLayer) {
  this._olLayer = olLayer;
};

proto.getSource = function () {
  if (!this._olLayer) this.getOLLayer();
  return this._olLayer.getSource();
};

proto.setSource = function (source) {
  this._olLayer.setSource(source);
};

proto.setStyle = function (style) {
  this._olLayer.setStyle(style);
};

proto.getFeatureById = function (fid) {
  if (fid) {
    return this._olLayer.getSource().getFeatureById(fid);
  }
};

proto.isVisible = function () {
  return this._olLayer.getVisible();
};

proto.setVisible = function (bool) {
  this._olLayer.setVisible(bool);
};

proto.clear = function () {
  this.getSource().clear();
};

proto.addToMap = function (map) {
  map.addLayer(this._olLayer);
};

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils/geo":629,"core/utils/utils":630,"gui/gui":710}],599:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var MapLayer = require('./maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function WMSLayer() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';

  this.LAYERTYPE = {
    LAYER: 'layer',
    MULTILAYER: 'multilayer'
  };
  this.extraParams = extraParams;
  this._method = method;
  this.layers = []; // store all enabled layers
  this.allLayers = []; // store all layers

  base(this, options);
}

inherit(WMSLayer, MapLayer);

var proto = WMSLayer.prototype;

proto.getOLLayer = function (withLayers) {
  if (!this._olLayer) this._olLayer = this._makeOlLayer(withLayers);
  return this._olLayer;
};

proto.getSource = function () {
  return this.getOLLayer().getSource();
};

proto.getInfoFormat = function () {
  return 'application/vnd.ogc.gml';
};

proto.getGetFeatureInfoUrl = function (coordinate, resolution, epsg, params) {
  return this.getOLLayer().getSource().getGetFeatureInfoUrl(coordinate, resolution, epsg, params);
};

proto.getLayerConfigs = function () {
  return this.layers;
};

proto.addLayer = function (layer) {
  if (!this.allLayers.find(function (_layer) {
    return layer === _layer;
  })) {
    this.allLayers.push(layer);
  }
  if (!this.layers.find(function (_layer) {
    return layer === _layer;
  })) {
    this.layers.push(layer);
  }
};

proto.removeLayer = function (layer) {
  this.layers = this.layers.filter(function (_layer) {
    return layer !== _layer;
  });
};

proto.toggleLayer = function (layer) {
  this.layers.forEach(function (_layer) {
    if (_layer.id === layer.id) {
      _layer.visible = layer.visible;
    }
  });
  this._updateLayers();
};

proto.update = function () {
  var mapState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  this._updateLayers(mapState, extraParams);
};

proto.isVisible = function () {
  return this._getVisibleLayers().length > 0;
};

proto.getQueryUrl = function () {
  var layer = this.layers[0];
  if (layer.infourl && layer.infourl !== '') {
    return layer.infourl;
  }
  return this.config.url;
};

proto.getQueryableLayers = function () {
  return this.layers.filter(function (layer) {
    return layer.isQueryable();
  });
};

proto._getVisibleLayers = function () {
  return this.layers.filter(function (layer) {
    return layer.isVisible();
  });
};

proto._makeOlLayer = function (withLayers) {
  var _this = this;

  var wmsConfig = {
    url: this.config.url,
    id: this.config.id,
    projection: this.config.projection
  };
  if (withLayers) {
    wmsConfig.layers = this.layers.map(function (layer) {
      return layer.getWMSLayerName();
    });
  }
  var representativeLayer = this.layers[0];
  if (representativeLayer) {
    wmsConfig.url = representativeLayer.getWmsUrl();
  }
  var olLayer = new RasterLayers.WMSLayer(wmsConfig, this.extraParams, this._method);

  olLayer.getSource().on('imageloadstart', function () {
    _this.emit("loadstart");
  });
  olLayer.getSource().on('imageloadend', function () {
    _this.emit("loadend");
  });

  olLayer.getSource().on('imageloaderror', function () {
    _this.emit("loaderror");
  });
  return olLayer;
};

proto.checkLayerDisabled = function (layer, resolution, mapUnits) {
  layer.setDisabled(resolution, mapUnits);
  return layer.isDisabled();
};

// check which layers has to be disabled
proto.checkLayersDisabled = function (resolution, mapUnits) {
  var _this2 = this;

  this.allLayers.forEach(function (layer) {
    _this2.checkLayerDisabled(layer, resolution, mapUnits);
  });
};

//update Layers
proto._updateLayers = function () {
  var mapState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var extraParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  //check disabled layers
  var mapUnits = mapState.mapUnits;

  this.checkLayersDisabled(mapState.resolution, mapUnits);
  var visibleLayers = this._getVisibleLayers(mapState) || [];
  if (visibleLayers.length > 0) {
    var prefix = visibleLayers[0].isArcgisMapserver() ? 'show:' : '';
    var params = {
      LAYERS: '' + prefix + visibleLayers.map(function (layer) {
        return layer.getWMSLayerName();
      }).join(',')
    };
    if (extraParams) params = _.assign(params, extraParams);
    this._olLayer.setVisible(true);
    this._olLayer.getSource().updateParams(params);
  } else this._olLayer.setVisible(false);
};

module.exports = WMSLayer;

},{"./maplayer":597,"core/utils/utils":630,"g3w-ol3/src/layers/rasters":673}],600:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var MapLayer = require('./maplayer');
var RasterLayers = require('g3w-ol3/src/layers/rasters');

function XYZLayer(options) {
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "GET";

  base(this, options);
  this._method = method;
  this.layer = null;
}

inherit(XYZLayer, MapLayer);

var proto = XYZLayer.prototype;

proto.getOLLayer = function () {
  var olLayer = this._olLayer;
  if (!olLayer) {
    olLayer = this._olLayer = this._makeOlLayer();
  }
  return olLayer;
};

proto.getSource = function () {
  return this.getOLLayer().getSource();
};

proto.getLayerConfigs = function () {
  return this.layer;
};

proto.addLayer = function (layer) {
  this.layer = layer;
};

proto.toggleLayer = function () {
  this._updateLayers();
};

proto.update = function (mapState, extraParams) {
  this._updateLayer(mapState, extraParams);
};

proto.isVisible = function () {
  return layer.state.visible;
};

proto._makeOlLayer = function () {
  var _this = this;

  var projection = this.projection ? this.projection : this.layer.getProjection();
  var layerOptions = {
    url: this.layer.getCacheUrl() + "/{z}/{x}/{y}.png",
    maxZoom: 20
  };

  layerOptions.projection = projection;
  this._olLayer = new RasterLayers.XYZLayer(layerOptions, this._method);

  this._olLayer.getSource().on('imageloadstart', function () {
    _this.emit("loadstart");
  });
  this._olLayer.getSource().on('imageloadend', function () {
    _this.emit("loadend");
  });
  this._olLayer.getSource().on('imageloaderror', function () {
    _this.emit("loaderror");
  });

  return this._olLayer;
};

proto._updateLayer = function (mapState, extraParams) {
  this._olLayer.setVisible(this.layer.isVisible());
};

module.exports = XYZLayer;

},{"./maplayer":597,"core/utils/utils":630,"g3w-ol3/src/layers/rasters":673}],601:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Provider = require('core/layers/providers/provider');

function GEOJSONDataProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._name = 'geojson';
  this.provider = options.provider;
}

inherit(GEOJSONDataProvider, Provider);

var proto = GEOJSONDataProvider.prototype;

proto.query = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  d.resolve([]);
  return d.promise();
};

proto.getFeatures = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var url = options.url || this.getLayer().get('source').url;
  var data = options.data;
  var projection = options.projection || "EPSG:4326";
  var mapProjection = options.mapProjection;
  var parseFeatures = function parseFeatures(data) {
    var parser = new ol.format.GeoJSON();
    return parser.readFeatures(data, {
      featureProjection: mapProjection,
      defaultDataProjection: projection
    });
  };
  if (data) {
    var features = parseFeatures(data);
    d.resolve(features);
  } else {
    $.get({ url: url }).then(function (response) {
      var features = parseFeatures(response.results);
      d.resolve(features);
    }).fail(function (err) {
      d.reject(err);
    });
  }
  return d.promise();
};

proto.getDataTable = function () {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      page = _ref.page;

  var d = $.Deferred();
  this.getFeatures().then(function () {
    d.resolve(_this._features);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.digestFeaturesForTable = function () {
  return {
    headers: [],
    features: []
  };
};

module.exports = GEOJSONDataProvider;

},{"core/layers/providers/provider":603,"core/utils/utils":630}],602:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function KMLDataProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._name = 'kml';
}

inherit(KMLDataProvider, DataProvider);

var proto = KMLDataProvider.prototype;

proto.getData = function () {
  var d = $.Deferred();
  return d.promise();
};

module.exports = KMLDataProvider;

},{"core/layers/providers/provider":603,"core/utils/utils":630}],603:[function(require,module,exports){
var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var geoutils = require('g3w-ol3/src/utils/utils');
var G3WObject = require('core/g3wobject');
var convert = require('xml-js');
var WORD_NUMERIC_XML_TAG_ESCAPE = 'GIS3W_ESCAPE_NUMERIC_';

function Provider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._isReady = false;
  this._name = 'provider';
  this._layer = options.layer;
  base(this);
}

inherit(Provider, G3WObject);

var proto = Provider.prototype;

proto.getLayer = function () {
  return this._layer;
};

proto.setLayer = function (layer) {
  this._layer = layer;
};

proto.getFeatures = function () {
  console.log('overwriteby single provider');
};

proto.query = function () {
  console.log('overwriteby single provider');
};

proto.setReady = function (bool) {
  this._isReady = bool;
};

proto.isReady = function () {
  return this._isReady;
};

proto.error = function () {
  //TODO
};

proto.isValid = function () {
  console.log('overwriteby single provider');
};

proto.getName = function () {
  return this._name;
};

// to extract gml from multiple (Tuscany region)
proto.extractGML = function (response) {
  if (response.substr(0, 2) !== '--') return response;
  var gmlTag1 = new RegExp("<([^ ]*)FeatureCollection");
  var gmlTag2 = new RegExp("<([^ ]*)msGMLOutput");
  var boundary = '\r\n--';
  var parts = response.split(new RegExp(boundary));
  parts.forEach(function (part) {
    isGmlPart = part.search(gmlTag1) > -1 ? true : part.search(gmlTag2) > -1 ? true : false;
    if (isGmlPart) {
      var gml = part.substr(part.indexOf("<?xml"));
      return gml;
    }
  });
};

// Method to transform xml from server to present to queryreult component
proto.handleQueryResponseFromServer = function (response, projections, layers) {
  var _this = this;

  var wms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

  layers = layers ? layers : [this._layer];
  var layer = layers[0];
  var infoFormat = layer.getInfoFormat();
  switch (infoFormat) {
    case 'json':
      return this._parseGeoJsonResponse({
        layer: layer,
        response: response,
        projections: projections
      });
      break;
    default:
      if (layer.getType() === "table" || !layer.isExternalWMS() || !layer.isLayerProjectionASMapProjection()) {
        response = this._handleXMLStringResponseBeforeConvertToJSON({
          layers: layers,
          response: response,
          wms: wms
        });
        return this._getHandledResponsesFromResponse({
          response: response,
          layers: layers,
          projections: projections
          //id: false //used in case of layer id .. but for now is set to false in case of layerid starting with number
        });
      } else {
        //case of
        if (/msGMLOutput/.test(response)) {
          return layers.map(function (layer) {
            var layers = layer.getQueryLayerOrigName();
            var parser = new ol.format.WMSGetFeatureInfo({
              layers: layers
            });
            var features = parser.readFeatures(response);
            return {
              layer: layer,
              features: features
            };
          });
        } else {
          return layers.map(function (layer) {
            return _this._handleWMSMultilayers({
              layer: layer,
              response: response,
              projections: projections
            });
          });
        }
      }
  }
};

proto._parseGeoJsonResponse = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      layer = _ref.layer,
      response = _ref.response,
      projections = _ref.projections;

  var data = response.vector && response.vector.data;
  var features = data && this._parseLayerGeoJSON(data, projections) || [];
  return [{
    layer: layer,
    features: features
  }];
};

proto._handleWMSMultilayers = function () {
  var _this2 = this;

  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      layer = _ref2.layer,
      response = _ref2.response,
      projections = _ref2.projections;

  var x2js = new X2JS();
  var arrayQGS = [].concat((0, _toConsumableArray3.default)(response.matchAll(/<qgs:(\w+) fid=/g)));
  var alreadySubstitute = [];
  arrayQGS.forEach(function (element) {
    var fid = element[1];
    if (alreadySubstitute.indexOf(fid) === -1) {
      alreadySubstitute.push(fid);
      var startfid = +fid[0];
      if ((0, _isInteger2.default)(startfid)) response = response.replace(new RegExp('' + fid, "g"), '' + WORD_NUMERIC_XML_TAG_ESCAPE + fid);
    }
  });
  var jsonresponse = x2js.xml_str2json(response);
  // in case of parser return null
  if (!jsonresponse) return [{
    layer: layer,
    features: []
  }];
  var FeatureCollection = jsonresponse.FeatureCollection;
  var handledResponses = [];
  if (FeatureCollection.featureMember) {
    var originalFeatureMember = Array.isArray(FeatureCollection.featureMember) ? FeatureCollection.featureMember : [FeatureCollection.featureMember];
    var layersNames = new _set2.default();
    originalFeatureMember.forEach(function (featureMember) {
      layersNames.add((0, _keys2.default)(featureMember)[0]);
    });

    var _loop = function _loop(layerName) {
      jsonresponse.FeatureCollection.featureMember = originalFeatureMember.filter(function (feature) {
        return feature[layerName];
      });
      var handledResponse = _this2._parseLayerFeatureCollection({
        jsonresponse: jsonresponse,
        layer: layer,
        projections: projections
      });
      if (handledResponse) {
        var _response = handledResponse[0];
        _response.layer = layerName.replace(WORD_NUMERIC_XML_TAG_ESCAPE, '');
        handledResponses.unshift(_response);
      }
    };

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(layersNames), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var layerName = _step.value;

        _loop(layerName);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
  return handledResponses;
};

proto._groupFeaturesByFields = function (features) {
  return _.groupBy(features, function (feature) {
    return (0, _keys2.default)(feature);
  });
};

proto._handleWMSMultiLayersResponseFromQGISSERVER = function () {
  var _this3 = this;

  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      groupFeatures = _ref3.groupFeatures,
      prefix = _ref3.prefix,
      handledResponses = _ref3.handledResponses,
      jsonresponse = _ref3.jsonresponse,
      layer = _ref3.layer,
      projections = _ref3.projections;

  // is a multilayers. Each feature has different fields
  (0, _keys2.default)(groupFeatures).forEach(function (key, index) {
    var _jsonresponse$Feature;

    var features = groupFeatures[key];
    jsonresponse.FeatureCollection.featureMember = (_jsonresponse$Feature = {}, (0, _defineProperty3.default)(_jsonresponse$Feature, 'layer' + index, features), (0, _defineProperty3.default)(_jsonresponse$Feature, '__prefix', prefix), _jsonresponse$Feature);
    var handledResponse = _this3._parseLayerFeatureCollection({
      jsonresponse: jsonresponse,
      layer: layer,
      projections: projections
    });
    if (handledResponse) {
      var response = handledResponse[0];
      response.layer = layer;
      handledResponses.unshift(response);
    }
  });
};

proto._getHandledResponsesFromResponse = function (_ref4) {
  var _this4 = this;

  var response = _ref4.response,
      layers = _ref4.layers,
      projections = _ref4.projections,
      _ref4$id = _ref4.id,
      id = _ref4$id === undefined ? false : _ref4$id;

  var multilayers = false;
  var x2js = new X2JS();
  var jsonresponse = x2js.xml_str2json(response);
  // in case of parser return null
  if (!jsonresponse) return [{
    layer: layers[0],
    features: []
  }];
  var FeatureCollection = jsonresponse.FeatureCollection;
  var handledResponses = [];
  if (FeatureCollection.featureMember) {
    var originalFeatureMember = Array.isArray(FeatureCollection.featureMember) ? FeatureCollection.featureMember : [FeatureCollection.featureMember];

    var _loop2 = function _loop2(i) {
      var layer = layers[i];
      var layerName = id ? layer.getId() : 'layer' + i;
      var featureMemberArrayAndPrefix = {
        features: null,
        __prefix: null
      };
      jsonresponse.FeatureCollection.featureMember = originalFeatureMember.filter(function (feature) {
        var featureMember = feature[layerName];
        if (featureMember) {
          if (Array.isArray(featureMember)) {
            featureMemberArrayAndPrefix.features = featureMember;
            featureMemberArrayAndPrefix.__prefix = feature.__prefix;
            return false;
          }
          return true;
        }
      });
      if (featureMemberArrayAndPrefix.features) {
        var prefix = featureMemberArrayAndPrefix.__prefix;
        // check if features have the same fields. If not group the featues with the same fields
        var groupFeatures = _this4._groupFeaturesByFields(featureMemberArrayAndPrefix.features);
        //check if features have different fields (multilayers)
        if ((0, _keys2.default)(groupFeatures).length > 1) {
          // is a multilayers. Each feature has different fields
          multilayers = true;
          _this4._handleWMSMultiLayersResponseFromQGISSERVER({
            groupFeatures: groupFeatures,
            prefix: prefix,
            handledResponses: handledResponses,
            jsonresponse: jsonresponse,
            layer: layer,
            projections: projections
          });
        } else {
          featureMemberArrayAndPrefix.features.forEach(function (feature) {
            var _jsonresponse$Feature2;

            //for Each element have to add and object contain layerName and information, and __prefix
            jsonresponse.FeatureCollection.featureMember.push((_jsonresponse$Feature2 = {}, (0, _defineProperty3.default)(_jsonresponse$Feature2, layerName, feature), (0, _defineProperty3.default)(_jsonresponse$Feature2, '__prefix', prefix), _jsonresponse$Feature2));
          });
        }
      }
      if (!multilayers) {
        var _handledResponse = _this4._parseLayerFeatureCollection({
          jsonresponse: jsonresponse,
          layer: layer,
          projections: projections
        });
        _handledResponse && handledResponses.unshift(_handledResponse[0]);
      }
    };

    for (var i = 0; i < layers.length; i++) {
      _loop2(i);
    }
  }
  return handledResponses;
};

proto._handleXMLStringResponseBeforeConvertToJSON = function (_ref5) {
  var response = _ref5.response,
      layers = _ref5.layers,
      wms = _ref5.wms;

  if (!(typeof response === 'string' || response instanceof String)) response = new XMLSerializer().serializeToString(response);
  for (var i = 0; i < layers.length; i++) {
    var _layer = layers[i];
    var originalName = wms && _layer.isWmsUseLayerIds() ? _layer.getId() : _layer.getName();
    var sanitizeLayerName = wms ? originalName.replace(/[/\s]/g, '') : originalName.replace(/[/\s]/g, '_');
    sanitizeLayerName = sanitizeLayerName.replace(/(\'+)/, '');
    sanitizeLayerName = sanitizeLayerName.replace(/(\)+)/, '');
    sanitizeLayerName = sanitizeLayerName.replace(/(\(+)/, '');
    var reg = new RegExp('qgs:' + sanitizeLayerName + '\\b', "g");
    response = response.replace(reg, 'qgs:layer' + i);
  }
  return response;
};

// digest result
proto.digestFeaturesForLayers = function (featuresForLayers) {
  var _this5 = this;

  var id = 0;
  var layers = [];
  var layerAttributes = void 0,
      layerTitle = void 0,
      layerId = void 0;
  featuresForLayers.forEach(function (featuresForLayer) {
    featuresForLayer = featuresForLayer;
    var layer = featuresForLayer.layer;
    layerAttributes = layer.getAttributes();
    layerTitle = layer.getTitle();
    layerId = layer.getId();

    var layerObj = {
      title: layerTitle,
      id: layerId,
      attributes: [],
      features: [],
      hasgeometry: false,
      show: true,
      expandable: true,
      hasImageField: false, // check if image filed exist
      error: ''
    };

    // check if exist feature related to the layer
    if (featuresForLayer.features && featuresForLayer.features.length) {
      // get aonly attributes returned by WMS (using the first feature availble)
      layerObj.attributes = _this5._parseAttributes(layerAttributes, featuresForLayer.features[0].getProperties());
      // check if exist image field
      layerObj.attributes.forEach(function (attribute) {
        if (attribute.type === 'image') {
          layerObj.hasImageField = true;
        }
      });
      // loop throught selected features from query result
      featuresForLayer.features.forEach(function (feature) {
        var fid = feature.getId() ? feature.getId() : id;
        var geometry = feature.getGeometry();
        // check if feature has geometry
        if (geometry) {
          // set to true it used by action
          layerObj.hasgeometry = true;
        }
        // create feature object
        var featureObj = {
          id: fid,
          attributes: feature.getProperties(),
          geometry: feature.getGeometry(),
          show: true
        };
        layerObj.features.push(featureObj);
        id += 1;
      });
      layers.push(layerObj);
    } else if (featuresForLayer.error) {
      layerObj.error = featuresForLayer.error;
    }
  });
  return layers;
};

proto._parseAttributes = function (layerAttributes, featureAttributes) {
  var featureAttributesNames = _.keys(featureAttributes);
  featureAttributesNames = _.filter(featureAttributesNames, function (featureAttributesName) {
    return ['boundedBy', 'geom', 'the_geom', 'geometry', 'bbox', 'GEOMETRY'].indexOf(featureAttributesName) === -1;
  });
  if (layerAttributes && layerAttributes.length) {
    var _featureAttributesNames = _.keys(featureAttributes);
    return _.filter(layerAttributes, function (attribute) {
      return _featureAttributesNames.indexOf(attribute.name) > -1;
    });
  } else {
    return _.map(featureAttributesNames, function (featureAttributesName) {
      return {
        name: featureAttributesName,
        label: featureAttributesName
      };
    });
  }
};

proto._tranformFeatures = function (features, projections) {
  if (features.length) {
    if (!!features[0].getGeometry()) {
      var mainProjection = projections.layer ? projections.layer : projections.map;
      var invertedAxis = mainProjection.getAxisOrientation().substr(0, 2) === 'ne';
      if (projections.layer && projections.layer.getCode() !== projections.map.getCode()) {
        features.forEach(function (feature) {
          var geometry = feature.getGeometry();
          feature.setGeometry(geometry.transform(projections.layer.getCode(), projections.map.getCode()));
        });
      }
      if (invertedAxis) features = this._reverseFeaturesCoordinates(features);
    }
  }
  return features;
};

proto._parseLayerFeatureCollection = function (_ref6) {
  var jsonresponse = _ref6.jsonresponse,
      layer = _ref6.layer,
      projections = _ref6.projections;

  var x2js = new X2JS();
  var layerFeatureCollectionXML = x2js.json2xml_str(jsonresponse);
  var parser = new ol.format.WMSGetFeatureInfo();
  var features = this._tranformFeatures(parser.readFeatures(layerFeatureCollectionXML), projections);
  return [{
    layer: layer,
    features: features
  }];
};

proto._reverseFeaturesCoordinates = function (features) {
  features.forEach(function (feature) {
    var geometry = feature.getGeometry();
    feature.setGeometry(geoutils.reverseGeometry(geometry));
  });
  return features;
};

proto._parseLayermsGMLOutput = function (data) {
  var layers = this._layer.getQueryLayerOrigName();
  var parser = new ol.format.WMSGetFeatureInfo({
    layers: layers
  });
  return parser.readFeatures(data);
};

proto._parseLayerGeoJSON = function (data, projections) {
  var defaultDataProjection = projections.layer || projections.map;
  var geojson = new ol.format.GeoJSON({
    defaultDataProjection: defaultDataProjection,
    geometryName: "geometry"
  });
  return geojson.readFeatures(data);
};

module.exports = Provider;

},{"babel-runtime/core-js/get-iterator":4,"babel-runtime/core-js/number/is-integer":7,"babel-runtime/core-js/object/keys":14,"babel-runtime/core-js/set":17,"babel-runtime/helpers/defineProperty":21,"babel-runtime/helpers/toConsumableArray":24,"core/g3wobject":569,"core/utils/utils":630,"g3w-ol3/src/utils/utils":678,"xml-js":519}],604:[function(require,module,exports){
var Providers = {
  geojson: require('./geojsonprovider'),
  kml: require('./kmlprovider'),
  xml: require('./xmlprovider'),
  qgis: require('./qgisprovider'),
  wms: require('./wmsprovider'),
  wfs: require('./wfsprovider')
};

var ProvidersForServerTypes = {
  'QGIS': {
    'postgres': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis,
      search: Providers.qgis
    },
    'spatialite': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis,
      search: Providers.qgis
    },
    'ogr': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null,
      search: Providers.qgis
    },
    'delimitedtext': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.qgis,
      search: Providers.qgis
    },
    'wms': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: null,
      search: null
    },
    'wfs': {
      query: Providers.wms,
      filter: Providers.wfs,
      data: Providers.wfs,
      search: Providers.qgis
    },
    'gdal': {
      query: Providers.wms,
      filter: null,
      data: null,
      search: null
    },
    'arcgismapserver': {
      query: Providers.wms,
      filter: null,
      data: null,
      search: null
    }
  },
  'OGC': {
    'wms': {
      query: Providers.wms,
      filter: null,
      data: null,
      search: null
    }
  },
  'G3WSUITE': {
    'geojson': {
      query: Providers.geojson,
      filter: null,
      data: Providers.geojson,
      search: null
    }
  }
};

function ProviderFactory() {
  this.build = function (providerType, serverType, sourceType, options) {
    // return instace of seletced provider
    var providerClass = this.get(providerType, serverType, sourceType);
    if (providerClass) {
      return new providerClass(options);
    }
    return null;
  };

  this.get = function (providerType, serverType, sourceType) {
    return ProvidersForServerTypes[serverType][sourceType][providerType];
  };
}

module.exports = new ProviderFactory();

},{"./geojsonprovider":601,"./kmlprovider":602,"./qgisprovider":605,"./wfsprovider":606,"./wmsprovider":607,"./xmlprovider":609}],605:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var XHR = require('core/utils/utils').XHR;
var t = require('core/i18n/i18n.service').t;
var DataProvider = require('core/layers/providers/provider');
var Feature = require('core/layers/features/feature');
var Parsers = require('core/parsers/parsers');

function QGISProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  this._name = 'qgis';
  this._layer = options.layer || {};
  this._projections = {
    map: null,
    layer: null
  };
  this._unlockUrl = this._layer.getUrl('unlock');
  // url referred to query
  this._queryUrl = this._layer.getUrl('query');
  // editing url api
  this._editingUrl = this._layer.getUrl('editing');
  this._commitUrl = this._layer.getUrl('commit');
  // url to get configuration
  this._configUrl = this._layer.getUrl('config');
  // widget url
  this._widgetUrls = this._layer.getUrl('widget');
  // layer name
  this._layerName = this._layer.getName() || null; // get name  from QGIS layer, because the query are proxed from g3w-server
  this._infoFormat = this._layer.getInfoFormat() || 'application/vnd.ogc.gml';
}

inherit(QGISProvider, DataProvider);

var proto = QGISProvider.prototype;

//query by filter
proto.query = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var feature_count = options.feature_count || 10;
  var filter = options.filter || null;
  var isVector = this._layer.getType() !== "table";
  if (isVector) {
    this._projections.layer = this._layer.getProjection();
    this._projections.map = this._layer.getMapProjection() || this._projections.layer;
  }
  var crs = isVector ? this._layer.getSourceType() === 'spatialite' ? 'EPSG:' + this._layer.getCrs() : this._projections.map.getCode() : null;
  var queryUrl = options.queryUrl || this._queryUrl;
  var layers = options.layers;
  var I = options.I,
      J = options.J;

  var layerNames = layers ? layers.map(function (layer) {
    return layer.getWMSLayerName();
  }).join(',') : this._layer.getWMSLayerName();
  if (filter) {
    // check if geomemtry filter. If not i have to remove projection layer
    if (filter.getType() !== 'geometry' && this._layer.getSourceType() !== 'spatialite') this._projections.layer = null;
    var url = queryUrl;
    var params = {
      SERVICE: 'WMS',
      VERSION: '1.3.0',
      REQUEST: 'GetFeatureInfo',
      LAYERS: layerNames,
      QUERY_LAYERS: layerNames,
      INFO_FORMAT: this._infoFormat,
      FEATURE_COUNT: feature_count,
      CRS: crs,
      I: I,
      J: J,
      FILTER: filter.get(),
      WITH_GEOMETRY: isVector ? 1 : 0
    };

    XHR.get({
      url: url,
      params: params
    }).then(function (response) {
      var featuresForLayers = _this.handleQueryResponseFromServer(response, _this._projections, layers);
      d.resolve(featuresForLayers);
    }).catch(function (err) {
      d.reject(err);
    });
  }
  return d.promise();
};

// get layer config
proto.getConfig = function () {
  var d = $.Deferred();
  var url = this._configUrl;
  if (!url) {
    d.reject('Url non valido');
    return;
  }
  $.get(url).then(function (config) {
    d.resolve(config);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.getWidgetData = function (options) {
  options = options || {};
  var type = options.type;
  var fields = options.fields;
  var url = this._widgetUrls[type];
  return $.get(url, {
    fields: fields
  });
};

// unlock feature
proto.unlock = function () {
  var d = $.Deferred();
  $.post(this._unlockUrl).then(function (response) {
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

// commit function
proto.commit = function (commitItems) {
  var d = $.Deferred();
  //check if editing or not;
  var url = this._commitUrl;
  var jsonCommits = (0, _stringify2.default)(commitItems);
  $.post({
    url: url,
    data: jsonCommits,
    contentType: "application/json"
  }).then(function (response) {
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

// METODS LOADING EDITING FEATURES (READ/WRITE) //
proto.getFeatures = function () {
  var _this2 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var d = $.Deferred();
  // filter null value
  (0, _entries2.default)(params).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        key = _ref2[0],
        value = _ref2[1];

    if (value === null) delete params[key];
  });
  var layerType = options.type || 'vector'; //layer type vector/table etc
  // check if data are requested in read or write mode;
  var url = void 0;
  //editing mode
  if (options.editing) {
    url = this._editingUrl;
    var filter = options.filter || null;
    if (filter && filter.bbox) {
      var bbox = filter.bbox;
      filter = { in_bbox: bbox[0] + ',' + bbox[1] + ',' + bbox[2] + ',' + bbox[3] };
    }
    var pk = this._layer.getPk();
    if (!url) {
      d.reject('Url non valido');
      return;
    }
    var features = [];
    var jsonFilter = (0, _stringify2.default)(filter);
    var urlParams = $.param(params);
    url += urlParams ? '?' + urlParams : '';
    $.post({
      url: url,
      data: jsonFilter,
      contentType: "application/json"
    }).then(function (response) {
      var vector = response.vector,
          result = response.result,
          featurelocks = response.featurelocks;

      if (result) {
        var data = vector.data,
            geometrytype = vector.geometrytype;

        var parser = Parsers[layerType].get({
          type: 'json',
          pk: pk
        });
        var parser_options = geometrytype !== 'No geometry' ? { crs: _this2._layer.getCrs() } : {};
        var lockIds = featurelocks.map(function (featureLock) {
          return featureLock.featureid;
        });
        parser(data, parser_options).forEach(function (feature) {
          var featureId = '' + feature.getId();
          if (lockIds.indexOf(featureId) > -1) {
            features.push(new Feature({
              feature: feature,
              pk: pk
            }));
          }
        });
        // resolve with featers locked and requested
        d.resolve({
          features: features,
          featurelocks: featurelocks
        });
      } else {
        // case when server responde with result false (error)
        d.reject({
          message: t("info.server_error")
        });
      }
    }).fail(function (err) {
      d.reject({
        message: t("info.server_error")
      });
    });
  } else {
    url = this._layer.getUrl('data');
    var _urlParams = $.param(params);
    url += _urlParams ? '?' + _urlParams : '';
    $.get({
      url: url,
      contentType: "application/json"
    }).then(function (response) {
      var vector = response.vector;
      var pk = vector.pk;
      var data = vector.data;
      count = vector.count;
      d.resolve({
        data: data,
        pk: pk,
        count: count
      });
    }).fail(function (err) {
      d.reject(err);
    });
  }

  return d.promise();
};

// main function, starting point, is called to get vector data
proto._loadLayerData = function (mode, customUrlParameters) {
  var _this3 = this,
      _arguments = arguments;

  var d = $.Deferred();
  //verifica se sono stati caricati i vettoriali dei layer
  // attraverso la propriet vector del layer passato dal plugin
  Obkect.entries(this._layers).forEach(function (_ref3) {
    var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
        layerCode = _ref4[0],
        layer = _ref4[1];

    // verifico se l'attributo vector  nullo
    if (_.isNull(layer.vector)) {
      noVectorlayerCodes.push(layerCode);
    }
  });
  // eseguo le richieste delle configurazioni e mi tengo le promesse
  var vectorLayersSetup = noVectorlayerCodes.map(function (layerCode) {
    return _this3._setupVectorLayer(layerCode);
  });
  // emetto l'evento loadingvectorlayersstart (il pluginservice  in ascolto)
  this.emit('loadingvectorlayersstart');
  // aspetto tutte le promesse del setup vector
  $.when.apply(this, vectorLayersSetup)
  // una volta che tutte le configurazioni dei layer vecor
  // sono state prese dal server e dopo aver assegnato all'attributo vector
  // del layer plugin il layer vettoriale costruito con le configurazioni
  // di sopra
  .then(function () {
    // le promesse ritornano il layerCode del layer vettoriale appena costuito
    var vectorLayersCodes = Array.prototype.slice.call(_arguments);
    // emtto evento che inzia il recupero dei dati dei layer vettoriali (geojson)
    _this3.emit('loadingvectolayersdatastart');
    // inizio a caricare tutti i vettoriali dopo aver caricato le configurazioni
    _this3.loadAllVectorsData(vectorLayersCodes).then(function () {
      _this3._vectorLayersCodes = vectorLayersCodes;
      d.resolve(vectorLayersCodes);
      // emtto evento che ho ricevuto i layers
      _this3.emit('loadingvectorlayersend');
      // ora il loader  pronto
      _this3.setReady(true);
    }).fail(function () {
      // risetto tutti i layer veetotiali a null
      _this3._layers.forEach(function (layer) {
        layer.vector = null;
      });
      d.reject();
      // emttto che c' stato un errore nel loading dei dati che vengono dal server
      _this3.emit('errorloadingvectorlayersend');
      _this3.setReady(false);
    });
  }).fail(function () {
    _this3.setReady(false);
    _this3.emit('errorloadingvectorlayersend');
    d.reject();
  });
  return d.promise();
};

proto.setVectorLayersCodes = function (vectorLayersCodes) {
  this._vectorLayersCodes = vectorLayersCodes;
};

proto.getVectorLayersCodes = function () {
  return this._vectorLayersCodes;
};

proto.getLayers = function () {
  return this._layers;
};

// funzione che fa il reload che rihiede di nuovo il dati del vetor layer
// caso in cui si lavora con un layer vettoriale e non si usa un wms per fare la query
proto.reloadVectorData = function (layerCode) {
  var _this4 = this;

  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  this._createVectorLayerFromConfig(layerCode).then(function (vectorLayer) {
    _this4._getVectorLayerData(vectorLayer, bbox).then(function (vectorDataResponse) {
      _this4.setVectorLayerData(vectorLayer[_this4._editingApiField], vectorDataResponse);
      vectorLayer.setData(vectorDataResponse.vector.data);
      d.resolve(vectorLayer);
    });
  });
  return d.promise();
};

//funzione che permette di ottenere tutti i dati relativi ai layer vettoriali caricati
//prima si  ottenuta la coinfigurazione, ora si ottengono i dati veri e propri
proto.loadAllVectorsData = function (layerCodes) {
  var _this5 = this;

  var d = $.Deferred();
  var layers = this._layers;
  // verifico che il BBOX attuale non sia stato gi  caricato
  // prondo il bbox
  var bbox = this._mapService.state.bbox;
  var loadedExtent = this._loadedExtent;
  if (loadedExtent && ol.extent.containsExtent(loadedExtent, bbox)) {
    return resolvedValue();
  }
  if (!loadedExtent) {
    this._loadedExtent = bbox;
  } else {
    this._loadedExtent = ol.extent.extend(loadedExtent, bbox);
  }
  if (layerCodes) {
    layers = [];
    layerCodes.forEach(function (layerCode) {
      layers.push(_this5._layers[layerCode]);
    });
  }
  //per ogni layer del plugin che non ha il layer vado a caricare i dati del layer vettoriale
  var vectorDataRequests = layers.map(function (Layer) {
    return _this5._loadVectorData(Layer.vector, bbox);
  });

  $.when.apply(this, vectorDataRequests).then(function () {
    d.resolve(layerCodes);
  }).fail(function () {
    d.reject();
  });

  return d.promise();
};

proto._setCustomUrlParameters = function (customUrlParameters) {
  this._customUrlParameters = customUrlParameters;
};

proto._checkVectorGeometryTypeFromConfig = function (vectorConfig) {
  switch (vectorConfig.geometrytype) {
    case 'Line':
      vectorConfig.geometrytype = 'LineString';
      break;
    case 'MultiLine':
      vectorConfig.geometrytype = 'MultiLineString';
      break;
  }
  return vectorConfig;
};

proto._createVectorLayerFromConfig = function (layerCode) {
  var _this6 = this;

  // recupero la configurazione del layer settata da plugin service
  var layerConfig = this._layers[layerCode];
  var d = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._getVectorLayerConfig(layerConfig[this._editingApiField]).then(function (vectorConfigResponse) {
    var vectorConfig = vectorConfigResponse.vector;
    // vado a verificare la correttezza del geometryType (caso di editing generico)
    vectorConfig = _this6._checkVectorGeometryTypeFromConfig(vectorConfig);
    // una volta ottenuta dal server la configurazione vettoriale,
    // provvedo alla creazione del layer vettoriale
    var crsLayer = layerConfig.crs || _this6._mapService.getProjection().getCode();
    var vectorLayer = _this6._createVectorLayer({
      geometrytype: vectorConfig.geometrytype,
      format: vectorConfig.format,
      crs: _this6._mapService.getProjection().getCode(),
      crsLayer: crsLayer,
      id: layerConfig.id,
      name: layerConfig.name,
      pk: vectorConfig.pk,
      editing: self._editingMode
    });
    // setto i campi del layer
    vectorLayer.setFields(vectorConfig.fields);
    vectorLayer.setCrs(crsLayer);
    // questo  la propriet della configurazione del config layer
    // che specifica se esistono relazioni con altri layer
    // sono array di oggetti che specificano una serie di
    // informazioni su come i layer sono relazionati (nome della relazione == nome layer)
    // foreign key etc ..
    var relations = vectorConfig.relations;
    // nel caso il layer abbia relazioni (array non vuoto)
    if (relations) {
      // per dire a vectorLayer che i dati
      // delle relazioni verranno caricati solo quando
      // richiesti (es. aperture form di editing)
      vectorLayer.lazyRelations = true;
      //vado a settare le relazioni del vector layer
      vectorLayer.setRelations(relations);
    }
    // setto lo stile del layer OL
    if (layerConfig.style) {
      vectorLayer.setStyle(layerConfig.style);
    }
    // risolve con il nome del vectorLayer
    d.resolve(vectorLayer);
  }).fail(function () {
    d.reject();
  });
  return d.promise();
};

// funzione che dato la configurazione del layer fornito dal plugin (style, editor, vctor etc..)
// esegue richieste al server al fine di ottenere configurazione vettoriale del layer
proto._setupVectorLayer = function (layerCode) {
  var _this7 = this;

  var d = $.Deferred();
  // eseguo le richieste delle configurazioni
  this._createVectorLayerFromConfig(layerCode).then(function (vectorLayer) {
    var layerConfig = _this7._layers[layerCode];
    // assegno il vetorLayer appena creato all'attributo vector del layer
    layerConfig.vector = vectorLayer;
    // risolve con il nome del layerCode
    d.resolve(layerCode);
  }).fail(function () {
    d.reject();
  });
  return d.promise();
};

//in base all bbox e la layer chiedo al server di restituirmi il vettoriale (geojson) del layer
proto._loadVectorData = function (vectorLayer, bbox) {
  var _this8 = this;

  // eseguo le richieste dei dati al server al fine di ottenere il geojson,
  // vettoriale, del layer richiesto
  return self._getVectorLayerData(vectorLayer, bbox).then(function (vectorDataResponse) {
    _this8.setVectorLayerData(vectorLayer[_this8._editingApiField], vectorDataResponse);
    // setto i dati vettoriali del layer vettoriale
    // e verifico se siamo in editingMode write e se ci sono featurelocks
    if (_this8._editingMode && vectorDataResponse.featurelocks) {
      // nel cso in cui sia in editing (mode w) e che si siano featureLocks
      // setto tale features al layervettoriale
      _this8.setVectorFeaturesLock(vectorLayer, vectorDataResponse.featurelocks);
    }
    //setto i dati del layer vettoriale (geojson)
    vectorLayer.setData(vectorDataResponse.vector.data);
    if (_this8._) return vectorDataResponse;
  }).fail(function () {
    return false;
  });
};

proto.getVectorLayerData = function (layerCode) {
  return this._vectorLayersData[layerCode];
};

proto.getVectorLayersData = function () {
  return this._vectorLayersData;
};

proto.setVectorLayerData = function (layerCode, vectorLayerData) {
  this._vectorLayersData[layerCode] = vectorLayerData;
};

//funzione che setta le features lock del layer vettoriale
proto.setVectorFeaturesLock = function (vectorLayer, featureslock) {
  //vado a pescare le fifferenze tra le featureidlock gi caricati id
  var newFeaturesLockIds = _.differenceBy(featureslock, vectorLayer.getFeatureLocks(), 'featureid');
  newFeaturesLockIds.forEach(function (newLockId) {
    vectorLayer.addLockId(newLockId);
  });
};

proto.cleanVectorFeaturesLock = function (vectorLayer) {
  vectorLayer.cleanFeatureLocks();
};

proto.lockFeatures = function (layerName) {
  var _this9 = this;

  var d = $.Deferred();
  var bbox = this._mapService.state.bbox;
  var vectorLayer = this._layers[layerName].vector;
  $.get(this._baseUrl + layerName + "/?lock" + this._customUrlParameters + "&in_bbox=" + bbox[0] + "," + bbox[1] + "," + bbox[2] + "," + bbox[3]).done(function (data) {
    _this9.setVectorFeaturesLock(vectorLayer, data.featurelocks);
    d.resolve(data);
  }).fail(function () {
    d.reject();
  });
  return d.promise();
};

// ottiene la configurazione del vettoriale
// (qui richiesto solo per la definizione degli input)
proto._getVectorLayerConfig = function (layerApiField) {
  var d = $.Deferred();
  // attravercso il layer name e il base url
  // chiedo la server di inviarmi la configurazione editing del laye
  $.get(this._baseUrl + layerApiField + "/?config" + this._customUrlParameters).done(function (data) {
    d.resolve(data);
  }).fail(function () {
    d.reject();
  });
  return d.promise();
};

// ottiene il vettoriale in modalit  editing
proto._getVectorLayerData = function (vectorLayer, bbox) {
  var d = $.Deferred();
  var lock = this.getMode() == 'w' ? true : false;
  var apiUrl = void 0;
  if (lock) {
    apiUrl = this._baseUrl + vectorLayer[this._editingApiField] + "/?editing";
  } else {
    apiUrl = this._baseUrl + vectorLayer[this._editingApiField] + "/?";
  }
  $.get(apiUrl + this._customUrlParameters + "&in_bbox=" + bbox[0] + "," + bbox[1] + "," + bbox[2] + "," + bbox[3]).done(function (data) {
    d.resolve(data);
  }).fail(function () {
    d.reject();
  });
  return d.promise();
};
// funzione per creare il layer vettoriale
proto._createVectorLayer = function (options) {
  var vector = new VectorLayer(options);
  return vector;
};
//funzione chiamata dal plugin quando si vuole fare un cleanUp dei layers
// !!! -- DA RIVEDERE -- !!!
proto.cleanUpLayers = function () {
  this._loadedExtent = null;
};

module.exports = QGISProvider;

},{"babel-runtime/core-js/json/stringify":6,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/i18n/i18n.service":572,"core/layers/features/feature":580,"core/layers/providers/provider":603,"core/parsers/parsers":613,"core/utils/utils":630}],606:[function(require,module,exports){
var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');
var Filter = require('core/layers/filter/filter');

function WFSDataProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._name = 'wfs';
  this._layerName = this._getTypeName(this._layer.getQueryLayerName());
}

inherit(WFSDataProvider, DataProvider);

var proto = WFSDataProvider.prototype;

proto._getTypeName = function (layerQueryName) {
  return layerQueryName.replace(/[/\s]/g, '_');
};

proto.getData = function () {
  var d = $.Deferred();
  return d.promise();
};

// query method
proto.query = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var feature_count = options.feature_count || 10;
  params.MAXFEATURES = feature_count;
  var filter = options.filter;
  var d = $.Deferred();
  var layers = options.layers;
  this._doRequest(filter, params, layers).then(function (response) {
    var projections = {
      map: _this._layer.getMapProjection(),
      layer: _this._layer.getProjection()
    };
    var featuresForLayers = _this.handleQueryResponseFromServer(response, projections, layers, wms = false);
    d.resolve({
      data: featuresForLayers
    });
  }).fail(function (e) {
    d.reject(e);
  });
  return d.promise();
};

proto._post = function (url, params) {
  url = url.match(/\/$/) ? url : url + '/';
  var d = $.Deferred();
  $.post(url, params).then(function (response) {
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

// get request
proto._get = function (url, params) {
  // trasform parameters
  url = url.match(/\/$/) ? url : url + '/';
  var d = $.Deferred();
  var urlParams = $.param(params);
  url = url + '?' + urlParams;
  $.get(url).then(function (response) {
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

//request to server
proto._doRequest = function (filter) {
  var _this2 = this;

  var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var layers = arguments[2];

  var d = $.Deferred();
  filter = filter || new Filter();
  var layer = layers ? layers[0] : this._layer;
  var httpMethod = layer.getOwsMethod();
  var url = layer.getQueryUrl();
  var infoFormat = layer.getInfoFormat();
  var layerNames = layers ? layers.map(function (layer) {
    return _this2._getTypeName(layer.getQueryLayerName());
  }).join(',') : this._layerName;
  params = (0, _assign2.default)(params, {
    SERVICE: 'WFS',
    VERSION: '1.3.0',
    REQUEST: 'GetFeature',
    TYPENAME: layerNames,
    OUTPUTFORMAT: infoFormat,
    SRSNAME: layer.getProjection().getCode()
  });
  if (filter) {
    var filterType = filter.getType();
    var featureRequest = void 0;
    var f = ol.format.filter;
    filter = filter.get();
    switch (filterType) {
      case 'bbox':
        featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: f.bbox('the_geom', filter)
        });
        break;
      case 'geometry':
        featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: f.intersects('the_geom', filter)
        });
        break;
      case 'expression':
        featureRequest = new ol.format.WFS().writeGetFeature({
          featureTypes: [layer],
          filter: null
        });
        break;
      case 'all':
        request = this._post(url, params);
        return request;
      default:
        break;
    }
    params.FILTER = featureRequest.children[0].innerHTML;
    var queryPromise = httpMethod === 'GET' ? this._get(url, params) : this._post(url, params);
    queryPromise.then(function (response) {
      d.resolve(response);
    }).fail(function (err) {
      if (err.status === 200) d.resolve(err.responseText);else d.reject(err);
    });
  } else {
    d.reject();
  }
  return d.promise();
};

module.exports = WFSDataProvider;

},{"babel-runtime/core-js/object/assign":10,"core/layers/filter/filter":584,"core/layers/providers/provider":603,"core/utils/utils":630}],607:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var utils = require('core/utils/utils');
var geoutils = require('g3w-ol3/src/utils/utils');
var DataProvider = require('core/layers/providers/provider');

//overwrite method to read feature
// da un geojson
var PIXEL_TOLERANCE = 10;
var GETFEATUREINFO_IMAGE_SIZE = [101, 101];
var DPI = geoutils.getDPI();

function WMSDataProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._name = 'wms';
  this._projections = {
    map: null,
    layer: null
  };
  this._infoFormat = this._layer.getInfoFormat() || 'application/vnd.ogc.gml';
}

inherit(WMSDataProvider, DataProvider);

var proto = WMSDataProvider.prototype;

proto._getRequestParameters = function (_ref) {
  var layers = _ref.layers,
      feature_count = _ref.feature_count,
      coordinates = _ref.coordinates,
      resolution = _ref.resolution,
      size = _ref.size;

  var layerNames = layers ? layers.map(function (layer) {
    return layer.getWMSInfoLayerName();
  }).join(',') : this._layer.getWMSInfoLayerName();
  var extent = geoutils.getExtentForViewAndSize(coordinates, resolution, 0, size);
  var x = Math.floor((coordinates[0] - extent[0]) / resolution);
  var y = Math.floor((extent[3] - coordinates[1]) / resolution);
  var params = {
    SERVICE: 'WMS',
    VERSION: '1.3.0',
    REQUEST: 'GetFeatureInfo',
    CRS: this._projections.map.getCode(),
    LAYERS: layerNames,
    QUERY_LAYERS: layerNames,
    INFO_FORMAT: this._infoFormat,
    FEATURE_COUNT: feature_count,
    // TOLLERANCE PARAMETERS FOR QGIS
    FI_POINT_TOLERANCE: PIXEL_TOLERANCE,
    FI_LINE_TOLERANCE: PIXEL_TOLERANCE,
    FI_POLYGON_TOLERANCE: PIXEL_TOLERANCE,
    G3W_TOLERANCE: PIXEL_TOLERANCE * resolution,
    WITH_GEOMETRY: 1,
    I: x,
    J: y,
    DPI: DPI,
    WIDTH: size[0],
    HEIGHT: size[1]
  };
  if (!('STYLES' in params)) params['STYLES'] = '';

  var bbox = this._projections.map.getAxisOrientation().substr(0, 2) === 'ne' ? [extent[1], extent[0], extent[3], extent[2]] : extent;

  params['BBOX'] = bbox.join(',');
  return params;
};

proto.query = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var size = options.size || GETFEATUREINFO_IMAGE_SIZE;
  var feature_count = options.feature_count || 10;
  var layerProjection = this._layer.getProjection();
  this._projections.map = this._layer.getMapProjection() || layerProjection;
  var coordinates = options.coordinates || [];
  var resolution = options.resolution || null;
  var layers = options.layers;
  var layer = layers ? layers[0] : this._layer;
  var url = layer.getQueryUrl();
  var METHOD = layer.isExternalWMS() || !/^\/ows/.test(url) ? 'GET' : layer.getOwsMethod();
  var params = this._getRequestParameters({ layers: layers, feature_count: feature_count, coordinates: coordinates, resolution: resolution, size: size });
  this[METHOD]({ url: url, layers: layers, params: params }).then(function (response) {
    var data = _this.handleQueryResponseFromServer(response, _this._projections, layers);
    d.resolve({
      data: data,
      query: {
        coordinates: coordinates,
        resolution: resolution
      }
    });
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.GET = function (_ref2) {
  var url = _ref2.url,
      params = _ref2.params;

  var sourceParam = url.split('SOURCE');
  if (sourceParam.length) {
    url = sourceParam[0];
    if (sourceParam.length > 1) {
      sourceParam = '&SOURCE' + sourceParam[1];
    } else {
      sourceParam = '';
    }
  }
  url = utils.appendParams(url, params);
  url = '' + url + (sourceParam && sourceParam);
  return $.get(url);
};

proto.POST = function (_ref3) {
  var url = _ref3.url,
      params = _ref3.params;

  return $.post(url, params);
};

module.exports = WMSDataProvider;

},{"core/layers/providers/provider":603,"core/utils/utils":630,"g3w-ol3/src/utils/utils":678}],608:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

var _require = require('core/utils/utils'),
    XHR = _require.XHR;

var G3WObject = require('core/g3wobject');
var WPS_VERSION = "1.0.0";

function WPSProvider() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._name = 'wps';
  this._url = options.url;
  this._service = new WpsService({
    url: this._url,
    version: WPS_VERSION
  });
  this._inputs = [];
  this._outputs = [];
  this._parser = new X2JS();
}

inherit(WPSProvider, G3WObject);

var proto = WPSProvider.prototype;

proto._XMLToJSON = function (response) {
  return this._parser.xml2json(response);
};

proto._createProcessInputType = function (input) {
  var inputObject = {
    type: null,
    dataType: null,
    value: null,
    options: {}
  };
  if (input.complexData) {
    inputObject.type = 'file';
    inputObject.options.mimetype = input.complexData.formats[0].mimeType;
  } else if (input.literalData) {
    inputObject.type = input.literalData.literalDataDomains[0].dataType.type;
    inputObject.dataType = inputObject.type;
    inputObject.options = null;
  } else if (input.boundingBoxData) {
    inputObject.value = {
      llx: null,
      lly: null,
      upx: null,
      upy: null
    };
    inputObject.type = 'bbox';
    inputObject.epsg = input.boundingBoxData.supportedCRSs[0];
    inputObject.options.epsg = input.boundingBoxData.supportedCRSs;
  }
  return inputObject;
};

proto._buildFormFromDescribeProcessResponse = function () {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      abstractValue = _ref.abstractValue,
      inputs = _ref.inputs,
      outputs = _ref.outputs;

  this._inputs = inputs;
  inputs = inputs.map(function (input) {
    var inputType = _this._createProcessInputType(input);
    return (0, _extends3.default)({
      id: input.identifier,
      label: input.title
    }, inputType);
  });
  this._outputs = outputs;
  outputs = outputs.map(function (output) {
    return {
      id: output.identifier,
      label: output.title,
      sublabel: output.abstractValue || '',
      //dataType: output.complexData ? 'complexData' : 'literalData',
      //type: output.complexData ? output.complexData.formats: output.literalData && output.literalData.literalDataDomains[0].dataType.type,
      value: ''
    };
  });

  return {
    abstract: abstractValue,
    inputs: inputs,
    outputs: outputs
  };
};

proto.getCapabilities = function () {
  var _this2 = this;

  return new _promise2.default(function (resolve, reject) {
    _this2._service.getCapabilities_GET(function (response) {
      try {
        var processes = response.capabilities && response.capabilities.processes || [];
        resolve(processes);
      } catch (err) {
        reject(err);
      }
    });
  });
};

proto.describeProcess = function (_ref2) {
  var _this3 = this;

  var id = _ref2.id,
      _ref2$format = _ref2.format,
      format = _ref2$format === undefined ? 'form' : _ref2$format;

  return new _promise2.default(function (resolve, reject) {
    try {
      _this3._service.describeProcess_GET(function (response) {
        var describeProcessResponse = response.processOffering && response.processOffering.process;
        var describeProcessForm = _this3._buildFormFromDescribeProcessResponse(describeProcessResponse);
        resolve(describeProcessForm);
      }, id);
    } catch (err) {
      reject(err);
    }
  });
};

proto._createInputsForExcute = function () {
  var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return inputs.map(function (input) {
    var executeInput = void 0;
    var inputGenerator = new InputGenerator();
    var type = input.type;
    /**
     * the following parameters are mandatory: identifier and value
     *
     * the rest might be set to 'undefined'!
     *
     * @identifier input identifier
     * @dataType data type of the input; may be 'undefined'
     * @uom unit of measure; may be 'undefined'
     * @value the literal value of the input
     */
    switch (type) {
      case 'string':
      case 'float':
        executeInput = inputGenerator.createLiteralDataInput_wps_1_0_and_2_0(input.id, undefined, undefined, input.value);
        break;
      case 'file':
        executeInput = inputGenerator.createComplexDataInput_wps_1_0_and_2_0(input.id, input.options.mimetype, undefined, undefined, undefined, input.value);
        break;
      case 'bbox':
        var lowerCorner = input.value.llx + ' ' + input.value.lly;
        var upperCorner = input.value.upx + ' ' + input.value.upy;
        executeInput = inputGenerator.createBboxDataInput_wps_1_0_and_2_0(input.id, input.epsg, 2, lowerCorner, upperCorner);
        break;
    }
    return executeInput;
  });
};

proto._createOutputsForExcute = function () {
  var ouputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  return this._outputs.map(function (output, index) {
    var outputGenerator = new OutputGenerator();
    /**
     * the following parameters are mandatory: identifier
     *
     * @identifier output identifier
     * @asReference boolean, "true" or "false"
     */
    if (output.literalData) return outputGenerator.createLiteralOutput_WPS_1_0(output.identifier, false);
    /**
     * the following parameters are mandatory: identifier
     *
     * the rest might be set to 'undefined'!
     *
     * @identifier output identifier
     * @mimeType MIME type of the input; may be 'undefined'
     * @schema reference to a schema; may be 'undefined'
     * @encoding encoding; may be 'undefined'
     * @uom unit of measure; may be 'undefined'
     * @asReference boolean, "true" or "false"
     * @title new title
     * @abstractValue new description as text of the 'Abstract' element
     *                of the response document
     */
    else if (output.complexData) return outputGenerator.createComplexOutput_WPS_1_0(output.identifier, output.complexData.formats[0].mimeType, output.complexData.formats[0].schema, output.complexData.formats[0].encoding, undefined, undefined, undefined, 'Pippo', 'Prova');else if (output.boundingBoxData) {
        return outputGenerator.createComplexOutput_WPS_1_0(output.identifier);
      }
  });
};

proto.execute = function () {
  var _this4 = this;

  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$inputs = _ref3.inputs,
      inputs = _ref3$inputs === undefined ? [] : _ref3$inputs,
      id = _ref3.id,
      _ref3$outputs = _ref3.outputs,
      outputs = _ref3$outputs === undefined ? [] : _ref3$outputs;

  var response_ = {
    status: 'ok',
    data: null,
    type: null
  };
  return new _promise2.default(function (resolve, reject) {
    _this4._service.execute(function (response) {
      if (response.executeResponse) {
        //response.type is set to one of { responseDocument | resultDocument | statusInfoDocument | rawOutput }
        //response.responseDocument // property that stores the contents of response (structure depends on type!)
        /*
        * type 'rawOutput' stands for raw output
          type 'responseDocument' stands for a WPS 1.0.0 response document
          type 'resultDocument' stands for a WPS 2.0.0 result document (in response to a synchronous execution)
          type 'resultDocument' stands for a WPS 2.0.0 status info document (in response to an asynchronous execution)
        * */
        var data = void 0;
        var type = response.executeResponse.type;

        switch (type) {
          case 'responseDocument':
            data = _this4._parser.xml2json(response.responseDocument);
            if (data.ExecuteResponse.Status.ProcessFailed) {
              response_.status = "error";
              response_.data = data.ExecuteResponse.Status.ProcessFailed.ExceptionReport.Exception.ExceptionText.toString();
            } else {
              response_.data = response.responseDocument;
              response_.type = 'string';
            }
            resolve(response_);
            break;
          case "rawOutput":
            var responseType = _this4._outputs.find(function (output) {
              return output.complexData;
            }) ? 'vector' : 'string';
            data = response.executeResponse.responseDocument;
            response_.type = responseType;
            if (responseType === 'vector') {
              var parser = new ol.format.WMSGetFeatureInfo();
              var features = parser.readFeatures(data);
              response_.data = features;
            } else {
              response_.data = data;
            }
            resolve(response_);
            break;
          default:
        }
      }
    }, id, "raw", "sync", false, _this4._createInputsForExcute(inputs), _this4._createOutputsForExcute(_this4._outputs));
  });
};

proto._handleOutputProcessResponse = function (response) {
  var output = this._XMLToJSON(response);
  var response_ = {
    status: 'ok',
    data: null,
    type: null
  };
  var errorExceptionReport = output.ExceptionReport || output.ExecuteResponse.Status.ProcessFailed && output.ExecuteResponse.Status.ProcessFailed.ExceptionReport;
  if (errorExceptionReport) {
    response_.status = 'error';
    response_.data = errorExceptionReport.Exception.ExceptionText.toString();
  } else if (output.ExecuteResponse) {
    if (output.ExecuteResponse.ProcessOutputs.Output.Data.ComplexData) {
      var FeatureCollection = output.ExecuteResponse.ProcessOutputs.Output.Data.ComplexData.FeatureCollection;
      if (FeatureCollection.featureMember) FeatureCollection.featureMember = Array.isArray(FeatureCollection.featureMember) ? FeatureCollection.featureMember : [FeatureCollection.featureMember];
      var layerFeatureCollectionXML = this._parser.json2xml_str({
        FeatureCollection: FeatureCollection
      });
      var parser = new ol.format.WMSGetFeatureInfo();
      var features = parser.readFeatures(layerFeatureCollectionXML);
      response_.type = 'vector';
      response_.data = features;
    } else if (output.ExecuteResponse.ProcessOutputs.Output.Data.LiteralData) {
      response_.type = output.ExecuteResponse.ProcessOutputs.Output.Data.LiteralData._dataType;
      response_.data = output.ExecuteResponse.ProcessOutputs.Output.Data.LiteralData.toString();
    }
  }
  return response_;
};

proto.getStatus = function (jobId) {
  return XHR.get(this._url);
};

proto.getResult = function () {
  return;
};

module.exports = WPSProvider;

},{"babel-runtime/core-js/promise":16,"babel-runtime/helpers/extends":22,"core/g3wobject":569,"core/utils/utils":630}],609:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var DataProvider = require('core/layers/providers/provider');

function XMLDataProvider(options) {
  options = options || {};
  base(this);
  this._name = 'xml';
}

inherit(XMLDataProvider, DataProvider);

var proto = XMLDataProvider.prototype;

proto.getData = function () {
  var d = $.Deferred();
  return d.promise();
};

module.exports = XMLDataProvider;

},{"core/layers/providers/provider":603,"core/utils/utils":630}],610:[function(require,module,exports){
var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var Layer = require('./layer');
var Editor = require('core/editing/editor');
var FeaturesStore = require('./features/featuresstore');
var Feature = require('./features/feature');
var Relations = require('core/relations/relations');

// Base Layer that support editing
function TableLayer() {
  var _this3 = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var ProjectsRegistry = require('core/project/projectsregistry');
  // setters
  this.setters = {
    // delete all features
    clearFeatures: function clearFeatures() {
      this._clearFeatures();
    },
    addFeature: function addFeature(feature) {
      this._addFeature(feature);
    },
    deleteFeature: function deleteFeature(feature) {
      this._deleteFeature(feature);
    },
    updateFeature: function updateFeature(feature) {
      this._updateFeature(feature);
    },
    setFeatures: function setFeatures(features) {
      this._setFeatures(features);
    },
    // get data from every sources (server, wms, etc..)
    // throught provider related to featuresstore
    getFeatures: function getFeatures() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var d = $.Deferred();
      this._featuresStore.getFeatures(options).then(function (promise) {
        promise.then(function (features) {
          _this.emit('getFeatures', features);
          return d.resolve(features);
        }).fail(function (err) {
          return d.reject(err);
        });
      }).fail(function (err) {
        d.reject(err);
      });
      return d.promise();
    },
    commit: function commit(commitItems, featurestore) {
      var _this2 = this;

      var d = $.Deferred();
      this._featuresStore.commit(commitItems).then(function (promise) {
        promise.then(function (response) {
          // if commit go right
          // apply commit changes to features store eventually passed (ex: session featurestore)
          if (featurestore) {
            features = featurestore.readFeatures();
            _this2._featuresStore.setFeatures(features);
          }
          _this2.applyCommitResponse(response);
          return d.resolve(response);
        }).fail(function (err) {
          return d.reject(err);
        });
      }).fail(function (err) {
        d.reject(err);
      });
      return d.promise();
    },
    setColor: function setColor(color) {
      this._setColor(color);
    }
  };
  /*
   * editing url api:
   * /api/vector/<type of request: data/editing/config>/<project_type>/<project_id>/<layer_id>
   * example: /api/vector/config/qdjango/10/points273849503023
   *
  */
  this.type = Layer.LayerTypes.TABLE;
  // color
  this._color = null;
  var currentProject = options.project || ProjectsRegistry.getCurrentProject();
  // set urls
  this.projectId = currentProject.getId();
  this.layerId = config.id;
  this.projectType = options.project_type || currentProject.getType();
  this.vectorUrl = options.vectorurl || initConfig.vectorurl;
  // add urls
  config.urls = config.urls || {};
  //add editing urls
  this.setEditingUrls({
    urls: config.urls
  });
  // add editing configurations
  config.editing = {
    pk: null, // primary key
    fields: [] // editing fields
  };
  // call base layer
  base(this, config);
  var projectRelations = currentProject.getRelations();
  // create realations
  this._relations = null;
  this._createRelations(projectRelations);
  // add state info for the layer
  this.state = _.merge({
    editing: {
      started: false,
      modified: false,
      ready: false,
      ispkeditable: false
    }
  }, this.state);
  // get configuration from server if is editable
  if (this.isEditable()) {
    this.getEditingConfig().then(function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          vector = _ref.vector,
          constraints = _ref.constraints;

      _this3.config.editing.pk = vector.pk;
      _this3.config.editing.fields = vector.fields;
      _this3.config.editing.format = vector.format;
      _this3.config.editing.constraints = constraints || {};
      _this3.config.editing.style = vector.style || {};
      _this3._setOtherConfigParameters(vector);
      if (vector.style) {
        _this3.setColor(vector.style.color);
      }
      _this3._setPkEditable(_this3.config.editing.fields);
      _this3.setReady(true);
    }).fail(function (err) {
      _this3.setReady(false);
    }).always(function () {
      _this3.emit('layer-config-ready', _this3.config);
    });
  }
  this._featuresStore = new FeaturesStore({
    provider: this.providers.data
  });
  // creare an instace of editor
  this._editor = new Editor({
    layer: this
  });
}

inherit(TableLayer, Layer);

var proto = TableLayer.prototype;

proto.clone = function () {
  return _.cloneDeep(this);
};

proto.cloneFeatures = function () {
  return this._featuresStore.clone();
};

proto.setVectorUrl = function (url) {
  this.vectorUrl = url;
};

proto.setProjectType = function (projectType) {
  this.projectType = projectType;
};

proto._setColor = function (color) {
  this._color = color;
};

proto.getColor = function () {
  return this._color;
};

proto.readFeatures = function () {
  return this._featuresStore.readFeatures();
};

// return layer for editing
proto.getLayerForEditing = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      vectorurl = _ref2.vectorurl,
      project_type = _ref2.project_type;

  vectorurl && this.setVectorUrl(vectorurl);
  project_type && this.setProjectType(project_type);
  this.setEditingUrl();
  return this.clone();
};

proto.setEditingUrls = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      urls = _ref3.urls;

  var suffixUrl = this.projectType + '/' + this.projectId + '/' + this.layerId + '/';
  urls = urls || this.config.urls;
  urls.editing = this.vectorUrl + 'editing/' + suffixUrl;
  urls.commit = this.vectorUrl + 'commit/' + suffixUrl;
  urls.config = this.vectorUrl + 'config/' + suffixUrl;
  urls.unlock = this.vectorUrl + 'unlock/' + suffixUrl;
  urls.widget = {
    unique: this.vectorUrl + 'widget/unique/data/' + suffixUrl
  };
};

proto.getEditingStyle = function () {
  return this.config.editing.style;
};

proto.setEditingStyle = function () {
  var style = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config.editing.style = style;
};

proto.getEditingConstrains = function () {
  return this.config.editing.constraints;
};

proto.isFieldRequired = function (fieldName) {
  var required = false;
  this.getEditingFields().forEach(function (field) {
    if (fieldName === field.name) {
      required = !!field.validate.required;
      return false;
    }
  });
  return required;
};

// apply response data from server in case of new inserted feature
proto.applyCommitResponse = function () {
  var _this4 = this;

  var response = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (response && response.result) {
    var data = response.response;

    var ids = data.new;
    var lockids = data.new_lockids;
    ids.forEach(function (idobj) {
      var feature = _this4._featuresStore.getFeatureById(idobj.clientid);
      feature.setId(idobj.id);
      try {
        // temporary inside try ckeck if feature contain a field with the same pk of the layer
        feature.getKeys().indexOf(_this4.getPk()) !== -1 && feature.set(_this4.getPk(), idobj.id);
      } catch (err) {}
    });
    this._featuresStore.addLockIds(lockids);
  }
};

// unlock editng features
proto.unlock = function () {
  var d = $.Deferred();
  this._featuresStore.unlock().then(function () {
    d.resolve();
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto._setOtherConfigParameters = function (config) {
  // overwrite by vector layer
};

// return layer fields
proto.getEditingFields = function () {
  var editable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  var fields = this.config.editing.fields.length ? this.config.editing.fields : this.config.fields;
  if (editable) fields = fields.filter(function (field) {
    return field.editable;
  });
  return fields;
};

proto.getFieldsLabel = function () {
  var labels = [];
  this.getEditingFields().forEach(function (field) {
    labels.push(field.label);
  });
  return labels;
};

proto.getDataFormat = function () {
  return this.config.editing.format;
};

proto.getPk = function () {
  return this.config.editing.pk;
};

proto._setPkEditable = function (fields) {
  var _this5 = this;

  fields.forEach(function (field) {
    if (field.name === _this5.getPk()) {
      _this5.state.editing.ispkeditable = field.editable;
      return false;
    }
  });
};

// raw data
proto.getEditingFormat = function () {
  return this.config.editing.format;
};

proto.isReady = function () {
  return this.state.editing.ready;
};

proto.setReady = function (bool) {
  this.state.editing.ready = _.isBoolean(bool) ? bool : false;
};

proto.isPkEditable = function () {
  return this.state.editing.ispkeditable;
};

// get configuration from server
proto.getEditingConfig = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  var provider = this.getProvider('data');
  provider.getConfig(options).then(function (config) {
    d.resolve(config);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.addEditingConfigFieldOption = function () {
  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      field = _ref4.field,
      key = _ref4.key,
      value = _ref4.value;

  var options = field.input.options;
  options[key] = value;
  return options[key];
};

proto.getWidgetData = function (options) {
  var provider = this.getProvider('data');
  var d = $.Deferred();
  provider.getWidgetData(options).then(function (response) {
    d.resolve(response);
  }).fail(function (err) {
    d.reject(err);
  });
  return d.promise();
};

proto.getCommitUrl = function () {
  return this.config.urls.commit;
};

proto.setCommitUrl = function (url) {
  this.config.urls.commit = url;
};

proto.getEditingUrl = function () {
  return this.config.urls.editing;
};

proto.setEditingUrl = function (url) {
  this.config.urls.editing = url;
};

proto.getUnlockUrl = function () {
  return this.config.url.unlock;
};

proto.setUnlockUrl = function (url) {
  this.config.urls.unlock = url;
};

proto.getWidgetUrl = function () {
  return this.config.urls.widget;
};

// set data url
proto.setDataUrl = function (url) {
  this.config.urls.data = url;
};

proto.getDataUrl = function () {
  return this.config.urls.data;
};

// url to get config layer
proto.getConfigUrl = function () {
  return this.config.urls.config;
};

proto.setConfigUrl = function (url) {
  this.config.urls.index = url;
};

proto.getEditor = function () {
  return this._editor;
};

proto.setEditor = function (editor) {
  this._editor = editor;
};

proto.getFeaturesStore = function () {
  return this._featuresStore;
};

proto.setFeaturesStore = function (featuresstore) {
  this._featuresStore = featuresstore;
};

proto.setSource = function (source) {
  this.setFeaturesStore(source);
};

proto.getSource = function () {
  return this._featuresStore;
};

proto._setFeatures = function (features) {
  this._featuresStore.setFeatures(features);
};

proto.addFeatures = function (features) {
  var _this6 = this;

  features.forEach(function (feature) {
    _this6.addFeature(feature);
  });
};

proto._addFeature = function (feature) {
  this._featuresStore.addFeature(feature);
};

proto._deleteFeature = function (feature) {
  return feature.getId();
};

proto._updateFeature = function (feature) {};

proto._clearFeatures = function () {
  this._featuresStore.clearFeatures();
};

proto.addLockIds = function (lockIds) {
  this._featuresStore.addLockIds(lockIds);
};

proto.setFieldsWithValues = function (feature, fields) {
  var pkValue = void 0;
  var createAttributesFromFields = function createAttributesFromFields(fields) {
    var attributes = {};
    fields.forEach(function (field) {
      if (field.type === 'child') {
        attributes[field.name] = createAttributesFromFields(field.fields);
      } else {
        // check if primary key is editbale
        if (feature.getPk() === field.name && field.editable) {
          pkValue = field.type === "integer" ? 1 * field.value : field.value;
          feature.setId(pkValue);
        } else {
          // case selct force to null
          if (field.value === 'null') {
            field.value = null;
          }
          attributes[field.name] = field.value;
        }
      }
    });
    return attributes;
  };
  var attributes = createAttributesFromFields(fields);
  feature.setProperties(attributes);
  return attributes;
};

proto.getFieldsWithValues = function (obj) {
  var _this7 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var exclude = options.exclude || [];
  var relation = options.relation || false;
  var fields = JSON.parse((0, _stringify2.default)(this.getEditingFields()));
  var feature = void 0;
  if (obj instanceof Feature) feature = obj;else if (obj instanceof ol.feature.Feature) feature = new Feature({
    feature: obj
  });else feature = obj && this.getFeatureById(obj);
  if (feature) {
    var attributes = feature.getProperties();
    fields = fields.filter(function (field) {
      //check if field is pk and if is new nad if is not editable
      return !relation && field.name === _this7.config.editing.pk && feature.isNew() && !_this7.isPkEditable() ? false : exclude.indexOf(field.name) === -1;
    });
    fields.forEach(function (field) {
      // check if pk
      if (field.name === _this7.config.editing.pk) {
        var editable = _this7.isPkEditable();
        // che check if has a value
        if (feature.getId()) {
          field.value = feature.getId();
          editable = feature.isNew();
        } else field.value = null;
        field.editable = editable;
      } else field.value = attributes[field.name];

      if (field.type !== 'child' && field.input.type === 'select_autocomplete' && !field.input.options.usecompleter) {
        var _configField = _this7.getEditingFields().find(function (_field) {
          return _field.name === field.name;
        });
        var _options = _configField.input.options;
        field.input.options.loading = _options.loading;
        field.input.options.values = _options.values;
      }
      // for editing purpose
      if (field.validate === undefined) field.validate = {};
      field.validate.valid = true;
      field.validate.unique = true;
      field.validate.required = field.validate.required === undefined ? false : field.validate.required;
      field.validate.empty = field.validate.required;
      field.validate.message = null;
      // end editng purpose
    });
  }
  return fields;
};

proto._createRelations = function (projectRelations) {
  var relations = [];
  var layerId = this.getId();
  projectRelations.forEach(function (relation) {
    if ([relation.referencedLayer, relation.referencingLayer].indexOf(layerId) != -1) relations.push(relation);
  });
  if (!!relations.length) {
    this._relations = new Relations({
      relations: relations
    });
  }
  return relations;
};

proto.createNewFeature = function () {
  var feature = new ol.Feature();
  var properties = {};
  _.forEach(this.getEditingFields(), function (field) {
    properties[field.name] = null;
  });
  feature.setProperties(properties);
  feature = new Feature({
    feature: feature,
    pk: this.getPk()
  });
  //check if primary key is editable
  if (!this.isPkEditable()) feature.setTemporaryId();else feature.setNew();
  return feature;
};

// retunr relations of layer
proto.getRelations = function () {
  return this._relations;
};

proto.getRelationAttributes = function (relationName) {
  var fields = [];
  this._relations.forEach(function (relation) {
    if (relation.name === relationName) {
      fields = relation.fields;
      return false;
    }
  });
  return fields;
};

proto.getRelationsAttributes = function () {
  var fields = {};
  this.state.relations.forEach(function (relation) {
    fields[relation.name] = relation.fields;
  });
  return fields;
};

proto.isChild = function () {
  if (!this.getRelations()) return false;
  return this._relations.isChild(this.getId());
};

proto.isFather = function () {
  if (!this.getRelations()) return false;
  return this._relations.isFather(this.getId());
};

proto.getChildren = function () {
  if (!this.isFather()) return [];
  return this._relations.getChildren(this.getId());
};

proto.getFathers = function () {
  if (!this.isChild()) return [];
  return this._relations.getFathers(this.getId());
};

proto.hasChildren = function () {
  if (!this.hasRelations()) return false;
  return this._relations.hasChildren(this.getId());
};

proto.hasFathers = function () {
  if (!this.hasRelations()) return false;
  return this._relations.hasFathers(this.getId());
};

proto.hasRelations = function () {
  return !!this._relations;
};

module.exports = TableLayer;

},{"./features/feature":580,"./features/featuresstore":581,"./layer":588,"babel-runtime/core-js/json/stringify":6,"core/editing/editor":564,"core/project/projectsregistry":624,"core/relations/relations":626,"core/utils//utils":630,"core/utils/utils":630}],611:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var mixin = require('core/utils/utils').mixin;
var Layer = require('./layer');
var TableLayer = require('./tablelayer');
var GeoLayerMixin = require('./geolayermixin');
var VectoMapLayer = require('./map/vectorlayer');

function VectorLayer() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments[1];

  base(this, config, options);
  this._mapLayer = null; // later tah will be added to map
  this.type = Layer.LayerTypes.VECTOR;
  // need a ol layer for add to map
  this.setup(config);
  this.onafter('setColor', function (color) {});
}

inherit(VectorLayer, TableLayer);

mixin(VectorLayer, GeoLayerMixin);

var proto = VectorLayer.prototype;

proto._setOtherConfigParameters = function (config) {
  this.config.editing.geometrytype = config.geometrytype;
};

proto.getEditingGeometryType = function () {
  return this.config.editing.geometrytype;
};

proto.getMapLayer = function () {
  if (this._mapLayer) return this._mapLayer;
  var id = this.getId();
  var geometryType = this.getGeometryType();
  var color = this.getColor();
  var style = this.getStyle();
  var provider = this.getProvider('data');
  this._mapLayer = new VectoMapLayer({
    id: id,
    geometryType: geometryType,
    color: color,
    style: style,
    provider: provider
  });
  return this._mapLayer;
};

module.exports = VectorLayer;

},{"./geolayermixin":586,"./layer":588,"./map/vectorlayer":598,"./tablelayer":610,"core/utils//utils":630,"core/utils/utils":630}],612:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var LayersStoresRegistry = require('core/layers/layersstoresregistry');

function MapLayersStoresRegistry() {
  base(this);
}

inherit(MapLayersStoresRegistry, LayersStoresRegistry);

module.exports = new MapLayersStoresRegistry();

},{"core/layers/layersstoresregistry":591,"core/utils//utils":630,"core/utils/utils":630}],613:[function(require,module,exports){
var Parsers = {
  vector: require('./vector/parser'),
  table: require('./table/parser')
};

module.exports = Parsers;

},{"./table/parser":614,"./vector/parser":615}],614:[function(require,module,exports){
var TableParser = function TableParser() {
  this.pk = 'id';
  this.get = function (options) {
    options = options || {};
    var type = options.type;
    this.pk = options.pk || this.pk;
    var parser = void 0;
    switch (type) {
      case 'json':
        parser = this._parserJSON.bind(this);
        break;
      default:
        parser = this._parserJSON.bind(this);
    }
    return parser;
  };

  this._parserJSON = function (data) {
    var _this = this;

    var features = [];
    var feature = void 0;
    _.forEach(data, function (properties) {
      feature = new ol.Feature();
      //set properties
      feature.setProperties(properties);
      //set Id prporties (is pk)
      feature.setId(properties[_this.pk]);
      features.push(feature);
    });
    return features;
  };
};

module.exports = new TableParser();

},{}],615:[function(require,module,exports){
var VectorParser = function VectorParser() {
  // return the right parser for the request
  this.get = function (options) {
    options = options || {};
    var type = options.type;
    var parser = void 0;
    switch (type) {
      case 'json':
        parser = this._parseLayerGeoJSON;
        break;
      case 'gml':
        parser = this._parseLayermsGMLOutput;
        break;
      default:
        parser = this._parseLayerGeoJSON;
    }
    return parser;
  };
  this._parseLayermsGMLOutput = function (data) {
    var layers = this._layer.getQueryLayerOrigName();
    var parser = new ol.format.WMSGetFeatureInfo({
      layers: layers
    });
    return parser.readFeatures(data);
  };

  this._parseLayerGeoJSON = function (data, options) {
    var crs = options.crs;
    var geojson = new ol.format.GeoJSON({
      defaultDataProjection: crs,
      geometryName: "geometry"
    });
    return geojson.readFeatures(data);
  };
};

module.exports = new VectorParser();

},{}],616:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var ProjectsRegistry = require('core/project/projectsregistry');
var PluginsRegistry = require('./pluginsregistry');

var Plugin = function Plugin() {
  var _this = this;

  base(this);
  this.name = '(no name)';
  this.config = null;
  this.service = null;
  this.dependencies = [];
  this._api = {
    getConfig: function getConfig() {
      return _this.config;
    }
  };
  this._hook = null;
  this._ready = false;
  this._services = {
    'search': GUI.getComponent('search').getService(),
    'tools': GUI.getComponent('tools').getService()
  };
};

inherit(Plugin, G3WObject);

var proto = Plugin.prototype;

proto.setDependencies = function (dependencies) {
  this.dependencies = dependencies;
};

proto.addDependency = function (dependency) {
  this.dependencies.push(dependency);
};

//API Plugin
proto.getApi = function () {
  return this._api;
};

proto.setApi = function () {
  var api = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  api.getConfig = this._api.getConfig;
  this._api = api;
};

proto.setReady = function (bool) {
  this._ready = bool;
  this.emit('set-ready', bool);
};

proto.isReady = function () {
  var _this2 = this;

  return new _promise2.default(function (resolve, reject) {
    if (_this2._ready) resolve();else _this2.once('set-ready', function (bool) {
      _this2._ready = bool;
      resolve();
    });
  });
};

//return plugin service
proto.getService = function () {
  return this.service;
};

//set plugin service
proto.setService = function (service) {
  this.service = service;
};

proto.getName = function () {
  return this.name;
};

proto.setName = function (name) {
  this.name = name;
};

//get cplugin configuration
proto.getConfig = function (name) {
  name = name || this.name;
  return PluginsRegistry.getPluginConfig(name);
};

proto.setConfig = function (config) {
  this.config = config;
};

//check if plugin is compatible with current project
proto.isCurrentProjectCompatible = function (projectId) {
  var project = ProjectsRegistry.getCurrentProject();
  return projectId === project.getGid();
};

proto.getProject = function () {
  return ProjectsRegistry.getCurrentProject();
};

//register the plugin if compatible
proto.registerPlugin = function (projectId) {
  var iscompatible = this.isCurrentProjectCompatible(projectId);
  iscompatible && PluginsRegistry.registerPlugin(this);
  return iscompatible;
};

proto.setupGui = function () {};

// method to get dependencies plugin
proto.getDependencyPlugins = function (pluginsName) {
  var _this3 = this;

  pluginsName = pluginsName || this.dependencies;
  var pluginPromises = pluginsName.map(function (pluginName) {
    return _this3.getDependencyPlugin(pluginName);
  });
  return _promise2.default.all(pluginPromises);
};

// method to get plugin dependency
proto.getDependencyPlugin = function (pluginName) {
  if (!PluginsRegistry.isTherePlugin(pluginName)) return _promise2.default.reject({ error: 'no plugin' });
  return new _promise2.default(function (resolve, reject) {
    var plugin = PluginsRegistry.getPlugin(pluginName);
    plugin && plugin.isReady().then(function () {
      resolve(plugin.getApi());
    }) || PluginsRegistry.onafter('registerPlugin', function (plugin) {
      plugin.name === pluginName && plugin.isReady().then(function () {
        resolve(plugin.getApi());
      });
    });
  });
};

proto.setHookLoading = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$hook = _ref.hook,
      hook = _ref$hook === undefined ? "tools" : _ref$hook,
      _ref$loading = _ref.loading,
      loading = _ref$loading === undefined ? false : _ref$loading;

  var service = this._services[hook];
  service.setLoading(loading);
};

proto.getHookService = function () {
  var hook = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "tools";

  return this._services[hook];
};

proto.addToolGroup = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$hook = _ref2.hook,
      hook = _ref2$hook === undefined ? "tools" : _ref2$hook,
      order = _ref2.position,
      group = _ref2.title;

  var service = this.getHookService(hook);
  service.addToolGroup(order, group);
};

proto.removeToolGroup = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      hook = _ref3.hook,
      group = _ref3.group;

  var title = group.title;

  var service = this.getHookService(hook);
  service.removeToolGroup(title);
};

proto.addTools = function () {
  var _this4 = this;

  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref4$hook = _ref4.hook,
      hook = _ref4$hook === undefined ? "tools" : _ref4$hook,
      action = _ref4.action,
      html = _ref4.html,
      icon = _ref4.icon,
      name = _ref4.name,
      type = _ref4.type,
      _ref4$options = _ref4.options,
      options = _ref4$options === undefined ? {} : _ref4$options,
      _ref4$loading = _ref4.loading,
      loading = _ref4$loading === undefined ? false : _ref4$loading,
      _ref4$disabled = _ref4.disabled,
      disabled = _ref4$disabled === undefined ? false : _ref4$disabled,
      _ref4$state = _ref4.state,
      state = _ref4$state === undefined ? { type: null, message: null } : _ref4$state;

  var groupTools = arguments[1];

  if (!action && !type) {
    this.removeToolGroup({ hook: hook, group: groupTools });
    return [];
  }
  this._hook = hook;
  var service = this._services[hook];
  var configs = this.config.configs || [this.config];
  var tools = configs.map(function (config) {
    return {
      icon: icon,
      type: type,
      name: config.name || name,
      html: html,
      loading: loading,
      disabled: disabled,
      options: options,
      action: action && action.bind(_this4, config),
      state: state
    };
  });
  service.addTools(tools, groupTools);
  return tools;
};

proto.setToolState = function () {
  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      id = _ref5.id,
      _ref5$state = _ref5.state,
      state = _ref5$state === undefined ? { type: null, message: null } : _ref5$state;

  var service = this._services[this._hook];
  service.setToolState({ id: id, state: state });
};

proto.removeTools = function () {
  var service = this._services[this._hook];
  service.removeTools();
};

// unload (case change map)
proto.unload = function () {
  this.service && this.service.clearAllEvents();
  //console.log('UNLOAD can be overwrite by plugin');
};

// load plugin
proto.load = function () {
  //console.log('LOAD  need to be overwrite by plugin');
};

module.exports = Plugin;

},{"./pluginsregistry":618,"babel-runtime/core-js/promise":16,"core/g3wobject":569,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/gui":710}],617:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ApplicationService = require('core/applicationservice');
var G3WObject = require('core/g3wobject');

function PluginService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._api = {
    own: null,
    dependencies: {}
  };
  this._pluginEvents = {};
  this._appEvents = [];
  this.init = function (config) {
    this.config = config;
  };
}

inherit(PluginService, G3WObject);

var proto = PluginService.prototype;

proto.isIframe = function () {
  return ApplicationService.isIframe();
};

proto.getConfig = function () {
  return this.config;
};

proto.setConfig = function (config) {
  this.config = config;
};

proto.setApi = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      dependency = _ref.dependency,
      api = _ref.api;

  if (!dependency) this._api.own = api;else this._api.dependencies[dependency] = api;
};

proto.getApi = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      dependency = _ref2.dependency;

  return dependency && this._api.dependencies[dependency] || this._api.own;
};

proto.initEvents = function () {
  var events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  for (var i in events) {
    var name = events[i];
    this._pluginEvents[name] = {};
  }
};

proto.registerWindowEvent = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      evt = _ref3.evt,
      cb = _ref3.cb;

  ApplicationService.registerWindowEvent({
    evt: evt,
    cb: cb
  });
};

proto.unregisterWindowEvent = function (_ref4) {
  var evt = _ref4.evt,
      cb = _ref4.cb;

  ApplicationService.unregisterWindowEvent({
    evt: evt,
    cb: cb
  });
};

proto.subscribeEvent = function (_ref5) {
  var name = _ref5.name,
      _ref5$once = _ref5.once,
      once = _ref5$once === undefined ? false : _ref5$once,
      owner = _ref5.owner,
      listener = _ref5.listener;

  this._pluginEvents[name] = this._pluginEvents[name] ? this._pluginEvents[name] : {};
  this._pluginEvents[name][owner] = listener;
  once ? this.once(name, listener) : this.on(name, listener);
};

proto.triggerEvent = function (_ref6) {
  var name = _ref6.name,
      _ref6$params = _ref6.params,
      params = _ref6$params === undefined ? {} : _ref6$params;

  this.emit(name, params);
};

proto.unsubscribeEvent = function (_ref7) {
  var name = _ref7.name,
      owner = _ref7.owner;

  var listener = this._pluginEvents[name][owner];
  this.removeEvent(name, listener);
  delete this._pluginEvents[name][owner];
};

proto.unsubscribeAllEvents = function () {
  for (var name in this._pluginEvents) {
    this.removeEvent(name);
    delete this._pluginEvents[name];
  }
};

proto.clearAllEvents = function () {
  this.unsubscribeAllEvents();
  this._pluginEvents = null;
};

module.exports = PluginService;

},{"core/applicationservice":560,"core/g3wobject":569,"core/utils/utils":630}],618:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var base = require('core/utils/utils').base;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var OTHERPLUGINS = ['law'];

function PluginsRegistry() {
  this.config = null;
  this._plugins = {};
  this.pluginsConfigs = {};
  this._loadedPluginUrls = [];
  this.setters = {
    //setters to register plugin
    registerPlugin: function registerPlugin(plugin) {
      if (!this._plugins[plugin.name]) this._plugins[plugin.name] = plugin;
    }
  };
  base(this);

  // initilize plugin
  this.init = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.pluginsBaseUrl = options.pluginsBaseUrl;
    // plugin configurations
    this.pluginsConfigs = options.pluginsConfigs;
    // plugins that aren't in configuration server but in project
    this.otherPluginsConfig = options.otherPluginsConfig;
    this.setOtherPlugins();
    this.setDependencyPluginConfig();
    return this._loadPlugins();
  };

  this._loadPlugins = function () {
    var _this = this;

    var pluginLoadPromises = (0, _entries2.default)(this.pluginsConfigs).map(function (_ref) {
      var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
          name = _ref2[0],
          pluginConfig = _ref2[1];

      return _this._setup(name, pluginConfig);
    });
    return _promise2.default.all(pluginLoadPromises);
  };

  this.setDependencyPluginConfig = function () {
    var _this2 = this;

    var _loop = function _loop() {
      var dependecyPluginConfig = _this2.pluginsConfigs[pluginName].plugins;
      dependecyPluginConfig && (0, _keys2.default)(dependecyPluginConfig).forEach(function (pluginName) {
        _this2.pluginsConfigs[pluginName] = (0, _extends3.default)({}, _this2.pluginsConfigs[pluginName], dependecyPluginConfig[pluginName]);
      });
    };

    for (pluginName in this.pluginsConfigs) {
      _loop();
    }
  };

  this.setOtherPlugins = function () {
    var law = OTHERPLUGINS[0];
    if (this.otherPluginsConfig && this.otherPluginsConfig[law] && this.otherPluginsConfig[law].length) {
      // law plugin
      this.pluginsConfigs[law] = this.otherPluginsConfig[law];
      this.pluginsConfigs[law].gid = this.otherPluginsConfig.gid;
    } else delete this.pluginsConfigs[law];
  };

  // reaload plugin in case of change map
  this.reloadPlugins = function (initConfig, project) {
    var _this3 = this;

    var scripts = $('script');
    var plugins = this.getPlugins();

    var _loop2 = function _loop2(_pluginName) {
      var plugin = plugins[_pluginName];
      // unload plugin e remove from DOM
      plugin.unload();
      delete _this3._plugins[_pluginName];
      scripts.each(function (index, scr) {
        _this3._loadedPluginUrls.forEach(function (pluginUrl, idx) {
          if (scr.getAttribute('src') === pluginUrl && pluginUrl.indexOf(_pluginName) !== -1) {
            scr.parentNode.removeChild(scr);
            _this3._loadedPluginUrls.splice(idx, 1);
            return false;
          }
        });
      });
    };

    for (var _pluginName in plugins) {
      _loop2(_pluginName);
    }
    this._loadedPluginUrls = [];
    //setup plugins
    this.otherPluginsConfig = project.getState();
    this.setPluginsConfig(initConfig.group.plugins);
    this.setOtherPlugins();
    return this._loadPlugins();
  };

  this.setPluginsConfig = function (config) {
    this.pluginsConfigs = config;
  };

  this._loadScript = function (url, name) {
    return $script(url, name);
  };

  //load plugin script
  this._setup = function (name, pluginConfig) {
    var _this4 = this;

    return new _promise2.default(function (resolve, reject) {
      if (!_.isNull(pluginConfig)) {
        var baseUrl = _this4.pluginsBaseUrl + name;
        var scriptUrl = baseUrl + '/js/plugin.js?' + Date.now();
        pluginConfig.baseUrl = _this4.pluginsBaseUrl;
        _this4._loadScript(scriptUrl, name).ready(name, function () {
          _this4._loadedPluginUrls.push(scriptUrl);
          resolve();
        });
      } else resolve();
    });
  };

  this.getPluginConfig = function (pluginName) {
    return this.pluginsConfigs[pluginName];
  };

  this.getPlugins = function () {
    return this._plugins;
  };

  this.getPlugin = function (pluginName) {
    return this._plugins[pluginName];
  };

  this.isTherePlugin = function (pluginName) {
    return this.pluginsConfigs[pluginName];
  };
}

inherit(PluginsRegistry, G3WObject);

module.exports = new PluginsRegistry();

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/core-js/object/keys":14,"babel-runtime/core-js/promise":16,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils/utils":630}],619:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var PrinterProviderFactory = require('./providers/printerproviderfactory');

function PrintService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  var type = options.type || 'QGIS';
  this.provider = PrinterProviderFactory.get(type);
}

inherit(PrintService, G3WObject);

var proto = PrintService.prototype;

proto.print = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "GET";

  return this.provider.print(options, method);
};

module.exports = PrintService;

},{"./providers/printerproviderfactory":621,"core/g3wobject":569,"core/utils/utils":630}],620:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function PrinterProvider() {
  base(this);
}

inherit(PrinterProvider, G3WObject);

var proto = PrinterProvider.prototype;

proto.print = function () {
  console.log('overwrite');
};

proto.getPrintUrl = function () {
  console.log('overwrite');
};

proto.print = function () {
  console.log('overwrite');
};

module.exports = PrinterProvider;

},{"core/g3wobject":569,"core/utils/utils":630}],621:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

var PrinterQGISProvider = require('./qgis/printerQGISProvider');

var Providers = {
  'QGIS': PrinterQGISProvider
};

function PrinterProviderFactory() {
  this.get = function () {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'QGIS';

    return new Providers[type]();
  };
  base(this);
}

inherit(PrinterProviderFactory, G3WObject);

module.exports = new PrinterProviderFactory();

},{"./qgis/printerQGISProvider":622,"core/g3wobject":569,"core/utils/utils":630}],622:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var convertObjectToUrlParams = require('core/utils/utils').convertObjectToUrlParams;
var PrintProvider = require('../printerprovider');
var ProjectsRegistry = require('core/project/projectsregistry');

function PrinterQGISProvider() {
  base(this);
}

inherit(PrinterQGISProvider, PrintProvider);

var proto = PrinterQGISProvider.prototype;

proto.POST = function (_ref) {
  var url = _ref.url,
      params = _ref.params,
      mime_type = _ref.mime_type;

  return new _promise2.default(function (resolve, reject) {
    var xhr = new XMLHttpRequest();
    xhr.open('POST', url, true);
    xhr.responseType = 'blob';
    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
    xhr.onload = function () {
      if (xhr.status === 200) {
        try {
          window.URL = window.URL || window.webkitURL;
          var _url = window.URL.createObjectURL(xhr.response);
          resolve({
            url: _url,
            layers: true,
            mime_type: mime_type
          });
        } catch (e) {
          reject(e);
        }
      } else if (xhr.status === 500) {
        reject();
      }
    };
    xhr.onerror = function () {
      reject();
    };
    xhr.send(convertObjectToUrlParams(params));
  });
};

proto.GET = function (_ref2) {
  var url = _ref2.url,
      params = _ref2.params,
      mime_type = _ref2.mime_type;

  return new _promise2.default(function (resolve, reject) {
    url = url + '?' + convertObjectToUrlParams(params);
    resolve({
      url: url,
      layers: true,
      mime_type: mime_type
    });
  });
};

proto._getParamsFromOptions = function (layers, options) {
  var templateMap = options.map || 'map0';
  layers = layers.map(function (layer) {
    return layer.getPrintLayerName();
  });
  var params = {
    SERVICE: 'WMS',
    VERSION: '1.3.0',
    REQUEST: 'GetPrint',
    TEMPLATE: options.template,
    DPI: options.dpi,
    FORMAT: options.format,
    CRS: options.crs,
    LAYERS: layers.join()
  };
  params[templateMap + ':SCALE'] = options.scale;
  params[templateMap + ':EXTENT'] = options.extent;
  params[templateMap + ':ROTATION'] = options.rotation;
  return params;
};

proto.print = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "GET";

  var layersStore = ProjectsRegistry.getCurrentProject().getLayersStore();
  var url = layersStore.getWmsUrl();
  // reverse of layer because the order is important
  var layers = _.reverse(layersStore.getLayers({
    PRINTABLE: {
      scale: options.scale
    },
    SERVERTYPE: 'QGIS'
  }));
  if (layers.length) {
    options.crs = layersStore.getProjection().getCode();
    var params = this._getParamsFromOptions(layers, options);
    var formats = {
      pdf: 'application/pdf',
      jpg: 'image/jpeg'
    };
    var mime_type = formats[params.FORMAT];
    return this[method]({
      url: url,
      params: params,
      mime_type: mime_type
    });
  } else return _promise2.default.resolve({
    layers: !!layers.length
  });
};

module.exports = PrinterQGISProvider;

/*
 http://localhost/fcgi-bin/qgis_mapserver/qgis_mapserv.fcgi?MAP=/home/marco/geodaten/projekte/composertest.qgs&SERVICE=WMS&VERSION=1.3.0
 &REQUEST=GetPrint&TEMPLATE=Composer 1&
 map0:extent=693457.466131,227122.338236,700476.845177,230609.807051&
 BBOX=693457.466131,227122.338236,700476.845177,230609.807051&
 CRS=EPSG:21781&WIDTH=1467&HEIGHT=729&LAYERS=layer0,layer1&
 STYLES=,&FORMAT=pdf&DPI=300&TRANSPARENT=true

 In detail, the following parameters can be used to set properties for composer maps:

 <mapname>:EXTENT=<xmin,ymin,xmax, ymax> //mandatory
 <mapname>:ROTATION=<double> //optional, defaults to 0
 <mapname>:SCALE=<double> //optional. Forces scale denominator as server and client may have different scale calculations
 <mapname>:LAYERS=<comma separated list with layer names> //optional. Defaults to all layer in the WMS request
 <mapname>:STYLES=<comma separated list with style names> //optional
 <mapname>:GRID_INTERVAL_X=<double> //set the grid interval in x-direction for composer grids
 <mapname>:GRID_INTERVAL_Y=<double> //set the grid interval in x-direction for composer grids
 */

},{"../printerprovider":620,"babel-runtime/core-js/promise":16,"core/project/projectsregistry":624,"core/utils/utils":630}],623:[function(require,module,exports){
var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var LayerFactory = require('core/layers/layerfactory');
var LayersStore = require('core/layers/layersstore');
var Projections = require('g3w-ol3/src/projection/projections');

function Project() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  /* structure 'project' object
  {
    id,
    type,
    gid,
    name,
    crs,
    proj4,
    extent,
    initextent,
    layers,
    layerstree,
    overviewprojectgid,
    baselayers,
    initbaselayer
    ows_method <POST or GET>
    wms_use_layer_ids: <TRUE OR FALSE>
    wps: [] // array of wps service
  }
  */
  // for future implementation catalog tab actived
  config.catalog_tab = config._catalog_tab || 'layers'; // values : layers, baselayers, legend
  config.ows_method = config.ows_method || 'GET';
  this.state = config;
  // process layers
  this._processLayers();
  // set the project projection
  this._projection = Projections.get(this.state.crs, this.state.proj4);
  // build a layerstore of the project
  this._layersStore = this._buildLayersStore();

  this.setters = {
    setBaseLayer: function setBaseLayer(id) {
      var _this = this;

      this.state.baselayers.forEach(function (baseLayer) {
        _this._layersStore.getLayerById(baseLayer.id).setVisible(baseLayer.id === id);
        baseLayer.visible = baseLayer.id === id;
      });
    }
  };
  base(this);
}

inherit(Project, G3WObject);

var proto = Project.prototype;

proto.getAliasUrl = function () {
  return this.state.aliasUrl;
};

proto.getActiveCatalogTab = function () {
  return this.state.catalog_tab;
};

proto.setActiveCatalogTab = function () {
  var tab = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'layers';

  this.state.catalog_tab = tab;
};

proto.isWmsUseLayerIds = function () {
  return this.state.wms_use_layer_ids;
};

// check if multi
proto.getQueryFeatureCount = function () {
  return this.state.feature_count || 5;
};

proto.isQueryMultiLayers = function (mapcontrol) {
  return this.state.querymultilayers && this.state.querymultilayers.indexOf(mapcontrol) !== -1;
};

proto.getRelations = function () {
  return this.state.relations;
};

proto.getRelationById = function (relationId) {
  return this.state.relations.find(function (relation) {
    return relation.id === relationId;
  });
};

proto.getOwsMethod = function () {
  return this.state.ows_method;
};

// process layerstree and baselayers of the project
proto._processLayers = function () {
  var _this2 = this;

  //info useful for catalog
  var traverse = function traverse(tree) {
    var _loop = function _loop(i) {
      var layer = tree[i];
      var layer_name_originale = void 0;
      //check if layer (node) of folder
      if (layer.id !== undefined) {
        _this2.state.layers.forEach(function (_layer) {
          layer_name_originale = _layer.name;
          if (layer.id === _layer.id) {
            layer.name = _layer.name;
            _layer.wmsUrl = _this2.getWmsUrl();
            _layer.project = _this2;
            tree[i] = (0, _assign2.default)(_layer, layer);
            return false;
          }
        });
      }
      if (Array.isArray(layer.nodes)) {
        //add title to tree
        layer.title = layer.name;
        traverse(layer.nodes);
      }
    };

    for (var i = 0; i < tree.length; i++) {
      _loop(i);
    }
  };
  // call trasverse function to
  traverse(this.state.layerstree);
  for (var i = 0; i < this.state.baselayers.length; i++) {
    var baseLayerConfig = this.state.baselayers[i];
    baseLayerConfig.visible = this.state.initbaselayer && baseLayerConfig.id === this.state.initbaselayer || !!baseLayerConfig.fixed;
    baseLayerConfig.baselayer = true;
  }
};

// build layersstore and create layersstree
proto._buildLayersStore = function () {
  var _this3 = this;

  // create a layersStore object
  var layersStore = new LayersStore();
  //check if we have owerview project
  var overviewprojectgid = this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
  layersStore.setOptions({
    id: this.state.gid,
    projection: this._projection,
    extent: this.state.extent,
    initextent: this.state.initextent,
    wmsUrl: this.state.WMSUrl,
    catalog: this.state.gid !== overviewprojectgid
  });

  // instance each layer ad area added to layersstore
  var layers = this.getLayers();
  layers.forEach(function (layerConfig) {
    // add projection
    layerConfig.projection = layerConfig.crs ? Projections.get(layerConfig.crs, layerConfig.proj4) : _this3._projection;
    //add ows_method
    layerConfig.ows_method = _this3.getOwsMethod();
    layerConfig.wms_use_layer_ids = _this3.state.wms_use_layer_ids;
    var layer = LayerFactory.build(layerConfig, {
      project: _this3
    });
    layersStore.addLayer(layer);
  });
  // create layerstree from layerstore
  layersStore.createLayersTree(this.state.name, {
    layerstree: this.state.layerstree
  });
  return layersStore;
};

proto.getLayerById = function (layerId) {
  return this._layersStore.getLayerById(layerId);
};

proto.getLayers = function () {
  return [].concat((0, _toConsumableArray3.default)(this.state.layers), (0, _toConsumableArray3.default)(this.state.baselayers));
};

proto.getConfigLayers = function () {
  return this.state.layers;
};

proto.getThumbnail = function () {
  return this.state.thumbnail;
};

proto.getState = function () {
  return this.state;
};

proto.getId = function () {
  return this.state.id;
};

proto.getType = function () {
  return this.state.type;
};

proto.getGid = function () {
  return this.state.gid;
};

proto.getName = function () {
  return this.state.name;
};

proto.getOverviewProjectGid = function () {
  return this.state.overviewprojectgid ? this.state.overviewprojectgid.gid : null;
};

proto.getCrs = function () {
  return this._projection.getCode();
};

/*
* type: major, minor, patch
* */
proto.getQgisVersion = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      type = _ref.type;

  var index = ['major', 'minor', 'patch'].indexOf(type);
  return index === -1 ? this.state.qgis_version : +this.state.qgis_version.split('.')[index];
};

proto.getProjection = function () {
  return this._projection;
};

proto.getWmsUrl = function () {
  return this.state.WMSUrl;
};

proto.getInfoFormat = function () {
  return 'application/vnd.ogc.gml';
};

proto.getLayersStore = function () {
  return this._layersStore;
};

module.exports = Project;

},{"babel-runtime/core-js/object/assign":10,"babel-runtime/helpers/toConsumableArray":24,"core/g3wobject":569,"core/layers/layerfactory":589,"core/layers/layersstore":590,"core/utils//utils":630,"core/utils/utils":630,"g3w-ol3/src/projection/projections":676}],624:[function(require,module,exports){
require('babel-polyfill');

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var Project = require('core/project/project');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var MapLayersStoresRegistry = require('core/map/maplayersstoresregistry');

/* service
    setup: init method
    getLayersState: returnLayersState
    getLayersTree: retunr  array of layersTree from LayersState
*/

// Public interface
function ProjectsRegistry() {
  this.config = null;
  this.initialized = false;
  this.projectType = null;
  this.setters = {
    setCurrentProject: function setCurrentProject(project) {
      if (this.state.currentProject !== project) {
        CatalogLayersStoresRegistry.removeLayersStores();
        MapLayersStoresRegistry.removeLayersStores();
      }
      this.state.currentProject = project;
      this.state.qgis_version = project.getQgisVersion();
      this.setProjectType(project.state.type);
      var projectLayersStore = project.getLayersStore();
      //set in first position (catalog)
      CatalogLayersStoresRegistry.addLayersStore(projectLayersStore, 0);
      //set in first position (map)
      MapLayersStoresRegistry.addLayersStore(projectLayersStore, 0);
    }
  };

  this.state = {
    baseLayers: {},
    minScale: null,
    maxscale: null,
    currentProject: null,
    qgis_version: null
  };

  // (lazy loading)
  this._groupProjects = [];
  this._projectConfigs = {};

  base(this);
}

inherit(ProjectsRegistry, G3WObject);

var proto = ProjectsRegistry.prototype;

//Inizialize configuration for all project belong to group
proto.init = function () {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  //check if already initialized
  if (!this.initialized) {
    this.config = config;
    this.overviewproject = config.overviewproject;
    this.setupState();
    // get current configuration
    this.getProject(config.initproject).then(function (project) {
      // set current project
      _this.setCurrentProject(project);
      _this.initialized = true;
      d.resolve(project);
    }).fail(function () {
      d.reject();
    });
  }
  return d.promise();
};

proto.setProjectType = function (projectType) {
  this.projectType = projectType;
};

proto.getConfig = function () {
  return this.config;
};

proto.getState = function () {
  return this.state;
};

proto.setupState = function () {
  var _this2 = this;

  this.state.baseLayers = this.config.baselayers;
  this.state.minScale = this.config.minscale;
  this.state.maxScale = this.config.maxscale;
  this.state.crs = this.config.crs;
  this.state.proj4 = this.config.proj4;
  var overViewProject = this.config.overviewproject && this.config.overviewproject.gid ? this.config.overviewproject : null;
  this.config.projects.forEach(function (project) {
    _this2.state.qgis_version = project.qgis_version || _this2.state.qgis_version;
    project.aliasUrl = project.url || null;
    project.baselayers = _this2.config.baselayers;
    project.minscale = _this2.config.minscale;
    project.maxscale = _this2.config.maxscale;
    project.crs = _this2.config.crs;
    project.proj4 = _this2.config.proj4;
    project.overviewprojectgid = overViewProject;
    _this2._groupProjects.push(project);
  });
};

proto.getProjectAliasUrl = function (gid) {
  var project = this.config.projects.find(function (project) {
    return project.gid === gid;
  });
  return project.aliasUrl;
};

proto.setProjectAliasUrl = function (_ref) {
  var gid = _ref.gid,
      url = _ref.url,
      host = _ref.host;

  var project = this.config.projects.find(function (project) {
    return project.gid === gid;
  });
  if (project) project.aliasUrl = project && '' + (host ? host : '') + url;
};

proto.getProjectType = function () {
  return this.projectType;
};

proto.getProjects = function () {
  return this._groupProjects;
};

proto.clearProjects = function () {
  this._groupProjects = [];
};

proto.getListableProjects = function () {
  var currentProjectId = this.getCurrentProject().getId();
  return _.sortBy(this.getProjects().filter(function (project) {
    if (!_.isNil(project.listable)) return project.listable;
    if (project.id === currentProjectId || project.overviewprojectgid && project.gid === project.overviewprojectgid.gid) return false;
    return project;
  }), 'title');
};

proto.getCurrentProject = function () {
  return this.state.currentProject;
};

proto.getProject = function (projectGid) {
  var _this3 = this;

  var d = $.Deferred();
  var pendingProject = this._groupProjects.find(function (project) {
    return project.gid === projectGid;
  });
  if (!pendingProject) {
    d.reject("Project doesn't exist");
    return d.promise();
  }
  var projectConfig = this._projectConfigs[projectGid];
  if (projectConfig) {
    var project = new Project(projectConfig);
    d.resolve(project);
  } else {
    this._getProjectFullConfig(pendingProject).then(function (projectFullConfig) {
      var projectConfig = _.merge(pendingProject, projectFullConfig);
      projectConfig.WMSUrl = _this3.config.getWmsUrl(projectConfig);
      // setupu project relations
      projectConfig.relations = _this3._setProjectRelations(projectConfig);
      _this3._projectConfigs[projectConfig.gid] = projectConfig;
      // instance of Project
      var project = new Project(projectConfig);
      // add to project
      d.resolve(project);
    }).fail(function (error) {
      d.reject(error);
    });
  }
  return d.promise();
};

proto._setProjectRelations = function (projectConfig) {
  projectConfig.relations = projectConfig.relations ? projectConfig.relations : [];
  projectConfig.relations = projectConfig.relations.map(function (relation) {
    if (relation.type === "ONE") {
      projectConfig.layers.find(function (layer) {
        if (layer.id === relation.referencingLayer) {
          relation.name = layer.name;
          return true;
        }
      });
    }
    return relation;
  });
  return projectConfig.relations;
};

proto.getProjectConfigByGid = function (gid) {
  return this._groupProjects.find(function (project) {
    return project.gid === gid;
  });
};

proto.getProjectUrl = function (gid) {
  var projectConfig = this.getProjectConfigByGid(gid);
  var projecId = projectConfig.gid.split(':')[1];
  var type = projectConfig.type;
  var currentUrl = window.location.href;
  var paths = currentUrl.split('/');
  if (!paths[paths.length - 1]) {
    paths[paths.length - 2] = projecId;
    paths[paths.length - 3] = type;
  } else {
    paths[paths.length - 1] = projecId;
    paths[paths.length - 2] = type;
  }
  return paths.join('/');
};

// method to call server to get project configuration
proto._getProjectFullConfig = function (projectBaseConfig) {
  var d = $.Deferred();
  var url = this.config.getProjectConfigUrl(projectBaseConfig);
  $.get(url).done(function (projectFullConfig) {
    d.resolve(projectFullConfig);
  }).fail(function (error) {
    d.reject(error);
  });
  return d.promise();
};

module.exports = new ProjectsRegistry();

},{"babel-polyfill":1,"core/catalog/cataloglayersstoresregistry":561,"core/g3wobject":569,"core/map/maplayersstoresregistry":612,"core/project/project":623,"core/utils/utils":630}],625:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Relation(config) {
  config = config || {};
  var uniqueSuffix = Date.now();
  var id = config.id || 'id_' + uniqueSuffix;
  var name = config.name || 'name_' + uniqueSuffix;

  // config per le pari statiche
  this.state = {
    id: id,
    name: name,
    father: config.referencedLayer,
    child: config.referencingLayer,
    fatherField: config.fieldRef.referencedField,
    childField: config.fieldRef.referencingField,
    type: config.type
  };

  base(this);
}

inherit(Relation, G3WObject);

var proto = Relation.prototype;

proto.getId = function () {
  return this.state.id;
};

proto.setId = function (id) {
  this.state.id = id;
};

proto.getName = function () {
  return this.state.name;
};

proto.setName = function (name) {
  this.state.name = name;
};

proto.getTitle = function () {
  return this.state.title;
};

proto.setTitle = function (title) {
  return this.state.title = title;
};

proto.getChild = function () {
  return this.state.child;
};

proto.getFather = function () {
  return this.state.father;
};

proto.getState = function () {
  return this.state;
};

proto.getType = function () {
  return this.state.type;
};

proto.getFields = function () {
  var fields = {
    father: this.state.fatherField,
    child: this.state.childField
  };
  return fields;
};

proto.getFatherField = function () {
  return this.state.fatherField;
};

proto.getChildField = function () {
  return this.state.childField;
};

module.exports = Relation;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],626:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');
var Relation = require('./relation');

// class Relations
function Relations() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var relations = options.relations;
  //store relations

  this._relations = {};
  this._length = relations ? relations.length : 0;
  // to build relations between layers
  this._relationsInfo = {
    children: {}, // array child (unique ids)
    fathers: {}, // array father (unique ids)
    father_child: {} // info parent child
  };
  var relation = void 0;
  relations.forEach(function (relationConfig) {
    relation = new Relation(relationConfig);
    _this._relations[relation.getId()] = relation;
  });
  this._createRelationsInfo();
  base(this);
}

inherit(Relations, G3WObject);

var proto = Relations.prototype;

proto._createRelationsInfo = function () {
  var _this2 = this;

  var father = void 0;
  var child = void 0;
  (0, _entries2.default)(this._relations).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        relationKey = _ref2[0],
        relation = _ref2[1];

    father = relation.getFather();
    child = relation.getChild();
    _this2._relationsInfo.father_child[father + child] = relationKey;
    if (!_this2._relationsInfo.fathers[father]) {
      _this2._relationsInfo.fathers[father] = [];
    }
    if (!_this2._relationsInfo.children[child]) {
      _this2._relationsInfo.children[child] = [];
    }
    _this2._relationsInfo.fathers[father].push(child);
    _this2._relationsInfo.children[child].push(father);
  });
};

proto._clearRelationsInfo = function () {
  this._relationsInfo = {
    children: {},
    fathers: {},
    father_children: {}
  };
};

proto._reloadRelationsInfo = function () {
  this._clearRelationsInfo();
  this._createRelationsInfo();
};

// number of relations
proto.getLength = function () {
  return this._length;
};

proto.getRelations = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$type = _ref3.type,
      type = _ref3$type === undefined ? null : _ref3$type;

  if (!type) return this._relations;else {
    if (['ONE', 'MANY'].indexOf(type) !== -1) {
      var relations = {};
      for (var name in this._relations) {
        var relation = this._relations[name];
        if (relation.getType() === type) relations[name] = relation;
      }
      return relations;
    } else return {};
  }
};

// array of relation
proto.getArray = function () {
  var relations = [];
  (0, _entries2.default)(this._relations).forEach(function (_ref4) {
    var _ref5 = (0, _slicedToArray3.default)(_ref4, 2),
        relName = _ref5[0],
        relation = _ref5[1];

    relations.push(relation);
  });
  return relations;
};

proto.setRelations = function (relations) {
  this._relations = _.isArray(relations) ? relations : [];
};

proto.getRelationById = function (id) {
  return this._relations[id];
};

proto.getRelationByFatherChildren = function (father, child) {
  var relationId = this._relationsInfo.father_child[father + child];
  return this.getRelationById(relationId);
};

proto.addRelation = function (relation) {
  if (relation instanceof Relation) {
    this._relations[relation.getId()] = relation;
    this._reloadRelationsInfo();
  }
};

proto.removeRelation = function (relation) {
  var relationId = void 0;
  if (relation instanceof Relation) {
    relationId = relation.getId();
    delete this._relations[relationId];
    this._reloadRelationsInfo();
  }
};

proto.hasChildren = function (childId) {
  var children = this.getChildren(childId);
  return children ? !!children.length : false;
};

proto.hasFathers = function (fatherId) {
  var fathers = this.getFathers(fatherId);
  return fathers ? !!fathers.length : false;
};

// get children based on father id
proto.getChildren = function (fatherId) {
  if (!this.isFather(fatherId)) {
    return null;
  }
  return this._relationsInfo.fathers[fatherId];
};

// get fathers based on childId
proto.getFathers = function (childId) {
  if (!this.isChild(childId)) {
    return null;
  }
  return this._relationsInfo.children[childId];
};

proto.isChild = function (id) {
  return !!this._relationsInfo.children[id];
};

proto.isFather = function (id) {
  return !!this._relationsInfo.fathers[id];
};

module.exports = Relations;

},{"./relation":625,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],627:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var XHR = require('core/utils/utils').XHR;
var base = require('core/utils/utils').base;
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');

function RelationsService() {
  this.state = {};
  this._project = ProjectsRegistry.getCurrentProject();
  base(this);

  this.getRelations = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var projectId = this._project.state.id;
    var value = options.value || null;
    var id = options.id || null;
    var url = '/qdjango/api/relations/' + projectId + '/' + id + '/' + value;
    return XHR.get({
      url: url
    });
  };
}

inherit(RelationsService, G3WObject);

module.exports = RelationsService;

},{"core/g3wobject":569,"core/project/projectsregistry":624,"core/utils/utils":630}],628:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Base64 = require('core/utils/utils').Base64;
var G3WObject = require('core/g3wobject');

/*
 * RouterService based on  History.js (https://github.com/browserstate/history.js) e Crossroads (https://github.com/millermedeiros/crossroads.js)
 * Base concept is RouteQuery, example "map?point=21.2,42.1&zoom=12",
 * it inserts into browser and URL as quesrystring (q=map@point!21.2,41.1|zoom!12).
 * To run RouteQuery:
 *
 * RouterService.goto("map?point=21.2,42.1&zoom=12");
 *
 *To listen to router has to be add  RouterService.addRoute(pattern, callback). Es.:
 *
 * var route = RouterService.addRoute('map/{?query}',function(query){
 *  console.log(query.point);
 *  console.log(query.zoom);
 * });
 *
 * Patterns:
 *  "map/{foo}": la porzione "foo" is request, and is passed as parameter in callback
 *  "map/:foo:": la porzione "foo"  optional, 
 *  "map/:foo*: 
 *  "map/{?querystring}": mandatory
 *  "map/:?querystring:": optionals
 *
 * to remove  route:
 * RouterService.removeRoute(route);
*/

crossroads.ignoreState = true;
crossroads.greedy = true;

var RouterService = function RouterService() {

  this._initialLocationQuery;
  this._routeQuery = '';
  this.setters = {
    setRouteQuery: function setRouteQuery(routeQuery) {
      this._routeQuery = routeQuery;
      crossroads.parse(routeQuery);
    }
  };

  base(this);
};
inherit(RouterService, G3WObject);

var proto = RouterService.prototype;

proto.init = function () {
  //Return the querystring part of a URL
  var query = window.location.search;
  this._setRouteQueryFromLocationQuery(query);
};

proto.addRoute = function (pattern, handler, priority) {
  return crossroads.addRoute(pattern, handler, priority);
};

proto.removeRoute = function (route) {
  return crossroads.removeRoute(route);
};

proto.removeAllRoutes = function () {
  return crossroads.removeAllRoutes();
};

proto.parse = function (request, defaultArgs) {
  return crossroads.parse(request, defaultArgs);
};

proto.goto = function (routeQuery) {
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  if (routeQuery) {
    this.setRouteQuery(routeQuery);
  }
};

proto.makePermalink = function (routeQuery) {
  if (!this._initialQuery) {
    this._initialLocationQuery = this._stripInitialQuery(location.search.substring(1));
  }
  var encodedRouteQuery = this._encodeRouteQuery(routeQuery);
  //encodedRouteQuery = Base64.encode(encodedRouteQuery);
  return '?' + this._initialLocationQuery + '&q=' + this._encodeRouteQuery(routeQuery);
};

proto.makeQueryString = function (queryParams) {};

proto.slicePath = function (path) {
  return path.split('?')[0].split('/');
};

proto.sliceFirst = function (path) {
  var pathAndQuery = path.split('?');
  var queryString = pathAndQuery[1];
  var pathArr = pathAndQuery[0].split('/');
  var firstPath = pathArr[0];
  path = pathArr.slice(1).join('/');
  path = [path, queryString].join('?');
  return [firstPath, path];
};

proto.getQueryParams = function (query) {
  query = query.replace('?', '');
  var queryParams = {};
  var queryPairs = [];
  if (query != "" && query.indexOf("&") == -1) {
    queryPairs = [query];
  } else {
    queryPairs = query.split('&');
  }
  try {
    _.forEach(queryPairs, function (queryPair) {
      var pair = queryPair.split('=');
      var key = pair[0];
      var value = pair[1];
      queryParams[key] = value;
    });
  } catch (e) {}
  return queryParams;
};

proto.getQueryString = function (path) {
  return path.split('?')[1];
};

proto._getQueryPortion = function (query, queryKey) {
  var queryPortion;
  try {
    var queryPairs = query.split('&');
    var queryParams = {};
    _.forEach(queryPairs, function (queryPair) {
      var pair = queryPair.split('=');
      var key = pair[0];
      if (key == queryKey) {
        queryPortion = queryPair;
      }
    });
  } catch (e) {}
  return queryPortion;
};

proto._encodeRouteQuery = function (routeQuery) {
  routeQuery = routeQuery.replace('?', '@');
  routeQuery = routeQuery.replace('&', '|');
  routeQuery = routeQuery.replace('=', '!');
  return routeQuery;
};

proto._decodeRouteQuery = function (routeQuery) {
  routeQuery = routeQuery.replace('@', '?');
  routeQuery = routeQuery.replace('|', '&');
  routeQuery = routeQuery.replace('!', '=');
  return routeQuery;
};

proto._setRouteQueryFromLocationQuery = function (locationQuery) {
  var encodedRouteQuery = this._getRouteQueryFromLocationQuery(locationQuery);
  //encodedRouteQuery = Base64.decode(encodedRouteQuery);
  if (encodedRouteQuery) {
    var routeQuery = this._decodeRouteQuery(encodedRouteQuery);
    this.setRouteQuery(routeQuery);
  }
};

proto._getRouteQueryFromLocationQuery = function (locationQuery) {
  return this.getQueryParams(locationQuery)['q'];
};

proto._stripInitialQuery = function (locationQuery) {
  var previousQuery = this._getQueryPortion(locationQuery, 'q');
  if (previousQuery) {
    var previousQueryLength = previousQuery.length;
    var previousQueryPosition = locationQuery.indexOf(previousQuery);
    queryPrefix = _.trimEnd(locationQuery.substring(0, previousQueryPosition), "&");
    querySuffix = locationQuery.substring(previousQueryPosition + previousQueryLength);
    querySuffix = queryPrefix != "" ? querySuffix : _.trimStart(querySuffix, "&");
    locationQuery = queryPrefix + querySuffix;
  }
  return locationQuery;
};

module.exports = new RouterService();

},{"core/g3wobject":569,"core/utils/utils":630}],629:[function(require,module,exports){
var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Geometry = require('core/geometry/geometry');
var Filter = require('core/layers/filter/filter');
var MapLayersStoreRegistry = require('core/map/maplayersstoresregistry');

module.exports = {
  coordinatesToGeometry: function coordinatesToGeometry(geometryType, coordinates) {
    var geometryClass = void 0;
    switch (geometryType) {
      case Geometry.GeometryTypes.POLYGON:
        geometryClass = ol.geom.Polygon;
        break;
      case Geometry.GeometryTypes.MULTIPOLYGON:
        geometryClass = ol.geom.MultiPolygon;
        break;
      case Geometry.GeometryTypes.LINESTRING:
      case Geometry.GeometryTypes.LINE:
        geometryClass = ol.geom.LineString;
        break;
      case Geometry.GeometryTypes.MULTILINE:
      case Geometry.GeometryTypes.MULTILINESTRING:
        geometryClass = ol.geom.MultiLineString;
        break;
      case Geometry.GeometryTypes.POINT:
        geometryClass = ol.geom.Point;
        break;
      case Geometry.GeometryTypes.MULTIPOINT:
        geometryClass = ol.geom.MultiPoint;
        break;
      default:
        geometryClass = ol.geom.Point;
    }
    var geometry = new geometryClass(coordinates);
    return geometry;
  },
  shpToGeojson: function shpToGeojson(config, returnData) {
    var inputData = {};
    var EPSG4326 = "EPSG:4326";
    var EPSGUser = config.EPSG || EPSG4326;
    var url = config.url;
    var encoding = typeof config.encoding != 'utf-8' ? config.encoding : 'utf-8';
    function TransCoord(x, y) {
      var p = ol.proj.transform([parseFloat(x), parseFloat(y)], EPSGUser, EPSG4326);
      return { x: p[0], y: p[1] };
    }

    function shpLoader(data, returnData) {
      inputData['shp'] = data;
      if (inputData['shp'] && inputData['dbf']) if (returnData) returnData(toGeojson(inputData));
    }

    function dbfLoader(data, returnData) {
      inputData['dbf'] = data;
      if (inputData['shp'] && inputData['dbf']) if (returnData) returnData(toGeojson(inputData));
    }

    function toGeojson(geojsonData) {
      var geojson = {},
          features = [],
          feature = void 0,
          geometry = void 0,
          points = void 0;

      var shpRecords = geojsonData.shp.records;
      var dbfRecords = geojsonData.dbf.records;

      geojson.type = "FeatureCollection";
      min = TransCoord(geojsonData.shp.minX, geojsonData.shp.minY);
      max = TransCoord(geojsonData.shp.maxX, geojsonData.shp.maxY);
      geojson.bbox = [min.x, min.y, max.x, max.y];

      geojson.features = features;
      for (var i = 0; i < shpRecords.length; i++) {
        feature = {};
        feature.type = 'Feature';
        geometry = feature.geometry = {};
        properties = feature.properties = dbfRecords[i];

        // point : 1 , polyline : 3 , polygon : 5, multipoint : 8
        switch (shpRecords[i].shape.type) {
          case 1:
            geometry.type = "Point";
            var reprj = TransCoord(shpRecords[i].shape.content.x, shpRecords[i].shape.content.y);
            geometry.coordinates = [reprj.x, reprj.y];
            break;
          case 3:
          case 8:
            geometry.type = shpRecords[i].shape.type == 3 ? "LineString" : "MultiPoint";
            geometry.coordinates = [];
            for (var j = 0; j < shpRecords[i].shape.content.points.length; j += 2) {
              var _reprj = TransCoord(shpRecords[i].shape.content.points[j], shpRecords[i].shape.content.points[j + 1]);
              geometry.coordinates.push([_reprj.x, _reprj.y]);
            }
            break;
          case 5:
            geometry.type = "Polygon";
            geometry.coordinates = [];
            for (var pts = 0; pts < shpRecords[i].shape.content.parts.length; pts++) {
              var partsIndex = shpRecords[i].shape.content.parts[pts],
                  part = [];
              for (var _j = partsIndex * 2; _j < (shpRecords[i].shape.content.parts[pts + 1] * 2 || shpRecords[i].shape.content.points.length); _j += 2) {
                var point = shpRecords[i].shape.content.points;
                var _reprj2 = TransCoord(point[_j], point[_j + 1]);
                part.push([_reprj2.x, _reprj2.y]);
              }
              geometry.coordinates.push(part);
            }
            break;
          default:
        }
        if ("coordinates" in feature.geometry) features.push(feature);
      }
      return geojson;
    }

    var reader = new FileReader();
    reader.onload = function (e) {
      var URL = window.URL || window.webkitURL || window.mozURL || window.msURL,
          zip = new JSZip(e.target.result),
          shpString = zip.file(/.shp$/i)[0].name,
          dbfString = zip.file(/.dbf$/i)[0].name;
      SHPParser.load(URL.createObjectURL(new Blob([zip.file(shpString).asArrayBuffer()])), shpLoader, returnData);
      DBFParser.load(URL.createObjectURL(new Blob([zip.file(dbfString).asArrayBuffer()])), encoding, dbfLoader, returnData);
    };
    reader.readAsArrayBuffer(url);
  },

  createLayerStyle: function createLayerStyle(styleObj) {
    var style = void 0;
    var styles = {};
    if (styleObj) {
      (0, _entries2.default)(styleObj).forEach(function (_ref) {
        var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
            type = _ref2[0],
            config = _ref2[1];

        switch (type) {
          case 'point':
            if (config.icon) {
              styles.image = new ol.style.Icon({
                src: config.icon.url,
                imageSize: config.icon.width
              });
            }
            break;
          case 'line':
            styles.stroke = new ol.style.Stroke({
              color: config.color,
              width: config.width
            });
            break;
          case 'polygon':
            styles.fill = new ol.style.Fill({
              color: config.color
            });
            break;
        }
      });
      style = new ol.style.Style(styles);
    }
    return style;
  },

  createOlLayer: function createOlLayer() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var id = options.id;
    var geometryType = options.geometryType;
    var color = options.color;
    var style = options.style;
    // create ol layer to add to map
    var olSource = new ol.source.Vector({
      features: new ol.Collection()
    });
    var olLayer = new ol.layer.Vector({
      id: id,
      source: olSource
    });
    if (!style) {
      switch (geometryType) {
        case 'Point' || 'MultiPoint':
          style = new ol.style.Style({
            image: new ol.style.Circle({
              radius: 5,
              fill: new ol.style.Fill({
                color: color
              })
            })
          });
          break;
        case 'Line' || 'MultiLine':
          style = new ol.style.Style({
            stroke: new ol.style.Stroke({
              width: 3,
              color: color
            })
          });
          break;
        case 'Polygon' || 'MultiPolygon':
          style = new ol.style.Style({
            stroke: new ol.style.Stroke({
              color: color,
              width: 3
            }),
            fill: new ol.style.Fill({
              color: color
            })
          });
          olLayer.setOpacity(0.6);
      }
    }
    olLayer.setStyle(style);
    return olLayer;
  },

  createSelectedStyle: function createSelectedStyle(_ref3) {
    var geometryType = _ref3.geometryType;

    var style = null;
    if (geometryType === 'LineString' || geometryType === 'MultiLineString') {
      style = new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: 'rgb(255,255,0)',
          width: 4
        })
      });
    } else if (geometryType === 'Point' || geometryType === 'MultiPoint') {
      style = new ol.style.Style({
        image: new ol.style.Circle({
          radius: 6,
          fill: new ol.style.Fill({
            color: 'rgb(255,255,0)'
          })
        }),
        zIndex: Infinity
      });
    } else if (geometryType === 'MultiPolygon' || geometryType === 'Polygon') {
      style = new ol.style.Style({
        stroke: new ol.style.Stroke({
          color: 'rgb(255,255,0)',
          width: 4
        }),
        fill: new ol.style.Fill({
          color: 'rgba(255, 255, 0, 0.5)'
        })
      });
    }
    return style;
  },
  getAlphanumericPropertiesFromFeature: function getAlphanumericPropertiesFromFeature() {
    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    properties = Array.isArray(properties) ? properties : (0, _keys2.default)(properties);
    return properties.filter(function (property) {
      return ['boundedBy', 'geom', 'the_geom', 'geometry', 'bbox', 'GEOMETRY'].indexOf(property) === -1;
    });
  },
  getQueryLayersPromisesByCoordinates: function getQueryLayersPromisesByCoordinates(layers) {
    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        coordinates = _ref4.coordinates,
        map = _ref4.map,
        _ref4$feature_count = _ref4.feature_count,
        feature_count = _ref4$feature_count === undefined ? 10 : _ref4$feature_count,
        _ref4$querymultilayer = _ref4.querymultilayers,
        querymultilayers = _ref4$querymultilayer === undefined ? false : _ref4$querymultilayer;

    var d = $.Deferred();
    var size = map.getSize();
    if (!layers.length) return d.resolve(layers);
    var queryResponses = [];
    var mapProjection = map.getView().getProjection();
    var resolution = map.getView().getResolution();
    if (querymultilayers) {
      (function () {
        // const multiLayers = _.groupBy(layers, function(layer) {
        //   return layer.getMultiLayerId();
        // });
        var multiLayers = {};
        layers.forEach(function (layer) {
          var key = layer.getInfoFormat() + ':' + layer.getInfoUrl() + ':' + layer.getMultiLayerId();
          if (multiLayers[key]) multiLayers[key].push(layer);else multiLayers[key] = [layer];
        });
        var layersLenght = (0, _keys2.default)(multiLayers).length;
        for (var key in multiLayers) {
          var _multilayer = multiLayers[key];
          var _layers = _multilayer;
          var multilayer = multiLayers[key][0];
          var provider = multilayer.getProvider('query');
          provider.query({
            feature_count: feature_count,
            coordinates: coordinates,
            mapProjection: mapProjection,
            resolution: resolution,
            size: size,
            layers: _layers
          }).then(function (response) {
            queryResponses.push(response);
          }).always(function () {
            layersLenght -= 1;
            if (layersLenght === 0) d.resolve(queryResponses);
          });
        }
      })();
    } else {
      var layersLenght = layers.length;
      layers.forEach(function (layer) {
        layer.query({
          feature_count: feature_count,
          coordinates: coordinates,
          mapProjection: mapProjection,
          size: size,
          resolution: resolution
        }).then(function (response) {
          queryResponses.push(response);
        }).always(function () {
          layersLenght -= 1;
          if (layersLenght === 0) d.resolve(queryResponses);
        });
      });
    }
    return d.promise();
  },
  getQueryLayersPromisesByGeometry: function getQueryLayersPromisesByGeometry(layers) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var d = $.Deferred();
    var filterGeometry = options.geometry;
    var bbox = options.bbox;
    var projection = options.projection;
    var queryResponses = [];
    var feature_count = options.feature_count || 10;
    if (!layers.length) d.resolve([]);
    var mapCrs = projection.getCode();
    var multiLayers = _.groupBy(layers, function (layer) {
      return layer.getMultiLayerId() + '_' + layer.getProjection().getCode();
    });
    var layersLenght = (0, _keys2.default)(multiLayers).length;
    for (var key in multiLayers) {
      var filter = new Filter();
      var _multilayer = multiLayers[key];
      var _layers2 = _multilayer;
      var multilayer = multiLayers[key][0];
      var provider = multilayer.getProvider('filter');
      var layerCrs = multilayer.getProjection().getCode();
      if (mapCrs !== layerCrs) {
        if (bbox) {
          var geometry = ol.geom.Polygon.fromExtent(filterGeometry);
          filterGeometry = geometry.transform(mapCrs, layerCrs).getExtent();
        } else {
          filterGeometry = filterGeometry.clone().transform(mapCrs, layerCrs);
        }
      }
      bbox && filter.setBBOX(filterGeometry) || filter.setGeometry(filterGeometry);
      provider.query({
        filter: filter,
        layers: _layers2,
        feature_count: feature_count
      }).then(function (response) {
        queryResponses.push(response);
      }).always(function () {
        layersLenght -= 1;
        if (layersLenght === 0) d.resolve(queryResponses);
      });
    }
    return d.promise();
  },
  parseQueryLayersPromiseResponses: function parseQueryLayersPromiseResponses(responses) {
    var results = {
      query: responses[0] ? responses[0].query : null,
      data: []
    };
    responses.forEach(function (result) {
      if (result.data) result.data.forEach(function (data) {
        results.data.push(data);
      });
    });
    return results;
  },
  getMapLayersByFilter: function getMapLayersByFilter(filter) {
    filter = filter || {};
    var mapFilter = {
      GEOLAYER: true
    };
    (0, _assign2.default)(filter, mapFilter);
    var layers = [];
    MapLayersStoreRegistry.getQuerableLayersStores().forEach(function (layerStore) {
      layers = layerStore.getLayers(filter);
    });
    return layers || [];
  },
  dissolve: function dissolve() {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref5$features = _ref5.features,
        features = _ref5$features === undefined ? [] : _ref5$features,
        _ref5$index = _ref5.index,
        index = _ref5$index === undefined ? 0 : _ref5$index,
        _ref5$clone = _ref5.clone,
        clone = _ref5$clone === undefined ? false : _ref5$clone;

    var parser = new jsts.io.OL3Parser();
    var featuresLength = features.length;
    var dissolvedFeature = void 0;
    switch (featuresLength) {
      case 0:
        dissolvedFeature = null;
        break;
      case 1:
        dissolvedFeature = features[0];
        break;
      default:
        var baseFeature = dissolvedFeature = clone ? features[index].clone() : features[index];
        var baseFeatureGeometry = baseFeature.getGeometry();
        var baseFeatureGeometryType = baseFeatureGeometry.getType();
        var jstsdissolvedFeatureGeometry = parser.read(baseFeatureGeometry);
        for (var i = 0; i < featuresLength; i++) {
          if (index !== i) {
            var feature = features[i];
            jstsdissolvedFeatureGeometry = jstsdissolvedFeatureGeometry.union(parser.read(feature.getGeometry()));
          }
        }
        var dissolvedFeatureGeometry = parser.write(jstsdissolvedFeatureGeometry);
        var dissolvedFeatureGeometryType = dissolvedFeatureGeometry.getType();
        var dissolvedFeatuteGeometryCoordinates = dissolvedFeatureGeometryType === baseFeatureGeometryType ? dissolvedFeatureGeometry.getCoordinates() : baseFeatureGeometryType.indexOf('Multi') !== -1 && dissolvedFeatureGeometryType === baseFeatureGeometryType.replace('Multi', '') ? [dissolvedFeatureGeometry.getCoordinates()] : null;
        if (dissolvedFeatuteGeometryCoordinates) baseFeature.getGeometry().setCoordinates(dissolvedFeatuteGeometryCoordinates);else dissolvedFeature = null;
    }
    return dissolvedFeature;
  }
};

},{"babel-runtime/core-js/object/assign":10,"babel-runtime/core-js/object/entries":12,"babel-runtime/core-js/object/keys":14,"babel-runtime/helpers/slicedToArray":23,"core/geometry/geometry":571,"core/layers/filter/filter":584,"core/map/maplayersstoresregistry":612}],630:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Decimal adjustment of a number.
 *
 * @param {String}  type  The type of adjustment.
 * @param {Number}  value The number.
 * @param {Integer} exp   The exponent (the 10 logarithm of the adjustment base).
 * @returns {Number} The adjusted value.
 */
function decimalAdjust(type, value, exp) {
  // If the exp is undefined or zero...
  if (typeof exp === 'undefined' || +exp === 0) {
    return Math[type](value);
  }
  value = +value;
  exp = +exp;
  // If the value is not a number or the exp is not an integer...
  if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
    return NaN;
  }
  // Shift
  value = value.toString().split('e');
  value = Math[type](+(value[0] + 'e' + (value[1] ? +value[1] - exp : -exp)));
  // Shift back
  value = value.toString().split('e');
  return +(value[0] + 'e' + (value[1] ? +value[1] + exp : exp));
}

// Decimal round
if (!Math.round10) {
  Math.round10 = function (value, exp) {
    return decimalAdjust('round', value, exp);
  };
}
// Decimal floor
if (!Math.floor10) {
  Math.floor10 = function (value, exp) {
    return decimalAdjust('floor', value, exp);
  };
}
// Decimal ceil
if (!Math.ceil10) {
  Math.ceil10 = function (value, exp) {
    return decimalAdjust('ceil', value, exp);
  };
}

String.prototype.hashCode = function () {
  var hash = 0,
      i = void 0,
      chr = void 0,
      len = void 0;
  if (this.length === 0) return hash;
  for (i = 0, len = this.length; i < len; i++) {
    chr = this.charCodeAt(i);
    hash = (hash << 5) - hash + chr;
    hash |= 0;
  }
  return hash;
};

var Base64 = { _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", encode: function encode(e) {
    var t = "";var n = void 0,
        r = void 0,
        i = void 0,
        s = void 0,
        o = void 0,
        u = void 0,
        a = void 0;var f = 0;e = Base64._utf8_encode(e);while (f < e.length) {
      n = e.charCodeAt(f++);r = e.charCodeAt(f++);i = e.charCodeAt(f++);s = n >> 2;o = (n & 3) << 4 | r >> 4;u = (r & 15) << 2 | i >> 6;a = i & 63;if (isNaN(r)) {
        u = a = 64;
      } else if (isNaN(i)) {
        a = 64;
      }t = t + this._keyStr.charAt(s) + this._keyStr.charAt(o) + this._keyStr.charAt(u) + this._keyStr.charAt(a);
    }return t;
  }, decode: function decode(e) {
    var t = "";var n = void 0,
        r = void 0,
        i = void 0;var s = void 0,
        o = void 0,
        u = void 0,
        a = void 0;var f = 0;e = e.replace(/[^A-Za-z0-9+/=]/g, "");while (f < e.length) {
      s = this._keyStr.indexOf(e.charAt(f++));o = this._keyStr.indexOf(e.charAt(f++));u = this._keyStr.indexOf(e.charAt(f++));a = this._keyStr.indexOf(e.charAt(f++));n = s << 2 | o >> 4;r = (o & 15) << 4 | u >> 2;i = (u & 3) << 6 | a;t = t + String.fromCharCode(n);if (u != 64) {
        t = t + String.fromCharCode(r);
      }if (a != 64) {
        t = t + String.fromCharCode(i);
      }
    }t = Base64._utf8_decode(t);return t;
  }, _utf8_encode: function _utf8_encode(e) {
    e = e.replace(/rn/g, "n");var t = "";for (var n = 0; n < e.length; n++) {
      var r = e.charCodeAt(n);if (r < 128) {
        t += String.fromCharCode(r);
      } else if (r > 127 && r < 2048) {
        t += String.fromCharCode(r >> 6 | 192);t += String.fromCharCode(r & 63 | 128);
      } else {
        t += String.fromCharCode(r >> 12 | 224);t += String.fromCharCode(r >> 6 & 63 | 128);t += String.fromCharCode(r & 63 | 128);
      }
    }return t;
  }, _utf8_decode: function _utf8_decode(e) {
    var t = "";var n = 0;var r = c1 = c2 = 0;while (n < e.length) {
      r = e.charCodeAt(n);if (r < 128) {
        t += String.fromCharCode(r);n++;
      } else if (r > 191 && r < 224) {
        c2 = e.charCodeAt(n + 1);t += String.fromCharCode((r & 31) << 6 | c2 & 63);n += 2;
      } else {
        c2 = e.charCodeAt(n + 1);c3 = e.charCodeAt(n + 2);t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);n += 3;
      }
    }return t;
  } };

var _uid = 0;

var utils = {
  getUniqueDomId: function getUniqueDomId() {
    _uid += 1;
    return _uid + '_' + Date.now();
  },

  uniqueId: function uniqueId() {
    return utils.getUniqueDomId();
  },

  basemixin: function mixin(destination, source) {
    return utils.merge(destination.prototype, source);
  },

  mixin: function mixininstance(destination, source) {
    var sourceInstance = new source();
    utils.merge(destination, sourceInstance);
    utils.merge(destination.prototype, source.prototype);
  },
  merge: function merge(destination, source) {
    var key = void 0;
    for (key in source) {
      if (utils.hasOwn(source, key)) {
        destination[key] = source[key];
      }
    }
  },
  hasOwn: function hasOwn(object, key) {
    return Object.prototype.hasOwnProperty.call(object, key);
  },
  // google closure library impememtation
  inherit: function inherit(childCtor, parentCtor) {
    function tempCtor() {}
    tempCtor.prototype = parentCtor.prototype;
    childCtor.superClass_ = parentCtor.prototype;
    childCtor.prototype = new tempCtor();
    childCtor.prototype.constructor = childCtor;
  },
  // goole closure library implementation
  base: function base(me, opt_methodName, var_args) {
    // who call base
    var caller = arguments.callee.caller;
    if (caller.superClass_) {
      // This function constructor (that inherith from superClass_). Call the superclass constructor.
      //It is a easy way to cal super class in binding to this
      return caller.superClass_.constructor.apply(me, Array.prototype.slice.call(arguments, 1));
    }
    var args = Array.prototype.slice.call(arguments, 2);
    var foundCaller = false;
    //constructor is the costructor function of the object
    for (var ctor = me.constructor; ctor; ctor = ctor.superClass_ && ctor.superClass_.constructor) {
      if (ctor.prototype[opt_methodName] === caller) {
        foundCaller = true;
      } else if (foundCaller) {
        return ctor.prototype[opt_methodName].apply(me, args);
      }
    }
    // If we did not find the caller in the prototype chain,
    // then one of two things happened:
    // 1) The caller is an instance method.
    // 2) This method was not called by the right caller.
    if (me[opt_methodName] === caller) {
      // call the function from prototype object
      return me.constructor.prototype[opt_methodName].apply(me, args);
    } else {
      throw Error('base called from a method of one name ' + 'to a method of a different name');
    }
  },

  noop: function noop() {},

  truefnc: function truefnc() {
    return true;
  },

  falsefnc: function falsefnc() {
    return true;
  },

  resolve: function resolve(value) {
    var d = $.Deferred();
    d.resolve(value);
    return d.promise();
  },

  reject: function reject(value) {
    var d = $.Deferred();
    d.reject(value);
    return d.promise();
  },

  getValueFromG3WObjectEvent: function getValueFromG3WObjectEvent() {
    //TODO
  },
  getAjaxResponses: function getAjaxResponses() {
    var listRequests = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var requestsLenght = listRequests.length;
    var d = $.Deferred();
    var DoneRespones = [];
    var FailedResponses = [];
    listRequests.forEach(function (request) {
      request.then(function (response) {
        DoneRespones.push(response);
      }).fail(function (err) {
        FailedResponses.push(err);
      }).always(function () {
        requestsLenght = requestsLenght > 0 ? requestsLenght - 1 : requestsLenght;
        if (requestsLenght === 0) d.resolve({
          done: DoneRespones,
          fail: FailedResponses
        });
      });
    });
    return d.promise();
  },
  sanitizeUrl: function sanitizeUrl() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        url = _ref.url,
        _ref$reserverParamete = _ref.reserverParameters,
        reserverParameters = _ref$reserverParamete === undefined ? [] : _ref$reserverParamete;

    var checkUrl = new URL(url);
    reserverParameters.forEach(function (param) {
      var _params = [param.toUpperCase(), param.toLowerCase()];
      for (var i = 0; i < 2; i++) {
        var _param = _params[i];
        var _value = checkUrl.searchParams.get(_param);
        if (_value) {
          url = url.replace(_param + '=' + _value, '');
          break;
        }
      }
    });
    return url;
  },


  convertObjectToUrlParams: function convertObjectToUrlParams() {
    var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return $.param(params);
  },
  // Appends query parameters to a URI
  appendParams: function appendParams(uri, params) {
    var keyParams = [];
    // Skip any null or undefined parameter values
    (0, _keys2.default)(params).forEach(function (k) {
      if (params[k] !== null && params[k] !== undefined) {
        keyParams.push(k + '=' + encodeURIComponent(params[k]));
      }
    });
    var qs = keyParams.join('&');
    // remove any trailing ? or &
    uri = uri.replace(/[?&]$/, '');
    // append ? or & depending on whether uri has existing parameters
    uri = uri.indexOf('?') === -1 ? uri + '?' : uri + '&';
    return uri + qs;
  },
  imageToDataURL: function imageToDataURL(_ref2) {
    var src = _ref2.src,
        _ref2$type = _ref2.type,
        type = _ref2$type === undefined ? 'image/jpeg' : _ref2$type,
        _ref2$callback = _ref2.callback,
        callback = _ref2$callback === undefined ? function () {} : _ref2$callback;

    var image = new Image();
    image.onload = function () {
      var canvas = document.createElement('canvas');
      var context = canvas.getContext('2d');
      canvas.height = this.naturalHeight;
      canvas.width = this.naturalWidth;
      context.drawImage(this, 0, 0);
      var dataURL = canvas.toDataURL(type);
      callback(dataURL);
    };
    image.src = src;
  },
  capitalize_first_letter: function capitalize_first_letter(string) {
    return '' + string[0].toUpperCase() + string.slice(1);
  },

  Base64: Base64,
  // build throttle function
  throttle: function throttle(fnc) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;

    var lastCall = void 0;
    return function () {
      var previousCall = lastCall;
      lastCall = Date.now();
      if (previousCall === undefined // function is being called for the first time
      || lastCall - previousCall > delay) {
        // throttle time has elapsed
        fnc.apply(undefined, arguments);
      }
    };
  },
  //build debounce function
  debounce: function debounce(func) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 500;

    var timeout = void 0;
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      clearTimeout(timeout);
      timeout = setTimeout(function () {
        func.apply(undefined, args);
      }, delay);
    };
  },

  XHR: {
    get: function get() {
      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          url = _ref3.url,
          _ref3$params = _ref3.params,
          params = _ref3$params === undefined ? {} : _ref3$params;

      return new _promise2.default(function (resolve, reject) {
        if (url) {
          $.get(url, params).then(function (result) {
            resolve(result);
          }).fail(function (err) {
            reject(err);
          });
        } else {
          reject('No url');
        }
      });
    },
    post: function post() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          url = _ref4.url,
          data = _ref4.data,
          _ref4$formdata = _ref4.formdata,
          formdata = _ref4$formdata === undefined ? false : _ref4$formdata,
          contentType = _ref4.contentType;

      return new _promise2.default(function (resolve, reject) {
        if (formdata) {
          var _formdata = new FormData();
          for (var param in data) {
            _formdata.append(param, data[param]);
          }
          $.ajax({
            type: 'POST',
            url: url,
            data: _formdata,
            processData: false,
            contentType: false
          }).then(function (response) {
            resolve(response);
          }).fail(function (error) {
            reject(error);
          });
        } else if (contentType) {
          $.ajax({
            type: 'POST',
            url: url,
            data: data,
            processData: false,
            contentType: contentType || false
          }).then(function (response) {
            resolve(response);
          }).fail(function (error) {
            reject(error);
          });
        } else {
          $.post(url, data).then(function (response) {
            resolve(response);
          }).fail(function (error) {
            reject(error);
          });
        }
      });
    },
    htmlescape: function htmlescape(string) {
      string = string.replace("&", "&amp;");
      string = string.replace("<", "&lt;");
      string = string.replace(">", "&gt;");
      string = string.replace('"', "&quot;");
      return string;
    },
    fileDownload: function fileDownload() {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          url = _ref5.url,
          data = _ref5.data,
          _ref5$httpMethod = _ref5.httpMethod,
          httpMethod = _ref5$httpMethod === undefined ? "POST" : _ref5$httpMethod;

      return new _promise2.default(function (resolve, reject) {
        $.fileDownload(url, {
          httpMethod: httpMethod,
          data: data,
          successCallback: function successCallback() {
            resolve();
          },
          failCallback: function failCallback() {
            reject();
          }
        });
      });
    }
  }
};

module.exports = utils;

},{"babel-runtime/core-js/object/keys":14,"babel-runtime/core-js/promise":16}],631:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function CheckBoxValidator(options) {
  base(this, options);
  this.validate = function (value) {
    var values = this.options.values || [];
    return values.indexOf(value) !== -1;
  };
}

inherit(CheckBoxValidator, Validator);

module.exports = CheckBoxValidator;

},{"./validator":637,"core/utils/utils":630}],632:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function DateTimePickerValidator(options) {
  base(this, options);
  this.validate = function (value, options) {
    var fielddatetimeformat = options.fielddatetimeformat;
    return moment(value, fielddatetimeformat, true).isValid();
  };
}
inherit(DateTimePickerValidator, Validator);

module.exports = DateTimePickerValidator;

},{"./validator":637,"core/utils/utils":630}],633:[function(require,module,exports){
var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function FloatValidator(options) {
  base(this, options);
  this.validate = function (value) {
    var float = Number(1 * value);
    return !(0, _isNan2.default)(float) && float <= 2147483647;
  };
}

inherit(FloatValidator, Validator);

module.exports = FloatValidator;

},{"./validator":637,"babel-runtime/core-js/number/is-nan":8,"core/utils/utils":630}],634:[function(require,module,exports){
var _isSafeInteger = require('babel-runtime/core-js/number/is-safe-integer');

var _isSafeInteger2 = _interopRequireDefault(_isSafeInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function IntegerValidator(options) {
  base(this, options);
  this.validate = function (value) {
    var integer = 1 * value;
    return !_.isNaN(integer) ? (0, _isSafeInteger2.default)(integer) && integer <= 2147483647 : false;
  };
}

inherit(IntegerValidator, Validator);

module.exports = IntegerValidator;

},{"./validator":637,"babel-runtime/core-js/number/is-safe-integer":9,"core/utils/utils":630}],635:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function RadioValidator(options) {
  base(this, options);
}

inherit(RadioValidator, Validator);

module.exports = RadioValidator;

},{"./validator":637,"core/utils/utils":630}],636:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Validator = require('./validator');

function RangeValidator() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.validate = function (value) {
    value = 1 * value;
    return value >= this.options.min && value <= this.options.max;
  };
}

inherit(RangeValidator, Validator);

module.exports = RangeValidator;

},{"./validator":637,"core/utils/utils":630}],637:[function(require,module,exports){
function InputValidator() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.options = options;
  this.validate = function () {
    return true; // always true. Generic validator
  };
}

module.exports = InputValidator;

},{}],638:[function(require,module,exports){
var Validators = {
  validators: {
    float: require('./float'),
    integer: require('./integer'),
    checkbox: require('./checkbox'),
    datetimepicker: require('./datetimepicker'),
    text: require('./validator'),
    string: require('./validator'),
    radio: require('./radio'),
    default: require('./validator'),
    range: require('./range')
  },

  get: function get(type) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var Validator = this.validators[type] || this.validators.default;
    return new Validator(options);
  }
};

module.exports = Validators;

},{"./checkbox":631,"./datetimepicker":632,"./float":633,"./integer":634,"./radio":635,"./range":636,"./validator":637}],639:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

//Class Flow of workflow step by step
function Flow() {
  var steps = [];
  var inputs = void 0;
  var counter = 0;
  var context = null;
  var d = void 0;
  var _workflow = void 0;
  //start workflow
  this.start = function (workflow) {
    d = $.Deferred();
    if (counter > 0) {
      console.log("reset workflow before restarting");
    }
    _workflow = workflow;
    inputs = workflow.getInputs();
    context = workflow.getContext();
    steps = workflow.getSteps();
    // check if there are steps
    if (steps && steps.length) {
      //run step (first)
      this.runStep(steps[0], inputs, context);
    }
    // return a promise that will be reolved if all step go right
    return d.promise();
  };

  //run step
  this.runStep = function (step, inputs) {
    var _this = this;

    //run step that run task
    _workflow.setMessages({
      help: step.state.help
    });
    step.run(inputs, context).then(function (outputs) {
      _this.onDone(outputs);
    }).fail(function (error) {
      _this.onError(error);
    });
  };

  //check if all step are resolved
  this.onDone = function (outputs) {
    counter++;
    if (counter == steps.length) {
      counter = 0;
      d.resolve(outputs);
      return;
    }
    this.runStep(steps[counter], outputs);
  };

  // in case of error
  this.onError = function (err) {
    // error step
    //console.log('step error: ', err);
    // reset counter to 0
    counter = 0;
    d.reject(err);
  };

  // stop flow
  this.stop = function () {
    var d = $.Deferred();
    //vcheck the counter
    steps[counter].isRunning() ? steps[counter].stop() : null;
    if (counter > 0) {
      // set counter to 0
      counter = 0;
      // reject flow
      d.reject();
    } else {
      //reject to force rollback session
      d.resolve();
    }
    return d.promise();
  };

  base(this);
}

inherit(Flow, G3WObject);

module.exports = Flow;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],640:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Step() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  this._inputs = options.inputs || null;
  this._task = options.task || null;
  this._outputs = options.outputs || null;
  //dynamic state of step
  this.state = {
    id: options.id || null,
    name: options.name || null,
    help: options.help || null, // help to show wat the user has to do
    running: false, // running
    error: null, // error
    message: options.message || null // message
  };
}

inherit(Step, G3WObject);

var proto = Step.prototype;

// method to start task
proto.run = function (inputs, context) {
  var _this = this;

  //emit run
  this.emit('run', { inputs: inputs, context: context });
  var d = $.Deferred();
  if (this._task) {
    try {
      // change state to running
      this.state.running = true;
      this._task.run(inputs, context).then(function (outups) {
        _this.stop();
        d.resolve(outups);
      }).fail(function (err) {
        _this.stop();
        d.reject(err);
      });
    } catch (err) {
      this.state.error = err;
      this.state.error = 'Problem ..';
      this.stop();
      d.reject(err);
    }
  }
  return d.promise();
};

// stop step
proto.stop = function () {
  // stop task
  this._task.stop();
  // running to false
  this.state.running = false;
  //emit run
  this.emit('stop');
};

// revert task
proto.revert = function () {
  if (this._task && this._task.revert) {
    this._task.revert();
  }
};

//panic
proto.panic = function () {
  if (this._task && this._task.panic) {
    this._task.panic();
  }
};

proto.getId = function () {
  return this.state.id;
};

proto.getName = function () {
  return this.state.name;
};

proto.getHelp = function () {
  return this.state.help;
};

proto.getError = function () {
  return this.state.error;
};

proto.getMessage = function () {
  return this.state.message;
};

proto.isRunning = function () {
  return this.state.running;
};

proto.setInputs = function (inputs) {
  this._inputs = inputs;
};

proto.getInputs = function () {
  return this._inputs;
};

proto.setTask = function (task) {
  this._task = task;
};

proto.getTask = function () {
  return this._task;
};

proto.setOutputs = function (outputs) {
  this._outputs = outputs;
};

proto.getOutputs = function () {
  return this._outputs;
};

Step.MESSAGES = {
  help: null
};

module.exports = Step;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],641:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var G3WObject = require('core/g3wobject');

function Task() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.state = {
    usermessagesteps: {}
  };
}

inherit(Task, G3WObject);

var proto = Task.prototype;

proto.revert = function () {
  console.log('Revert to implemente ');
};

proto.panic = function () {
  console.log('Panic to implement ..');
};

proto.stop = function () {
  console.log('Task Stop to implement ..');
};

proto.run = function () {
  console.log('Wrong. This method has to be overwrite from task');
};

proto.setRoot = function (task) {
  this.state.root = task;
};

proto.getUserMessageSteps = function () {
  return this.state.usermessagesteps;
};

proto.setUserMessageSteps = function () {
  var steps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.state.usermessagesteps = steps;
};

proto.setUserMessageStepDone = function (type) {
  if (type) this.state.usermessagesteps[type].done = true;
};

module.exports = Task;

},{"core/g3wobject":569,"core/utils//utils":630,"core/utils/utils":630}],642:[function(require,module,exports){
var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var resolve = require('core/utils/utils').resolve;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils//utils').base;
var t = require('core/i18n/i18n.service').t;
var G3WObject = require('core/g3wobject');
var Flow = require('./flow');
var WorkflowsStack = require('./workflowsstack');
var MESSAGES = require('./step').MESSAGES;
var createUserMessageStepsFactory = require('gui/workflow/createUserMessageStepsFactory');
var GUI = require('gui/gui');
//Class to manage flow of steps
function Workflow() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  // inputs mandatory to work with editing
  this._inputs = options.inputs || null;
  this._context = options.context || null;
  // flow object to control the flow
  this._flow = options.flow || new Flow();
  // all steps of flow
  this._steps = options.steps || [];
  // if is child of another workflow
  this._child = null;
  // stack workflowindex
  this._stackIndex = null;
  this._messages = MESSAGES;
  this._userMessageSteps = this._steps.reduce(function (messagesSteps, step) {
    var usermessagesteps = step.getTask().getUserMessageSteps();
    return usermessagesteps && (0, _extends3.default)({}, messagesSteps, usermessagesteps) || messagesSteps;
  }, {});
}

inherit(Workflow, G3WObject);

var proto = Workflow.prototype;

proto.getContextService = function () {
  var context = this.getContext();
  return context.service;
};

proto.setContextService = function (service) {
  var context = this.getContext();
  context.service = service;
};

proto.getStackIndex = function () {
  return this._stackIndex;
};

proto.addChild = function (workflow) {
  if (this._child) this._child.addChild(workflow);else {
    this._child = workflow;
  }
};

proto.removeChild = function () {
  if (this._child) {
    var index = this._child.getStackIndex();
    WorkflowsStack.removeAt(index);
  }

  this._child = null;
};

proto._setInputs = function (inputs) {
  this._inputs = inputs;
};

proto.getInputs = function () {
  return this._inputs;
};

proto.setContext = function (context) {
  this._context = context;
};

proto.getContext = function () {
  return this._context;
};

proto.getFlow = function () {
  return this._flow;
};

proto.setFlow = function (flow) {
  this._flow = flow;
};

proto.addStep = function (step) {
  this._steps.push(step);
};

proto.setSteps = function (steps) {
  this._steps = steps;
};

proto.getSteps = function () {
  return this._steps;
};

proto.getStep = function (index) {
  return this._steps[index];
};

proto.setMessages = function (messages) {
  (0, _assign2.default)(this._messages, messages);
  /*for (let messageKey in messages) {
    this._messages[messageKey] = messages[messageKey];
  }*/
};

proto.getMessages = function () {
  return this._messages;
};

proto.clearMessages = function () {
  this._messages.help = null;
  this._isThereUserMessaggeSteps() && this.clearUserMessagesSteps();
};

proto.getLastStep = function () {
  var length = this._steps.length;
  if (length) {
    return this._steps[length];
  }
  return null;
};

proto.getRunningStep = function () {
  return this._steps.find(function (step) {
    return step.isRunning();
  });
};

//stop all workflow children
proto._stopChild = function () {
  return this._child ? this._child.stop() : resolve();
};

proto._isThereUserMessaggeSteps = function () {
  return (0, _keys2.default)(this._userMessageSteps).length;
};

// start workflow
proto.start = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var d = $.Deferred();
  this._inputs = options.inputs;
  this._context = options.context || {};
  //check if are workflow running
  if (WorkflowsStack.getLength() && WorkflowsStack.getCurrent() !== this) {
    WorkflowsStack.getCurrent().addChild(this);
  }
  this._stackIndex = WorkflowsStack.push(this);
  this._flow = options.flow || this._flow;
  this._steps = options.steps || this._steps;
  var showUserMessage = this._isThereUserMessaggeSteps();
  if (showUserMessage) {
    var stepsComponent = createUserMessageStepsFactory({
      steps: this._userMessageSteps
    });
    GUI.showUserMessage({
      title: t('sdk.workflow.steps.title'),
      type: 'tool',
      position: 'left',
      size: 'small',
      hooks: {
        body: stepsComponent
      }
    });
  }

  this._flow.start(this).then(function (outputs) {
    showUserMessage && setTimeout(function () {
      _this.clearUserMessagesSteps();
      d.resolve(outputs);
    }, 500) || d.resolve(outputs);
  }).fail(function (error) {
    if (showUserMessage) {
      _this.clearUserMessagesSteps();
    }
    d.reject(error);
  });

  return d.promise();
};

// stop workflow during flow
proto.stop = function () {
  var _this2 = this;

  ////console.log('Workflow stopping .... ');
  var d = $.Deferred();
  // stop child workflow indpendent from father workflow
  this._stopChild()
  // in every case remove child
  .always(function () {
    _this2.removeChild();
    WorkflowsStack.removeAt(_this2.getStackIndex());
    // call stop flow
    _this2._flow.stop() // ritorna una promessa
    .then(function () {
      d.resolve();
    }).fail(function (err) {
      // mi serve per capire cosa fare
      d.reject(err);
    }).always(function () {
      _this2.clearMessages();
    });
  });
  return d.promise();
};

proto.clearUserMessagesSteps = function () {
  this._resetUserMessaggeStepsDone();
  GUI.closeUserMessage();
};

proto._resetUserMessaggeStepsDone = function () {
  var _this3 = this;

  (0, _keys2.default)(this._userMessageSteps).forEach(function (type) {
    _this3._userMessageSteps[type].done = false;
  });
};

module.exports = Workflow;

},{"./flow":639,"./step":640,"./workflowsstack":643,"babel-runtime/core-js/object/assign":10,"babel-runtime/core-js/object/keys":14,"babel-runtime/helpers/extends":22,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/utils//utils":630,"core/utils/utils":630,"gui/gui":710,"gui/workflow/createUserMessageStepsFactory":816}],643:[function(require,module,exports){
// Store all workflow activated

var WorkFlowsStack = function WorkFlowsStack() {
  this._workflows = [];
  this.push = function (workflow) {
    if (this._workflows.indexOf(workflow) === -1) return this._workflows.push(workflow) - 1;
    return this._workflows.indexOf(workflow);
  };

  this.getParent = function () {
    var index = this._getCurrentIndex();
    return index > 0 && this._workflows[index - 1];
  };

  this.pop = function () {
    return this._workflows.pop();
  };

  this.getLength = function () {
    return this._workflows.length;
  };

  this._getCurrentIndex = function () {
    var currentWorkflow = this.getCurrent();
    return this._workflows.findIndex(function (workfow) {
      return workfow === currentWorkflow;
    });
  };

  this.getCurrent = function () {
    return this.getLast();
  };

  this.getLast = function () {
    var length = this._workflows.length;
    return length ? this._workflows[length - 1] : null;
  };

  this.getFirst = function () {
    return this._workflows[0];
  };

  this.removeAt = function (index) {
    this._workflows.splice(index, 1);
  };

  this.getAt = function (index) {
    return this._workflows[index];
  };

  this.insertAt = function (index, workflow) {
    this._workflows[index] = workflow;
  };
};

module.exports = new WorkFlowsStack();

},{}],644:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
var GOOGLE_API_KEY = exports.GOOGLE_API_KEY = '<INSERT HERE YOUR GOOGLE API KEY>';
var BING_API_KEY = exports.BING_API_KEY = 'Am_mASnUA-jtW3O3MxIYmOOPLOvL39dwMvRnyoHxfKf_EPNYgfWM9imqGETWKGVn';

},{}],645:[function(require,module,exports){
var Control = require('./control');
function AddLayersControl() {
  var options = {
    name: "addlayer",
    tipLabel: "AddLayer",
    label: "\uE907"
  };
  Control.call(this, options);
  this._layerstore = null;
}

ol.inherits(AddLayersControl, Control);

var proto = AddLayersControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  Control.prototype.setMap.call(this, map);
  $(this.element).on('click', function () {
    _this.dispatchEvent('addlayer');
  });
};

proto.layout = function (map) {
  Control.prototype.layout.call(this, map);
};

proto.getLayersSore = function () {
  return this._layerstore;
};

proto.setLayersStore = function (layersStore) {
  this._layerstore = layersStore;
};

module.exports = AddLayersControl;

},{"./control":647}],646:[function(require,module,exports){
var utils = require('../utils');
var AreaIteraction = require('../interactions/areainteraction');
var MeasureControl = require('./measurecontrol');

var AreaControl = function AreaControl(options) {
  var _options = {
    name: "Area",
    label: '\uE909',
    interactionClass: AreaIteraction
  };
  options = utils.merge(options, _options);
  MeasureControl.call(this, options);
};

ol.inherits(AreaControl, MeasureControl);

module.exports = AreaControl;

},{"../interactions/areainteraction":666,"../utils":677,"./measurecontrol":651}],647:[function(require,module,exports){
var layout = require('./utils').layout;
var Control = function Control(options) {
  var name = options.name || "";
  this.name = name.split(' ').join('-').toLowerCase();
  this.id = this.name + '_' + Math.floor(Math.random() * 1000000);
  this.eventKeys = {}; // store eventKey and original havenHandler
  /*
    tl: top-left
    tr: top-right
    bl: bottom-left
    bt: bottom-right
   */
  this.positionCode = options.position || 'tl';
  this.priority = options.priority || 0;
  if (!options.element) {
    var className = "ol-" + this.name.split(' ').join('-').toLowerCase();
    var customClass = options.customClass;
    var tipLabel = options.tipLabel || this.name;
    var label = options.label || '';
    options.element = $('<div class="' + className + ' ol-unselectable ol-control"><button type="button" title="' + tipLabel + '">' + label + '<i class="' + customClass + '"></i></button></div>')[0];
  }
  var buttonClickHandler = options.buttonClickHandler || Control.prototype._handleClick.bind(this);
  $(options.element).on('click', buttonClickHandler);
  ol.control.Control.call(this, options);
  this._postRender();
};

// sotto classse della classe Control di OL3
ol.inherits(Control, ol.control.Control);

var proto = Control.prototype;

proto.setEventKey = function (_ref) {
  var eventType = _ref.eventType,
      eventKey = _ref.eventKey;

  this.eventKeys[eventType] = {
    eventKey: eventKey,
    originalHandler: eventKey.linstener
  };
};

proto.resetOriginalHandlerEvent = function (eventType) {
  var eventKey = this.eventKeys[eventType].eventKey;
  eventKey && ol.Observable.unByKey(eventKey);
  this.eventKeys[eventType].eventKey = this.on(eventType, this.eventKeys[eventType].originalHandler);
};

proto.overwriteEventHandler = function (_ref2) {
  var eventType = _ref2.eventType,
      handler = _ref2.handler;

  var eventKey = this.eventKeys[eventType].eventKey;
  eventKey && ol.Observable.unByKey(eventKey);
  this.eventKeys[eventType].eventKey = this.on(eventType, handler);
};

proto.getPosition = function (positionCode) {
  positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = positionCode.indexOf('t') > -1 ? true : false;
  position['left'] = positionCode.indexOf('l') > -1 ? true : false;
  position['bottom'] = positionCode.indexOf('b') > -1 ? true : false;
  position['right'] = positionCode.indexOf('r') > -1 ? true : false;
  return position;
};

proto._handleClick = function (event) {
  var _this = this;

  event.preventDefault();
  var map = this.getMap();
  var resetControl = null;
  // remove all the other, eventually toggled, interactioncontrols
  var controls = map.getControls();
  controls.forEach(function (control) {
    if (control.id && control.toggle && control.id !== _this.id) {
      control.toggle(false);
      if (control.name === 'reset') {
        resetControl = control;
      }
    }
  });
  if (!this._toggled && resetControl) {
    resetControl.toggle(true);
  }
  this.dispatchEvent('controlclick');
};

//shift of control position
proto.shiftPosition = function (position) {
  $(this.element).css(hWhere, position + 'px');
};

// layout handler
proto.layout = function (map) {
  if (map) {
    var position = this.getPosition();
    var element = $(this.element);
    layout({ map: map, position: position, element: element });
  }
};

// change layout of controls // overwrite to customize beahviour
proto.changelayout = function (map) {};

proto.showHide = function () {
  $(this.element).toggle();
};

//called when a control is added ore removed to map (added: map is an ol.Map instance , removed map is null)
proto.setMap = function (map) {
  if (map) {
    this.layout(map);
    ol.control.Control.prototype.setMap.call(this, map);
  }
};

//hide control and move all controls that sit on his right position
proto.hideControl = function () {
  var position = $(this.element).position().left;
  var controlWidth = $(this.element).outerWidth();
  var newPosition = position;
  var controls = $(this.element).siblings('.ol-control-tl');
  controls.each(function () {
    if ($(this).position().left > position) {
      newPosition = $(this).position().left;
      if (controlWidth > $(this).outerWidth()) {
        position = position + (controlWidth - $(this).outerWidth());
      }
      $(this).css('left', position + 'px');
      position = newPosition;
      controlWidth = $(this).outerWidth();
    }
  });
  $(this.element).hide();
};

proto._postRender = function () {};

module.exports = Control;

},{"./utils":663}],648:[function(require,module,exports){
var Control = require('./control');
function GeolocationControl() {
  var options = {
    name: "geolocation",
    tipLabel: "Geolocation",
    label: "\uE904"
  };
  Control.call(this, options);
}

ol.inherits(GeolocationControl, Control);

var proto = GeolocationControl.prototype;

proto.setMap = function (map) {
  var self = this;
  Control.prototype.setMap.call(this, map);
  // faccio la gestione tutta interna alla rimozione del controllo
  var geolocation = new ol.Geolocation({
    projection: map.getView().getProjection(),
    tracking: true
  });
  //mi metto in ascolto del proprety change in particolare quando viene settato allow o block
  geolocation.once('change:position', function (e) {
    if (this.getPosition()) {
      $(self.element).removeClass('g3w-ol-disabled');
      $(self.element).on('click', function () {
        var map = self.getMap();
        var view = map.getView();
        coordinates = geolocation.getPosition();
        view.setCenter(coordinates);
        self.dispatchEvent({
          type: 'click',
          coordinates: coordinates
        });
      });
    } else {
      self.hideControl();
    }
  });
  geolocation.once('error', function (e) {
    self.hideControl();
    if (e.code != 1) {
      self.dispatchEvent('error');
    }
  });
};

proto.layout = function (map) {
  Control.prototype.layout.call(this, map);
  $(this.element).addClass('g3w-ol-disabled');
};

module.exports = GeolocationControl;

},{"./control":647}],649:[function(require,module,exports){
var Control = require('./control');
var GUI = require('gui/gui');

var InteractionControl = function InteractionControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._visible = options.visible === false ? false : true;
  this._toggled = options.toggled || false;
  this._interactionClass = options.interactionClass || null;
  this._interaction = null;
  this._autountoggle = options.autountoggle || false;
  this._geometryTypes = options.geometryTypes || []; // array of types geometries
  this._onSelectLayer = options.onselectlayer || false;
  this._enabled = options.enabled === false ? false : true;
  this._onhover = options.onhover || false;
  this._help = options.help || null;
  this._helpButton = null;
  this._interactionClassOptions = options.interactionClassOptions || {};
  options.buttonClickHandler = InteractionControl.prototype._handleClick.bind(this);
  Control.call(this, options);
  // create an help message
  this._help && this._createModalHelp();
};

ol.inherits(InteractionControl, Control);

var proto = InteractionControl.prototype;

proto.isVisible = function () {
  return this._visible;
};

proto.setVisible = function (bool) {
  this._visible = bool;
};

//shwo help message
proto._showModalHelp = function () {
  GUI.showUserMessage({
    type: 'info',
    message: this._help,
    position: 'left',
    size: 'small',
    autoclose: true
  });
};

proto._closeModalHelp = function () {
  GUI.closeUserMessage();
};

// create modal help
proto._createModalHelp = function () {
  var _this = this;

  if (this._onhover) {
    this._helpButton = $('<span style="display:none" class="info_mapcontrol_button">i</span>');
    $(this.element).prepend(this._helpButton);
    this._helpButton.on('click', function (event) {
      event.stopPropagation();
      _this._showModalHelp();
    });
    $(this.element).hover(function () {
      _this._helpButton.show();
    });
    $(this.element).mouseleave(function () {
      _this._helpButton.hide();
    });
  }
};

proto.getGeometryTypes = function () {
  return this._geometryTypes;
};

proto.getInteraction = function () {
  return this._interaction;
};

proto.isToggled = function () {
  return this._toggled;
};

// press or not press
proto.toggle = function (toggle) {
  toggle = toggle !== undefined ? toggle : !this._toggled;
  this._toggled = toggle;
  var controlButton = $(this.element).find('button').first();
  if (toggle) {
    //this._help && this._showModalHelp();
    this._interaction && this._interaction.setActive(true);
    controlButton.addClass('g3w-ol-toggled');
  } else {
    this._help && this._helpButton.hide();
    this._interaction && this._interaction.setActive(false);
    controlButton.removeClass('g3w-ol-toggled');
  }
  this.dispatchEvent('toggled', toggle);
};

// funzione che abilita e disabilita il controllo
proto.setEnable = function (bool) {
  var controlButton = $(this.element).find('button').first();
  if (bool) {
    controlButton.removeClass('g3w-ol-disabled');
  } else {
    controlButton.addClass('g3w-ol-disabled');
    controlButton.removeClass('g3w-ol-toggled');
    if (this._interaction) {
      this._interaction.setActive(false);
    }
  }
  this._enabled = bool;
};

proto.getEnable = function () {
  return this._enabled;
};

proto.getGeometryTypes = function () {
  return this._geometryTypes;
};

proto.setGeometryTypes = function (types) {
  this._geometryTypes = types;
};

proto.onSelectLayer = function () {
  return this._onSelectLayer;
};

proto.setMap = function (map) {
  var _this2 = this;

  Control.prototype.setMap.call(this, map);
  if (!this._interaction && this._interactionClass) {
    this._interaction = new this._interactionClass(this._interactionClassOptions);
    map.addInteraction(this._interaction);
    this._interaction.setActive(false);
  }
  this._toggled && setTimeout(function () {
    _this2.toggle(true);
  });
};

proto._handleClick = function (e) {
  if (this._enabled) {
    this.toggle();
    Control.prototype._handleClick.call(this, e);
  }
};

proto.getIteraction = function () {
  return this._interaction;
};

module.exports = InteractionControl;

},{"./control":647,"gui/gui":710}],650:[function(require,module,exports){
var utils = require('../utils');
var LenghtIteraction = require('../interactions/lengthinteraction');
var MeasureControl = require('./measurecontrol');

var LengthControl = function LengthControl(options) {
  var _options = {
    name: "Length",
    label: '\uE908',
    interactionClass: LenghtIteraction
  };

  options = utils.merge(options, _options);
  MeasureControl.call(this, options);
};

ol.inherits(LengthControl, MeasureControl);

module.exports = LengthControl;

},{"../interactions/lengthinteraction":668,"../utils":677,"./measurecontrol":651}],651:[function(require,module,exports){
var InteractionControl = require('./interactioncontrol');

var MeasureControl = function MeasureControl(options) {
  this._map = null;
  InteractionControl.call(this, options);
};

ol.inherits(MeasureControl, InteractionControl);

var proto = MeasureControl.prototype;

proto.setMap = function (map) {
  InteractionControl.prototype.setMap.call(this, map);
};

proto.toggle = function (toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    //clean of the measure control if it was activated
    this.getIteraction().clear();
  }
};

module.exports = MeasureControl;

},{"./interactioncontrol":649}],652:[function(require,module,exports){
var layout = require('./utils').layout;
var changeLayout = require('./utils').changeLayoutBottomControl;
var MousePositionControl = function MousePositionControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.position = options.position || {
    bottom: true,
    right: true
  };
  ol.control.MousePosition.call(this, options);
};

ol.inherits(MousePositionControl, ol.control.MousePosition);

module.exports = MousePositionControl;
var proto = MousePositionControl.prototype;

proto.changelayout = function (map) {
  var position = this.position;
  var element = $(this.element);
  changeLayout({
    map: map,
    position: position,
    element: element
  });
};

proto.layout = function (map) {
  var position = this.position;
  var element = $(this.element);
  layout({
    map: map,
    position: position,
    element: element
  });
  element.addClass('ol-control-br');
};

proto.setMap = function (map) {
  if (map) {
    this.layout(map);
    ol.control.MousePosition.prototype.setMap.call(this, map);
  }
};

},{"./utils":663}],653:[function(require,module,exports){
var _isNan = require('babel-runtime/core-js/number/is-nan');

var _isNan2 = _interopRequireDefault(_isNan);

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _freeze = require('babel-runtime/core-js/object/freeze');

var _freeze2 = _interopRequireDefault(_freeze);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Control = require('./control');

function NominatimControl(options) {
  var self = this;
  this.options = {
    provider: 'osm',
    placeholder: options.placeholder || 'Citt, indirizzo ... ',
    noresults: options.noresults || 'Nessun risultato ',
    notresponseserver: options.notresponseserver || 'Il server non risponde',
    targetType: 'text-input',
    lang: 'it-IT',
    limit: 5,
    keepOpen: true,
    preventDefault: false,
    autoComplete: false,
    autoCompleteMinLength: 4,
    debug: false,
    viewbox: options.bbox,
    bounded: 1,
    classMobile: options.isMobile ? 'nominatim-mobile' : '',
    mapCrs: options.mapCrs,
    fontIcon: options.fontIcon || "fa fa-search fas fa-search"
  };

  var inputQueryId = "gcd-input-query";
  var inputResetId = "gcd-input-reset";
  var cssClasses = {
    "namespace": "ol-geocoder",
    "spin": "gcd-pseudo-rotate",
    "hidden": "gcd-hidden",
    "country": "gcd-country",
    "city": "gcd-city",
    "road": "gcd-road",
    "olControl": "ol-control",
    "glass": {
      "container": "gcd-gl-container",
      "control": "gcd-gl-control",
      "button": "gcd-gl-btn",
      "input": "gcd-gl-input",
      "expanded": "gcd-gl-expanded",
      "reset": "gcd-gl-reset",
      "result": "gcd-gl-result"
    },
    "inputText": {
      "container": "gcd-txt-container",
      "control": "gcd-txt-control",
      "input": "gcd-txt-input",
      "reset": "gcd-txt-reset",
      "icon": "gcd-txt-glass",
      "result": "gcd-txt-result"
    }
  };

  var targetType = {
    GLASS: 'glass-button',
    INPUT: 'text-input'
  };
  var vars = (0, _freeze2.default)({
    inputQueryId: inputQueryId,
    inputResetId: inputResetId,
    cssClasses: cssClasses,
    default: {
      inputQueryId: inputQueryId,
      inputResetId: inputResetId,
      cssClasses: cssClasses
    }
  });

  var utils = {
    toQueryString: function toQueryString(obj) {
      var this$1 = this;
      return (0, _keys2.default)(obj).reduce(function (a, k) {
        a.push((0, _typeof3.default)(obj[k]) === 'object' ? this$1.toQueryString(obj[k]) : encodeURIComponent(k) + '=' + encodeURIComponent(obj[k]));
        return a;
      }, []).join('&');
    },
    encodeUrlXhr: function encodeUrlXhr(url, data) {
      if (data && (typeof data === 'undefined' ? 'undefined' : (0, _typeof3.default)(data)) === 'object') {
        var str_data = this.toQueryString(data);
        url += (/\?/.test(url) ? '&' : '?') + str_data;
      }
      return url;
    },
    json: function json(url, data) {
      return $.get(url, data);
    },
    jsonp: function jsonp(url, key, callback) {
      // https://github.com/Fresheyeball/micro-jsonp/blob/master/src/jsonp.js
      var head = document.head,
          script = document.createElement('script'),

      // generate minimally unique name for callback function
      callbackName = 'f' + Math.round(Math.random() * Date.now());

      // set request url
      script.setAttribute('src',
      /*  add callback parameter to the url
       where key is the parameter key supplied
       and callbackName is the parameter value */
      url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + callbackName);

      /*  place jsonp callback on window,
       the script sent by the server should call this
       function as it was passed as a url parameter */
      window[callbackName] = function (json) {
        window[callbackName] = undefined;

        // clean up script tag created for request
        setTimeout(function () {
          head.removeChild(script);
        }, 0);

        // hand data back to the user
        callback(json);
      };

      // actually make the request
      head.appendChild(script);
    },
    now: function now() {
      // Polyfill for window.performance.now()
      // @license http://opensource.org/licenses/MIT
      // copyright Paul Irish 2015
      // https://gist.github.com/paulirish/5438650
      if ('performance' in window === false) {
        window.performance = {};
      }

      Date.now = Date.now || function () {
        // thanks IE8
        return new Date().getTime();
      };

      if ('now' in window.performance === false) {

        var nowOffset = Date.now();

        if (performance.timing && performance.timing.navigationStart) {
          nowOffset = performance.timing.navigationStart;
        }

        window.performance.now = function now() {
          return Date.now() - nowOffset;
        };
      }
      return window.performance.now();
    },

    flyTo: function flyTo(map, coord, duration, resolution) {
      resolution = resolution || 2.388657133911758;
      duration = duration || 500;
      var view = map.getView();
      view.animate({ duration: duration, resolution: resolution }, { duration: duration, center: coord });
    },
    randomId: function randomId(prefix) {
      var id = this.now().toString(36);
      return prefix ? prefix + id : id;
    },
    isNumeric: function isNumeric(str) {
      return (/^\d+$/.test(str)
      );
    },
    classRegex: function classRegex(classname) {
      return new RegExp("(^|\\s+) " + classname + " (\\s+|$)");
    },
    /**
     * @param {Element|Array<Element>} element DOM node or array of nodes.
     * @param {String|Array<String>} classname Class or array of classes.
     * For example: 'class1 class2' or ['class1', 'class2']
     * @param {Number|undefined} timeout Timeout to remove a class.
     */
    addClass: function addClass(element, classname, timeout) {
      var this$1 = this;

      if (Array.isArray(element)) {
        element.forEach(function (each) {
          this$1.addClass(each, classname);
        });
        return;
      }

      var array = Array.isArray(classname) ? classname : classname.split(/\s+/);
      var i = array.length;

      while (i--) {
        if (!this$1.hasClass(element, array[i])) {
          this$1._addClass(element, array[i], timeout);
        }
      }
    },
    _addClass: function _addClass(el, klass, timeout) {
      var this$1 = this;

      // use native if available
      if (el.classList) {
        el.classList.add(klass);
      } else {
        el.className = (el.className + ' ' + klass).trim();
      }

      if (timeout && this.isNumeric(timeout)) {
        window.setTimeout(function () {
          this$1._removeClass(el, klass);
        }, timeout);
      }
    },
    /**
     * @param {Element|Array<Element>} element DOM node or array of nodes.
     * @param {String|Array<String>} classname Class or array of classes.
     * For example: 'class1 class2' or ['class1', 'class2']
     * @param {Number|undefined} timeout Timeout to add a class.
     */
    removeClass: function removeClass(element, classname, timeout) {
      var this$1 = this;

      if (Array.isArray(element)) {
        element.forEach(function (each) {
          this$1.removeClass(each, classname, timeout);
        });
        return;
      }

      var array = Array.isArray(classname) ? classname : classname.split(/\s+/);
      var i = array.length;

      while (i--) {
        if (this$1.hasClass(element, array[i])) {
          this$1._removeClass(element, array[i], timeout);
        }
      }
    },
    _removeClass: function _removeClass(el, klass, timeout) {
      var this$1 = this;

      if (el.classList) {
        el.classList.remove(klass);
      } else {
        el.className = el.className.replace(this.classRegex(klass), ' ').trim();
      }
      if (timeout && this.isNumeric(timeout)) {
        window.setTimeout(function () {
          this$1._addClass(el, klass);
        }, timeout);
      }
    },
    /**
     * @param {Element} element DOM node.
     * @param {String} classname Classname.
     * @return {Boolean}
     */
    hasClass: function hasClass(element, c) {
      // use native if available
      return element.classList ? element.classList.contains(c) : this.classRegex(c).test(element.className);
    },
    /**
     * @param {Element|Array<Element>} element DOM node or array of nodes.
     * @param {String} classname Classe.
     */
    toggleClass: function toggleClass(element, classname) {
      var this$1 = this;

      if (Array.isArray(element)) {
        element.forEach(function (each) {
          this$1.toggleClass(each, classname);
        });
        return;
      }

      // use native if available
      if (element.classList) {
        element.classList.toggle(classname);
      } else {
        if (this.hasClass(element, classname)) {
          this._removeClass(element, classname);
        } else {
          this._addClass(element, classname);
        }
      }
    },
    /**
     * Abstraction to querySelectorAll for increased
     * performance and greater usability
     * @param {String} selector
     * @param {Element} context (optional)
     * @param {Boolean} find_all (optional)
     * @return (find_all) {Element} : {Array}
     */
    find: function find(selector, context, find_all) {
      if (context === void 0) context = window.document;
      var simpleRe = /^(#?[\w-]+|\.[\w-.]+)$/,
          periodRe = /\./g,
          slice = Array.prototype.slice,
          matches = [];

      // Redirect call to the more performant function
      // if it's a simple selector and return an array
      // for easier usage
      if (simpleRe.test(selector)) {
        switch (selector[0]) {
          case '#':
            matches = [this.$(selector.substr(1))];
            break;
          case '.':
            matches = slice.call(context.getElementsByClassName(selector.substr(1).replace(periodRe, ' ')));
            break;
          default:
            matches = slice.call(context.getElementsByTagName(selector));
        }
      } else {
        // If not a simple selector, query the DOM as usual
        // and return an array for easier usage
        matches = slice.call(context.querySelectorAll(selector));
      }
      return find_all ? matches : matches[0];
    },
    $: function $(id) {
      id = id[0] === '#' ? id.substr(1, id.length) : id;
      return document.getElementById(id);
    },
    isElement: function isElement(obj) {
      // DOM, Level2
      if ('HTMLElement' in window) {
        return !!obj && obj instanceof HTMLElement;
      }
      // Older browsers
      return !!obj && (typeof obj === 'undefined' ? 'undefined' : (0, _typeof3.default)(obj)) === 'object' && obj.nodeType === 1 && !!obj.nodeName;
    },
    getAllChildren: function getAllChildren(node, tag) {
      return [].slice.call(node.getElementsByTagName(tag));
    },
    isEmpty: function isEmpty(str) {
      return !str || 0 === str.length;
    },
    emptyArray: function emptyArray(array) {
      while (array.length) {
        array.pop();
      }
    },
    anyMatchInArray: function anyMatchInArray(source, target) {
      return source.some(function (each) {
        return target.indexOf(each) >= 0;
      });
    },
    everyMatchInArray: function everyMatchInArray(arr1, arr2) {
      return arr2.every(function (each) {
        return arr1.indexOf(each) >= 0;
      });
    },
    anyItemHasValue: function anyItemHasValue(obj, has) {
      var this$1 = this;
      if (has === void 0) has = false;

      var keys = (0, _keys2.default)(obj);
      keys.forEach(function (key) {
        if (!this$1.isEmpty(obj[key])) {
          has = true;
        }
      });
      return has;
    },
    removeAllChildren: function removeAllChildren(node) {
      while (node.firstChild) {
        node.removeChild(node.firstChild);
      }
    },
    removeAll: function removeAll(collection) {
      var node = void 0;
      while (node = collection[0]) {
        node.parentNode.removeChild(node);
      }
    },
    getChildren: function getChildren(node, tag) {
      return [].filter.call(node.childNodes, function (el) {
        return tag ? el.nodeType === 1 && el.tagName.toLowerCase() === tag : el.nodeType === 1;
      });
    },
    template: function template(html, row) {
      var this$1 = this;

      return html.replace(/\{ *([\w_-]+) *\}/g, function (htm, key) {
        var value = row[key] === undefined ? '' : row[key];
        return this$1.htmlEscape(value);
      });
    },
    htmlEscape: function htmlEscape(str) {
      return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    },
    /**
     * Overwrites obj1's values with obj2's and adds
     * obj2's if non existent in obj1
     * @returns obj3 a new object based on obj1 and obj2
     */
    mergeOptions: function mergeOptions(obj1, obj2) {
      var obj3 = {};
      for (var attr1 in obj1) {
        obj3[attr1] = obj1[attr1];
      }
      for (var attr2 in obj2) {
        obj3[attr2] = obj2[attr2];
      }
      return obj3;
    },
    createElement: function createElement(node, html) {
      var elem = void 0;
      if (Array.isArray(node)) {
        elem = document.createElement(node[0]);

        if (node[1].id) {
          elem.id = node[1].id;
        }
        if (node[1].classname) {
          elem.className = node[1].classname;
        }

        if (node[1].attr) {
          var attr = node[1].attr;
          if (Array.isArray(attr)) {
            var i = -1;
            while (++i < attr.length) {
              elem.setAttribute(attr[i].name, attr[i].value);
            }
          } else {
            elem.setAttribute(attr.name, attr.value);
          }
        }
      } else {
        elem = document.createElement(node);
      }
      elem.innerHTML = html;
      var frag = document.createDocumentFragment();

      while (elem.childNodes[0]) {
        frag.appendChild(elem.childNodes[0]);
      }
      elem.appendChild(frag);
      return elem;
    },
    assert: function assert(condition, message) {
      if (message === void 0) message = 'Assertion failed';

      if (!condition) {
        if (typeof Error !== 'undefined') {
          throw new Error(message);
        }
        throw message; // Fallback
      }
    }
  };

  var klasses = vars.cssClasses;
  var klasses$1 = vars.cssClasses;

  // classe Html //
  var Html = function Html(base) {
    this.options = base.options;
    this.els = this.createControl();
  };

  Html.prototype.createControl = function createControl() {
    var container = void 0,
        containerClass = void 0,
        elements = void 0;

    if (this.options.targetType === targetType.INPUT) {
      containerClass = klasses.namespace + ' ' + klasses.inputText.container + ' ' + this.options.classMobile;
      container = utils.createElement(['div', { classname: containerClass }], Html.input);
      elements = {
        container: container,
        control: utils.find('.' + klasses.inputText.control, container),
        input: utils.find('.' + klasses.inputText.input, container),
        reset: utils.find('.' + klasses.inputText.reset, container),
        result: utils.find('.' + klasses.inputText.result, container)
      };
    } else {
      containerClass = klasses.namespace + ' ' + klasses.glass.container;
      container = utils.createElement(['div', { classname: containerClass }], Html.glass);
      elements = {
        container: container,
        control: utils.find('.' + klasses.glass.control, container),
        button: utils.find('.' + klasses.glass.button, container),
        input: utils.find('.' + klasses.glass.input, container),
        reset: utils.find('.' + klasses.glass.reset, container),
        result: utils.find('.' + klasses.glass.result, container)
      };
    }
    //set placeholder from options
    elements.input.placeholder = this.options.placeholder;
    return elements;
  };

  /* eslint-disable indent */
  Html.glass = ['<div class="', klasses.glass.control, ' ', klasses.olControl, '">', '<button type="button" class="', klasses.glass.button, '"></button>', '<input type="text"', ' id="', vars.inputQueryId, '"', ' class="', klasses.glass.input, '"', ' autocomplete="off" placeholder="Search ...">', '<a', ' id="', vars.inputResetId, '"', ' class="', klasses.glass.reset, ' ', klasses.hidden, '"', '></a>', '</div>', '<ul class="', klasses.glass.result, '"></ul>'].join('');

  Html.input = ['<div class="', klasses.inputText.control, '">', '<input type="text"', ' id="', vars.inputQueryId, '"', ' class="', klasses.inputText.input, '"', ' autocomplete="off" placeholder="Search ...">', '<button type="button" class="btn" id="search_nominatim"><i style="color:#ffffff" class="' + this.options.fontIcon + '" aria-hidden="true"></i></button>', '<button type="button"', ' id="', vars.inputResetId, '"', ' class="', klasses.inputText.reset, ' ', klasses.hidden, '"', '></button>', '</div>', '<ul class="', klasses.inputText.result, '"></ul>'].join('');

  // classe Html fine //

  // classe OpenStreet //

  var OpenStreet = function OpenStreet() {
    this.settings = {
      url: 'https://nominatim.openstreetmap.org/search/',
      params: {
        q: '',
        format: 'json',
        addressdetails: 1,
        limit: 10
        //countrycodes: 'IT',
        //'accept-language': 'it-IT',
      }
    };
  };

  OpenStreet.prototype.getParameters = function getParameters(options) {
    var viewbox = ol.proj.transformExtent(self.options.viewbox, self.options.mapCrs, 'EPSG:4326').join(',');
    return {
      url: this.settings.url,
      params: {
        q: options.query,
        format: 'json',
        addressdetails: 1,
        limit: options.limit || this.settings.params.limit,
        //countrycodes: options.countrycodes || this.settings.params.countrycodes,
        //'accept-language': options.lang || this.settings.params['accept-language'],
        viewbox: viewbox,
        bounded: 1
      }
    };
  };

  OpenStreet.prototype.handleResponse = function handleResponse(results) {
    return results.map(function (result) {
      return {
        lon: result.lon,
        lat: result.lat,
        address: {
          name: result.address.neighbourhood || '',
          road: result.address.road || '',
          postcode: result.address.postcode,
          city: result.address.city || result.address.town,
          state: result.address.state,
          country: result.address.country
        },
        original: {
          formatted: result.display_name,
          details: result.address
        }
      };
    });
  };

  // classe OpenStreet fine //

  // classe Nomitatim //

  var Nominatim = function Nominatim(base, els) {
    this.Base = base;
    this.options = base.options;
    this.options.provider = this.options.provider.toLowerCase();
    this.els = els;
    this.lastQuery = '';
    this.container = this.els.container;
    this.registeredListeners = { mapClick: false };
    this.setListeners();
    this.OpenStreet = new OpenStreet();
  };

  Nominatim.prototype.setListeners = function setListeners() {
    var this$1 = this;
    var timeout = void 0,
        lastQuery = void 0;
    var openSearch = function openSearch() {
      utils.hasClass(this$1.els.control, klasses$1.glass.expanded) ? this$1.collapse() : this$1.expand();
    };
    var query = function query(evt) {
      var value = evt.target.value.trim();
      var hit = evt.key ? evt.key === 'Enter' : evt.which ? evt.which === 13 : evt.keyCode ? evt.keyCode === 13 : false;

      if (hit) {
        evt.preventDefault();
        this$1.query(value);
      }
    };
    var reset = function reset(evt) {
      this$1.els.input.focus();
      this$1.els.input.value = '';
      this$1.lastQuery = '';
      utils.addClass(this$1.els.reset, klasses$1.hidden);
      this$1.clearResults();
    };
    var handleValue = function handleValue(evt) {
      var value = evt.target.value.trim();

      value.length ? utils.removeClass(this$1.els.reset, klasses$1.hidden) : utils.addClass(this$1.els.reset, klasses$1.hidden);

      if (this$1.options.autoComplete && value !== lastQuery) {
        lastQuery = value;
        timeout && clearTimeout(timeout);
        timeout = setTimeout(function () {
          if (value.length >= this$1.options.autoCompleteMinLength) {
            this$1.query(value);
          }
        }, 200);
      }
    };
    this.els.input.addEventListener('keyup', query, false);
    this.els.input.addEventListener('input', handleValue, false);
    this.els.reset.addEventListener('click', reset, false);
    if (this.options.targetType === targetType.GLASS) {
      this.els.button.addEventListener('click', openSearch, false);
    }
  };

  Nominatim.prototype.query = function query(q) {
    var isNumber = function isNumber(value) {
      return typeof value === 'number' && !(0, _isNan2.default)(value);
    };
    var latlon = null;
    if (q && q.split(',').length === 2) {
      latlon = q.split(',');
      latlon = isNumber(latlon[0]) && isNumber(latlon[1]) ? latlon : null;
    }
    var this$1 = this;
    var ajax = {},
        options = this.options;
    var provider = this.getProvider({
      query: q,
      provider: options.provider,
      key: options.key,
      lang: options.lang,
      countrycodes: options.countrycodes,
      limit: options.limit,
      lat: latlon ? latlon[0] : null,
      lon: latlon ? latlon[1] : null
    });
    if (this.lastQuery === q && this.els.result.firstChild) {
      return;
    }
    this.lastQuery = q;
    this.clearResults();
    utils.addClass(this.els.reset, klasses$1.spin);
    ajax.url = provider.url;
    ajax.data = provider.params;
    utils.json(ajax).done(function (res) {
      utils.removeClass(this$1.els.reset, klasses$1.spin);
      //will be fullfiled according to provider
      var res_ = res.length ? this$1.OpenStreet.handleResponse(res) : undefined;
      this$1.createList(res_);
      if (res_) {
        this$1.listenMapClick();
      }
    }).fail(function (error) {
      utils.removeClass(this$1.els.reset, klasses$1.spin);
      var li = utils.createElement('li', '<h5>  ' + this$1.options.notresponseserver + '</h5>');
      this$1.els.result.appendChild(li);
    });
  };

  Nominatim.prototype.createList = function createList(response) {
    var this$1 = this;
    var ul = this.els.result;
    if (response) {
      response.forEach(function (row) {
        var addressHtml = this$1.addressTemplate(row.address),
            html = ['<a href="#">', addressHtml, '</a>'].join(''),
            li = utils.createElement('li', html);
        li.addEventListener('click', function (evt) {
          evt.preventDefault();
          this$1.chosen(row, addressHtml, row.address, row.original);
        }, false);
        ul.appendChild(li);
      });
    } else {
      var li = utils.createElement('li', this.options.noresults);
      li.className = 'nominatim-noresults';
      ul.appendChild(li);
    }
  };

  Nominatim.prototype.chosen = function chosen(place, addressHtml, addressObj, addressOriginal) {
    var map = this.Base.getMap();
    var coord_ = [parseFloat(place.lon), parseFloat(place.lat)];
    var projection = map.getView().getProjection();
    var coord = ol.proj.transform(coord_, 'EPSG:4326', projection);
    var address = {
      formatted: addressHtml,
      details: addressObj,
      original: addressOriginal
    };
    this.options.keepOpen === false && this.clearResults(true);
    this.Base.dispatchEvent({
      type: 'addresschosen',
      address: address,
      coordinate: coord
    });
  };

  Nominatim.prototype.addressTemplate = function addressTemplate(address) {
    var html = [];
    if (address.name) {
      html.push(['<div class="', klasses$1.road, '">{name}</div>'].join(''));
    }
    if (address.road || address.building || address.house_number) {
      html.push(['<div class="', klasses$1.road, '">{building} {road} {house_number}</div>'].join(''));
    }
    if (address.city || address.town || address.village) {
      html.push(['<div class="', klasses$1.city, '">{postcode} {city} {town} {village}</div>'].join(''));
    }
    if (address.state || address.country) {
      html.push(['<div class="', klasses$1.country, '">{state} {country}</div>'].join(''));
    }
    return utils.template(html.join('<br>'), address);
  };

  Nominatim.prototype.getProvider = function getProvider(options) {
    return this.OpenStreet.getParameters(options);
  };

  Nominatim.prototype.expand = function expand() {
    var this$1 = this;

    utils.removeClass(this.els.input, klasses$1.spin);
    utils.addClass(this.els.control, klasses$1.glass.expanded);
    window.setTimeout(function () {
      return this$1.els.input.focus();
    }, 100);
    this.listenMapClick();
  };

  Nominatim.prototype.collapse = function collapse() {
    this.els.input.value = '';
    this.els.input.blur();
    utils.addClass(this.els.reset, klasses$1.hidden);
    utils.removeClass(this.els.control, klasses$1.glass.expanded);
    this.clearResults();
  };

  Nominatim.prototype.listenMapClick = function listenMapClick() {
    // already registered
    if (this.registeredListeners.mapClick) {
      return;
    }

    var this_ = this;
    var mapElement = this.Base.getMap().getTargetElement();
    this.registeredListeners.mapClick = true;

    //one-time fire click
    mapElement.addEventListener('click', {
      handleEvent: function handleEvent(evt) {
        this_.clearResults(true);
        mapElement.removeEventListener(evt.type, this, false);
        this_.registeredListeners.mapClick = false;
      }
    }, false);
  };

  Nominatim.prototype.clearResults = function clearResults(collapse) {
    collapse && this.options.targetType === targetType.GLASS ? this.collapse() : utils.removeAllChildren(this.els.result);
  };

  Nominatim.prototype.getSource = function getSource() {
    return this.layer.getSource();
  };

  Nominatim.prototype.addLayer = function addLayer() {
    var this$1 = this;

    var found = false;
    var map = this.Base.getMap();

    map.getLayers().forEach(function (layer) {
      if (layer === this$1.layer) {
        found = true;
      }
    });
    if (!found) {
      map.addLayer(this.layer);
    }
  };

  // classe Nomitatim fine //

  var $html = new Html(this);
  this.container = $html.els.container;
  this.nominatim = new Nominatim(this, $html.els);
  this.layer = this.nominatim.layer;
  Control.call(this, {
    element: this.container,
    name: "nominatim"
  });
}

ol.inherits(NominatimControl, Control);

proto = NominatimControl.prototype;

module.exports = NominatimControl;

},{"./control":647,"babel-runtime/core-js/number/is-nan":8,"babel-runtime/core-js/object/freeze":13,"babel-runtime/core-js/object/keys":14,"babel-runtime/helpers/typeof":25}],654:[function(require,module,exports){
var OLControl = function OLControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._control = null;
  this.positionCode = options.position || 'tl';
  switch (options.type) {
    case 'zoom':
      this._control = new ol.control.Zoom(options);
      break;
    case 'zoomtoextent':
      this._control = new ol.control.ZoomToExtent(options);
      break;
    case 'scaleline':
      this._control = new ol.control.ScaleLine(options);
      break;
    case 'overview':
      this._control = new ol.control.OverviewMap(options);
      break;
  }

  $(this._control.element).addClass("ol-control-" + this.positionCode);

  ol.control.Control.call(this, {
    element: this._control.element
  });
};

// sotto classe della classe control di OL3
ol.inherits(OLControl, ol.control.Control);
module.exports = OLControl;

var proto = OLControl.prototype;

proto.getPosition = function (positionCode) {
  positionCode = positionCode || this.positionCode;
  var position = {};
  position['top'] = positionCode.indexOf('t') > -1 ? true : false;
  position['left'] = positionCode.indexOf('l') > -1 ? true : false;
  return position;
};

proto.layout = function (map) {
  if (map) {
    var position = this.getPosition();
    var viewPort = map.getViewport();
    var previusControls = $(viewPort).find('.ol-control-' + this.positionCode);
    if (previusControls.length) {
      previusControl = previusControls.last();
      var previousOffset = position.left ? previusControl.position().left : previusControl.position().right;
      var hWhere = position.left ? 'left' : 'right';
      var previousWidth = previusControl[0].offsetWidth;
      var hOffset = $(this.element).position()[hWhere] + previousOffset + previousWidth + 2;
      $(this.element).css(hWhere, hOffset + 'px');
    }
  }
};

proto.changelayout = function () {};

proto.showHide = function () {
  $(this.element).toggle();
};

proto.setMap = function (map) {
  this.layout(map);
  this._control.setMap(map);
};

},{}],655:[function(require,module,exports){
var Control = require('./control');
function OnClickControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._onclick = options.onclick;
  Control.call(this, options);
}

ol.inherits(OnClickControl, Control);

var proto = OnClickControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  Control.prototype.setMap.call(this, map);
  var controlElement = $(this.element);
  var buttonControl = controlElement.children('button');
  var cliccked = false;
  controlElement.on('click', function () {
    if (!cliccked) {
      cliccked = true;
      buttonControl.addClass('g3w-ol-disabled');
      _this._onclick && _this._onclick().then(function () {}).then(function () {
        buttonControl.removeClass('g3w-ol-disabled');
        cliccked = false;
      });
    }
  });
};

module.exports = OnClickControl;

},{"./control":647}],656:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var QueryBBoxControl = function QueryBBoxControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._startCoordinate = null;
  var _options = {
    name: "querybbox",
    tipLabel: "Query BBox layer",
    label: options.label || '\uE902',
    interactionClass: ol.interaction.DragBox,
    onhover: true
  };
  options = utils.merge(options, _options);
  var layers = options.layers || [];
  options.visible = !!layers.length;
  InteractionControl.call(this, options);
};

ol.inherits(QueryBBoxControl, InteractionControl);

var proto = QueryBBoxControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  InteractionControl.prototype.setMap.call(this, map);
  this._interaction.on('boxstart', function (e) {
    _this._startCoordinate = e.coordinate;
  });
  this._interaction.on('boxend', function (e) {
    var start_coordinate = _this._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate, end_coordinate]);
    _this.dispatchEvent({
      type: 'bboxend',
      extent: extent
    });
    _this._startCoordinate = null;
    if (_this._autountoggle) {
      _this.toggle();
    }
  });
};

module.exports = QueryBBoxControl;

},{"../utils":677,"./interactioncontrol":649}],657:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');
var VALIDGEOMETRIES = ['Polygon', 'MultiPolygon'];

var QueryByPolygonControl = function QueryByPolygonControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _options = {
    name: "querybypolygon",
    tipLabel: "Query By Polygon",
    label: options.label || '\uE903',
    onselectlayer: true,
    interactionClass: PickCoordinatesInteraction,
    onhover: true
  };
  options = utils.merge(options, _options);
  var layers = options.layers || [];
  var visible = false;
  // if no layer or just one
  if (!layers.length || layers.length === 1) {
    options.visible = visible;
  } else {
    // geometryes to check
    var geometryTypes = options.geometryTypes = VALIDGEOMETRIES;
    // get all layers that haven't the geometries above filterable
    var filterableLayers = layers.filter(function (layer) {
      return layer.isFilterable();
    });
    // gell all layer that have the valid geometries
    var querableLayers = layers.filter(function (layer) {
      return geometryTypes.indexOf(layer.getGeometryType()) !== -1;
    });
    var filterableLength = filterableLayers.length;
    var querableLength = querableLayers.length;
    if (querableLength && filterableLength) {
      visible = true;
    }
    options.visible = visible;
  }
  InteractionControl.call(this, options);
};

ol.inherits(QueryByPolygonControl, InteractionControl);

var proto = QueryByPolygonControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  InteractionControl.prototype.setMap.call(this, map);
  this._interaction.on('picked', function (e) {
    _this.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (_this._autountoggle) {
      _this.toggle();
    }
  });
  this.setEnable(false);
};

module.exports = QueryByPolygonControl;

},{"../interactions/pickcoordinatesinteraction":670,"../utils":677,"./interactioncontrol":649}],658:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var QueryControl = function QueryControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var _options = {
    name: "querylayer",
    tipLabel: "Query layer",
    label: options.label || '\uEA0F',
    interactionClass: PickCoordinatesInteraction
  };
  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(QueryControl, InteractionControl);

var proto = QueryControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  var eventToggledKey = void 0;
  var querySingleClickFnc = function querySingleClickFnc(event) {
    _this.dispatchEvent({
      type: 'picked',
      coordinates: event.coordinate
    });
    _this._autountoggle && _this.toggle(true);
  };
  if (map) {
    eventToggledKey = this.on('toggled', function (event) {
      var toggled = event.target.isToggled();
      toggled && map.on('singleclick', querySingleClickFnc) || map.un('singleclick', querySingleClickFnc);
    });
  } else ol.Observable.unByKey(eventToggledKey);
  InteractionControl.prototype.setMap.call(this, map);
};

module.exports = QueryControl;

},{"../interactions/pickcoordinatesinteraction":670,"../utils":677,"./interactioncontrol":649}],659:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');

var ResetControl = function ResetControl(options) {
  this._toggled = true;
  this._startCoordinate = null;
  var _options = {
    name: "reset",
    tipLabel: "Pan",
    label: '\uE901'
  };

  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(ResetControl, InteractionControl);

module.exports = ResetControl;

var proto = ResetControl.prototype;

proto._postRender = function () {
  this.toggle(true);
};

},{"../utils":677,"./interactioncontrol":649}],660:[function(require,module,exports){
var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var layout = require('./utils').layout;
var changeLayout = require('./utils').changeLayoutBottomControl;
var getResolutionFromScale = require('../utils/utils').getResolutionFromScale;
var getScaleFromResolution = require('../utils/utils').getScaleFromResolution;
var SCALES = [1000000, 5000000, 250000, 100000, 50000, 25000, 10000, 5000, 2500, 2000, 1000];

var ScaleControl = function ScaleControl() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.isMobile = options.isMobile || false;
  this.position = options.position || {
    bottom: true,
    right: true
  };
  ol.control.Control.call(this, options);
};

ol.inherits(ScaleControl, ol.control.Control);

module.exports = ScaleControl;
var proto = ScaleControl.prototype;

// called from map when layout change
proto.changelayout = function (map) {
  var position = this.position;
  var element = $(this.element);
  changeLayout({
    map: map,
    position: position,
    element: element
    //isMobile: this.isMobile
  });
};

proto.layout = function (map) {
  var self = this;
  var isMapResolutionChanged = false;
  var selectedOnClick = false;
  var position = this.position;
  var element = $(this.element);
  layout({
    map: map,
    position: position,
    element: element
  });
  var select2 = element.children('select').select2({
    tags: true,
    width: '120px',
    height: '20px',
    language: {
      noResults: function noResults(params) {
        return "Scala non valida";
      }
    },
    minimumResultsForSearch: this.isMobile ? -1 : 0,
    createTag: function createTag(params) {
      var newTag = null;
      var scale = void 0;
      // Don't offset to create a tag if there is no @ symbol
      if (params.term.indexOf('1:') !== -1) {
        // Return null to disable tag creation
        scale = params.term.split('1:')[1];
      } else if ((0, _isInteger2.default)(Number(params.term))) scale = Number(params.term);
      if (1 * scale <= self.scales[0]) {
        newTag = {
          id: scale,
          text: '1:' + params.term,
          new: true
        };
        deleteLastCustomScale();
      }
      return newTag;
    }
  });

  function deleteLastCustomScale() {
    select2.find('option').each(function (index, option) {
      if (self.scales.indexOf(1 * option.value) === -1) {
        $(option).remove();
      }
    });
  }

  function addCustomTag(data) {
    if (select2.find("option[value='" + data.id + "']").length) {
      select2.val(data.id).trigger('change');
    } else {
      deleteLastCustomScale();
      var newOption = new Option(data.text, data.id, true, true);
      select2.append(newOption).trigger('change');
    }
  }

  map.on('moveend', function () {
    if (isMapResolutionChanged) {
      var view = this.getView();
      var resolution = view.getResolution();
      var mapUnits = view.getProjection().getUnits();
      var scale = parseInt(getScaleFromResolution(resolution, mapUnits));
      var data = {
        id: scale,
        text: '1:' + scale,
        new: true
      };
      addCustomTag(data);
      isMapResolutionChanged = false;
    } else {
      selectedOnClick = false;
    }
  });
  var setChangeResolutionHandler = function setChangeResolutionHandler() {
    map.getView().on('change:resolution', function () {
      isMapResolutionChanged = !selectedOnClick;
    });
  };
  setChangeResolutionHandler();

  map.on('change:view', function () {
    setChangeResolutionHandler();
  });

  select2.on('select2:select', function (e) {
    selectedOnClick = true;
    var data = e.params.data;
    if (data.new) {
      deleteLastCustomScale();
      addCustomTag(data);
    }
    var mapUnits = map.getView().getProjection().getUnits();
    var scale = 1 * data.id;
    var resolution = getResolutionFromScale(scale, mapUnits);
    map.getView().setResolution(resolution);
  });
};

proto._setScales = function (map) {
  var mapUnits = map.getView().getProjection().getUnits();
  var currentResolution = map.getView().getResolution();
  var currentScale = parseInt(getScaleFromResolution(currentResolution, mapUnits));
  this.scales = SCALES.filter(function (scale) {
    return scale < currentScale;
  });
  this.scales.unshift(currentScale);
  this._createControl();
};

proto._createControl = function () {
  var controlDomElement = document.createElement('div');
  var select = document.createElement('select');
  var optgroup = document.createElement('optgroup');
  optgroup.label = '';
  this.scales.forEach(function (scale, index) {
    var option = document.createElement('option');
    option.value = scale;
    option.text = '1:' + scale;
    option.selected = index === 0 ? true : false;
    optgroup.appendChild(option);
  });
  select.appendChild(optgroup);
  if (!this.isMobile) {
    var optgroup_custom = document.createElement('optgroup');
    optgroup_custom.label = 'Custom';
    select.appendChild(optgroup_custom);
  }
  controlDomElement.appendChild(select);
  // set element of control (it is necessary to visualize it)
  this.element = controlDomElement;
  $(this.element).addClass('ol-control ol-control-br ol-scale-control');
  $(this.element).css('height', '20px');
};

proto.setMap = function (map) {
  if (map) {
    this._setScales(map);
    this.layout(map);
    ol.control.Control.prototype.setMap.call(this, map);
  }
};

},{"../utils/utils":678,"./utils":663,"babel-runtime/core-js/number/is-integer":7}],661:[function(require,module,exports){
var OnClickControl = require('./onclickcontrol');
function Screenshotcontrol() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.name = "maptoimage";
  options.tipLabel = "Screenshot";
  options.label = "\uE90F";
  OnClickControl.call(this, options);
}

ol.inherits(Screenshotcontrol, OnClickControl);

module.exports = Screenshotcontrol;

},{"./onclickcontrol":655}],662:[function(require,module,exports){
var utils = require('../utils');
var InteractionControl = require('./interactioncontrol');
var PickCoordinatesInteraction = require('../interactions/pickcoordinatesinteraction');

var StreetViewControl = function StreetViewControl(options) {
  var _options = {
    name: "streetview",
    tipLabel: "StreetView",
    label: '\uE905',
    interactionClass: PickCoordinatesInteraction
  };
  this._sv = null;
  this._panorama = null;
  this._map = null;
  this._projection = null;
  this._lastposition = null;
  this._streetViewFeature = new ol.Feature();
  var streetVectorSource = new ol.source.Vector({
    features: []
  });
  this._layer = new ol.layer.Vector({
    source: streetVectorSource,
    style: function style(feature) {
      var coordinates = feature.getGeometry().getCoordinates();
      this._lastposition = this._lastposition ? this._lastposition : coordinates;
      var dx = coordinates[0] - this._lastposition[0];
      var dy = coordinates[1] - this._lastposition[1];
      var rotation = -Math.atan2(dy, dx);
      var styles = [new ol.style.Style({
        text: new ol.style.Text({
          text: '\uE905',
          font: 'bold 15px icomoon',
          fill: new ol.style.Fill({
            color: '#ffffff'
          })
        })
      }), new ol.style.Style({
        image: new ol.style.Icon({
          src: '/static/client/images/streetviewarrow.png',
          rotation: rotation
        })
      })];
      this._lastposition = coordinates;
      return styles;
    }
  });
  options = utils.merge(options, _options);
  InteractionControl.call(this, options);
};

ol.inherits(StreetViewControl, InteractionControl);

var proto = StreetViewControl.prototype;

proto.getLayer = function () {
  return this._layer;
};

proto.setProjection = function (projection) {
  this._projection = projection;
};

proto.setPosition = function (position) {
  var self = this;
  var lnglat = void 0;
  var pixel = void 0;
  if (!this._sv) {
    this._sv = new google.maps.StreetViewService();
  }
  this._sv.getPanorama({ location: position }, function (data) {
    self._panorama = new google.maps.StreetViewPanorama(document.getElementById('streetview'));
    self._panorama.addListener('position_changed', function () {
      if (self.isToggled()) {
        lnglat = ol.proj.transform([this.getPosition().lng(), this.getPosition().lat()], 'EPSG:4326', self._projection.getCode());
        self._layer.getSource().getFeatures()[0].setGeometry(new ol.geom.Point(lnglat));
        pixel = self._map.getPixelFromCoordinate(lnglat);
        if (pixel[0] + 15 > self._map.getSize()[0] || pixel[1] + 15 > self._map.getSize()[1] || pixel[0] < 15 || pixel[1] < 15) {
          self._map.getView().setCenter(lnglat);
        }
      }
    });
    if (data && data.location) {
      self._panorama.setPov({
        pitch: 0,
        heading: 0
      });
      self._panorama.setPosition(data.location.latLng);
    }
  });
};

proto.setMap = function (map) {
  var _this = this;

  this._map = map;
  InteractionControl.prototype.setMap.call(this, map);
  this._interaction.on('picked', function (e) {
    _this.dispatchEvent({
      type: 'picked',
      coordinates: e.coordinate
    });
    if (_this._autountoggle) {
      _this.toggle();
    }
  });
};

proto.clearMarker = function () {
  this._streetViewFeature.setGeometry(null);
};

proto.clear = function () {
  this._layer.getSource().clear();
  this._streetViewFeature.setGeometry(null);
  this.clearMarker();
  this._panorama = null;
  this.dispatchEvent('disabled');
};

proto.toggle = function (toggle) {
  InteractionControl.prototype.toggle.call(this, toggle);
  if (!this.isToggled()) {
    this.clear();
  } else {
    this._layer.getSource().addFeatures([this._streetViewFeature]);
  }
};

module.exports = StreetViewControl;

},{"../interactions/pickcoordinatesinteraction":670,"../utils":677,"./interactioncontrol":649}],663:[function(require,module,exports){
var TOPOFFSET = 35;
module.exports = {
  layout: function layout(_ref) {
    var map = _ref.map,
        position = _ref.position,
        element = _ref.element;
  },
  changeLayoutBottomControl: function changeLayoutBottomControl(_ref2) {
    var map = _ref2.map,
        position = _ref2.position,
        element = _ref2.element,
        _ref2$isMobile = _ref2.isMobile,
        isMobile = _ref2$isMobile === undefined ? false : _ref2$isMobile;

    var viewPort = map.getViewport();
    var positionCode = (position['top'] ? 't' : 'b') + (position['left'] ? 'l' : 'r');
    var previusControls = $(viewPort).find('.ol-control-' + positionCode + ':visible');
    if (previusControls.length) {
      var previusControl = void 0;
      previusControls.each(function (index, elem) {
        if (elem != element[0]) previusControl = $(elem);else return false;
      });
      if (previusControl && positionCode === 'br') {
        if (!isMobile) {
          var previousTopPosition = previusControl.position().top;
          var elementTopPosition = element.position().top;
          if (previousTopPosition - elementTopPosition != TOPOFFSET) {
            var hOffset = previousTopPosition - TOPOFFSET;
            element.css('top', hOffset + 'px');
          }
        } else {
          var previusControlWidth = previusControl.width();
          var previousLeftPosition = previusControlWidth < 10 ? 130 : previusControlWidth + 20;
          element.css('right', previousLeftPosition + 'px');
          element.css('bottom', '15px');
        }
      }
    }
  }
};

},{}],664:[function(require,module,exports){
var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var InteractionControl = require('./interactioncontrol');

var ZoomBoxControl = function ZoomBoxControl(options) {
  this._startCoordinate = null;
  var _options = {
    name: "zoombox",
    tipLabel: "Zoom to box",
    label: "\uE901",
    interactionClass: ol.interaction.DragBox
  };
  options = (0, _assign2.default)({}, options, _options);
  InteractionControl.call(this, options);
};
ol.inherits(ZoomBoxControl, InteractionControl);
module.exports = ZoomBoxControl;

var proto = ZoomBoxControl.prototype;

proto.setMap = function (map) {
  var _this = this;

  InteractionControl.prototype.setMap.call(this, map);
  this._interaction.on('boxstart', function (e) {
    _this._startCoordinate = e.coordinate;
  });

  this._interaction.on('boxend', function (e) {
    var start_coordinate = _this._startCoordinate;
    var end_coordinate = e.coordinate;
    var extent = ol.extent.boundingExtent([start_coordinate, end_coordinate]);
    _this.dispatchEvent({
      type: 'zoomend',
      extent: extent
    });
    _this._startCoordinate = null;
    if (_this._autountoggle) {
      _this.toggle();
    }
  });
};

},{"./interactioncontrol":649,"babel-runtime/core-js/object/assign":10}],665:[function(require,module,exports){
var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utils = require('./utils');
var maphelpers = require('./map/maphelpers');

(function (name, root, factory) {
  if (typeof define === 'function' && define.amd) {
    define(factory);
  } else if ((typeof exports === 'undefined' ? 'undefined' : (0, _typeof3.default)(exports)) === 'object') {
    module.exports = factory();
  } else {
    root[name] = factory();
  }
})('g3wol3', undefined, function () {
  'use strict';

  var helpers = utils.merge({}, maphelpers);

  return {
    helpers: helpers
  };
});

},{"./map/maphelpers":674,"./utils":677,"babel-runtime/helpers/typeof":25}],666:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');
// Area
var AreaIteraction = function AreaIteraction() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.geometryType = "Polygon";
  MeasureInteraction.call(this, options);
};

ol.inherits(AreaIteraction, MeasureInteraction);

module.exports = AreaIteraction;

},{"./measureinteraction":669}],667:[function(require,module,exports){
var DeleteInteractionEvent = function DeleteInteractionEvent(type, layer, features, coordinate) {
  this.type = type;
  this.features = features;
  this.coordinate = coordinate;
};

var DeleteInteraction = function DeleteInteraction(options) {
  ol.interaction.Pointer.call(this, {
    handleDownEvent: DeleteInteraction.handleDownEvent_,
    handleMoveEvent: DeleteInteraction.handleMoveEvent_,
    handleUpEvent: DeleteInteraction.handleUpEvent_,
    handleEvent: DeleteInteraction.handleEvent_
  });

  this.previousCursor_ = undefined;
  this.startCursor_ = undefined;
  this.lastCoordinate_ = null;
  this.features_ = options.features !== undefined ? options.features : null;
  this.layer_ = options.layer !== undefined ? options.layer : null;
  this.map_ = null;
};

ol.inherits(DeleteInteraction, ol.interaction.Pointer);

DeleteInteraction.handleEvent_ = function (mapBrowserEvent) {
  if (mapBrowserEvent.type == 'keydown') {
    if (this.features_.getArray().length && mapBrowserEvent.originalEvent.keyCode == 46) {
      // an event can be string or an object with attribute type
      this.dispatchEvent(new DeleteInteractionEvent('deleteend', this.layer_, this.features_, event.coordinate));
      return true;
    }
  } else {
    return ol.interaction.Pointer.handleEvent.call(this, mapBrowserEvent);
  }
};

DeleteInteraction.handleDownEvent_ = function (event) {
  this.lastFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  if (this.lastFeature_) {
    DeleteInteraction.handleMoveEvent_.call(this, event);
    this.dispatchEvent(new DeleteInteractionEvent('deleteend', this.layer_, this.features_, event.coordinate));
    return true;
  }
  return false;
};

DeleteInteraction.handleMoveEvent_ = function (event) {
  var _this = this;

  this.map_ = event.map;
  var elem = this.map_.getTargetElement();
  if (this.startCursor_ === undefined) {
    this.startCursor_ = elem.style.cursor;
  }
  var intersectingFeature = this.map_.forEachFeatureAtPixel(event.pixel, function (feature, layer) {
    ///check if is the same layero of editing
    feature = layer == _this.layer_ ? feature : null;
    return feature;
  });
  if (intersectingFeature) {
    this.previousCursor_ = elem.style.cursor;
    elem.style.cursor = 'pointer';
  } else {
    elem.style.cursor = this.previousCursor_ !== undefined ? this.previousCursor_ : '';
    this.previousCursor_ = undefined;
  }
};

DeleteInteraction.prototype.featuresAtPixel_ = function (pixel, map) {
  var found = null;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel, function (feature) {
    return feature;
  });
  if (this.features_ && _.includes(this.features_.getArray(), intersectingFeature)) {
    found = intersectingFeature;
  }
  return found;
};

DeleteInteraction.prototype.clear = function () {
  var elem = void 0;
  if (this.map_) {
    elem = this.map_.getTargetElement();
    elem.style.cursor = this.startCursor_;
  }
};

module.exports = DeleteInteraction;

},{}],668:[function(require,module,exports){
var MeasureInteraction = require('./measureinteraction');

// LenghtInteracion
var LengthIteraction = function LengthIteraction() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.geometryType = "LineString";
  MeasureInteraction.call(this, options);
};

ol.inherits(LengthIteraction, MeasureInteraction);

module.exports = LengthIteraction;

},{"./measureinteraction":669}],669:[function(require,module,exports){
// MeasureInteracion

var MeasureIteraction = function MeasureIteraction() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._helpTooltip;
  this._measureTooltipElement;
  this._measureTooltip;
  this._featureGeometryChangelistener;
  this._poinOnMapMoveListener;
  this._helpMsg = options.help;
  this._projection = options.projection;
  var useSphereMethods = ['EPSG:3857', 'EPSG:4326'].indexOf(this._projection.getCode()) !== -1;
  var measureStyle = new ol.style.Style({
    fill: new ol.style.Fill({
      color: 'rgba(255, 255, 255, 0.2)'
    }),
    stroke: new ol.style.Stroke({
      color: 'rgba(0, 0, 0, 0.5)',
      lineDash: [10, 10],
      width: 3
    }),
    image: new ol.style.Circle({
      radius: 5,
      stroke: new ol.style.Stroke({
        color: 'rgba(0, 0, 0, 0.7)'
      }),
      fill: new ol.style.Fill({
        color: 'rgba(255, 255, 255, 0.2)'
      })
    })
  });
  var geometryType = options.geometryType || 'LineString';
  this._formatMeasure = null;
  // handel keydown event - delete of last vertex
  this._keyDownEventHandler = null;
  switch (geometryType) {
    case 'LineString':
      this._formatMeasure = function (feature) {
        var geometry = feature;
        if (this._projection.getUnits() === 'degrees') {
          geometry = feature.clone();
          geometry.transform(this._projection.getCode(), 'EPSG:3857');
        }
        var length = Math.round(useSphereMethods ? ol.Sphere.getLength(geometry) : geometry.getLength() * 100) / 100;
        var output = length > 1000 ? (length / 1000).toFixed(3) + ' km' : length.toFixed(2) + ' m';
        return output;
      };
      break;
    case 'Polygon':
      this._formatMeasure = function (feature) {
        var geometry = feature;
        if (this._projection.getUnits() === 'degrees') {
          geometry = feature.clone();
          geometry.transform(this._projection.getCode(), 'EPSG:3857');
        }
        var area = useSphereMethods ? ol.Sphere.getArea(geometry) : geometry.getArea();
        var output = area > 1000000 ? (area / 1000000).toFixed(6) + ' km<sup>2</sup>' : area.toFixed(3) + ' m<sup>2</sup>';
        return output;
      };
      break;
  }
  var source = new ol.source.Vector();
  this._helpTooltipElement;
  this._map = null;
  this._feature = null;
  this._layer = new ol.layer.Vector({
    source: source,
    style: function style(feature) {
      var styles = [
      // linestring
      new ol.style.Style({
        stroke: new ol.style.Stroke({
          lineDash: [10, 10],
          width: 3
        }),
        fill: new ol.style.Fill({
          color: 'rgba(255, 255, 255, 0.2)'
        })
      })];
      return styles;
    }
  });
  ol.interaction.Draw.call(this, {
    source: source,
    type: geometryType,
    style: measureStyle
  });
  this.set('beforeRemove', this.clear);
  this.set('layer', this._layer);
  // register event on two action
  this.on('drawstart', this._drawStart);
  this.on('drawend', this._drawEnd);
};

ol.inherits(MeasureIteraction, ol.interaction.Draw);

var proto = MeasureIteraction.prototype;

proto.setDrawMessage = function (message) {
  this._helpMsg = message;
};

proto.clear = function () {
  this._layer.getSource().clear();
  this._clearMessagesAndListeners();
  if (this._map) {
    this._map.removeOverlay(this._measureTooltip);
    this._map.removeLayer(this._layer);
  }
};

proto._clearMessagesAndListeners = function () {
  this._feature = null;
  // unset tooltip so that a new one can be created
  if (this._map) {
    this._measureTooltipElement = null;
    this._helpTooltipElement.innerHTML = '';
    this._helpTooltipElement.classList.add('hidden');
    ol.Observable.unByKey(this._featureGeometryChangelistener);
    ol.Observable.unByKey(this._poinOnMapMoveListener);
    $(document).off('keydown', this._keyDownEventHandler);
  }
};

proto._removeLastPoint = function (event) {
  var geom = this._feature.getGeometry();
  if (event.keyCode === 46) {
    if (geom instanceof ol.geom.Polygon && geom.getCoordinates()[0].length > 2) {
      this.removeLastPoint();
    } else if (geom instanceof ol.geom.LineString && geom.getCoordinates().length > 1) {
      this.removeLastPoint();
    }
  }
};

//drawStart function
proto._drawStart = function (evt) {
  var _this = this;

  this._map = this.getMap();
  this._map.removeLayer(this._layer);
  this._createMeasureTooltip();
  this._createHelpTooltip();
  this._feature = evt.feature;
  this._keyDownEventHandler = _.bind(this._removeLastPoint, this);
  $(document).on('keydown', this._keyDownEventHandler);
  // vado a ripulire tutte le features
  this._layer.getSource().clear();
  this._poinOnMapMoveListener = this._map.on('pointermove', function (evt) {
    if (evt.dragging) return;
    if (_this._feature) helpMsg = _this._helpMsg;
    _this._helpTooltipElement.innerHTML = helpMsg;
    _this._helpTooltip.setPosition(evt.coordinate);
    _this._helpTooltipElement.classList.remove('hidden');
  });
  var tooltipCoord = evt.coordinate;
  this._featureGeometryChangelistener = this._feature.getGeometry().on('change', function (evt) {
    var geom = evt.target;
    if (geom instanceof ol.geom.Polygon) tooltipCoord = geom.getInteriorPoint().getCoordinates();else if (geom instanceof ol.geom.LineString) tooltipCoord = geom.getLastCoordinate();
    var output = _this._formatMeasure(geom);
    _this._measureTooltipElement.innerHTML = output;
    _this._measureTooltip.setPosition(tooltipCoord);
  });
};

//funzione drawEnd
proto._drawEnd = function () {
  this._measureTooltipElement.className = 'mtooltip mtooltip-static';
  this._measureTooltip.setOffset([0, -7]);
  this._clearMessagesAndListeners();
  this._map.addLayer(this._layer);
};

/**
 * Creates a new help tooltip
 */
proto._createHelpTooltip = function () {
  this._helpTooltipElement && this._helpTooltipElement.parentNode.removeChild(this._helpTooltipElement);
  this._helpTooltip && this._map.removeOverlay(this._helpTooltip);
  this._helpTooltipElement = document.createElement('div');
  this._helpTooltipElement.className = 'mtooltip hidden';
  this._helpTooltip = new ol.Overlay({
    element: this._helpTooltipElement,
    offset: [15, 0],
    positioning: 'center-left'
  });
  this._map.addOverlay(this._helpTooltip);
};

/**
 * Creates a new measure tooltip
 */
proto._createMeasureTooltip = function () {
  this._measureTooltipElement && this._measureTooltipElement.parentNode.removeChild(this._measureTooltipElement);
  this._measureTooltip && this._map.removeOverlay(this._measureTooltip);
  this._measureTooltipElement = document.createElement('div');
  this._measureTooltipElement.className = 'mtooltip mtooltip-measure';
  this._measureTooltip = new ol.Overlay({
    element: this._measureTooltipElement,
    offset: [0, -15],
    positioning: 'bottom-center'
  });
  this._map.addOverlay(this._measureTooltip);
};
// END MEASURE CONTROLS //

module.exports = MeasureIteraction;

},{}],670:[function(require,module,exports){
var PickCoordinatesEventType = {
  PICKED: 'picked'
};

var PickCoordinatesEvent = function PickCoordinatesEvent(type, coordinate) {
  this.type = type;
  this.coordinate = coordinate;
};

var PickCoordinatesInteraction = function PickCoordinatesInteraction(options) {
  this.previousCursor_ = null;
  this._centerMap = null;

  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickCoordinatesInteraction.handleDownEvent_,
    handleUpEvent: PickCoordinatesInteraction.handleUpEvent_,
    handleMoveEvent: PickCoordinatesInteraction.handleMoveEvent_
  });
};

ol.inherits(PickCoordinatesInteraction, ol.interaction.Pointer);

PickCoordinatesInteraction.handleDownEvent_ = function (event) {
  var _this = this;

  this._centerMap = event.map.getView().getCenter();
  // set timeout to avoid to block pan
  setTimeout(function () {
    if (_this._centerMap === event.map.getView().getCenter()) {
      PickCoordinatesInteraction.handleUpEvent_.call(_this, event);
    }
  }, 300);
  // return false to avoid  start of drag event
  return false;
};

PickCoordinatesInteraction.handleUpEvent_ = function (event) {
  this.dispatchEvent(new PickCoordinatesEvent(PickCoordinatesEventType.PICKED, event.coordinate));
  // it used to stop drag event
  return false;
};

PickCoordinatesInteraction.handleMoveEvent_ = function (event) {
  var elem = event.map.getTargetElement();
  elem.style.cursor = 'pointer';
  return true;
};

PickCoordinatesInteraction.prototype.shouldStopEvent = function () {
  return false;
};

PickCoordinatesInteraction.prototype.setActive = function (active) {
  var map = this.getMap();
  if (map) {
    var elem = map.getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setActive.call(this, active);
};

PickCoordinatesInteraction.prototype.setMap = function (map) {
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this, map);
};

module.exports = PickCoordinatesInteraction;

},{}],671:[function(require,module,exports){
var PickFeatureEventType = {
  PICKED: 'picked'
};

var PickFeatureEvent = function PickFeatureEvent(type, coordinate, layer, feature) {
  this.type = type;
  this.feature = feature;
  this.coordinate = coordinate;
  this.layer = layer;
};

var PickFeatureInteraction = function PickFeatureInteraction() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  ol.interaction.Pointer.call(this, {
    handleDownEvent: PickFeatureInteraction.handleDownEvent_,
    handleUpEvent: PickFeatureInteraction.handleUpEvent_,
    handleMoveEvent: PickFeatureInteraction.handleMoveEvent_
  });
  this.features_ = options.features || null;
  this.layers_ = options.layers || null;
  this.pickedFeature_ = null;
  this.pickedLayer_ = null;
  this.layerFilter_ = function (layer) {
    var include = _.includes(_this.layers_, layer);
    _this.pickedLayer_ = include && layer;
    return include;
  };
};
ol.inherits(PickFeatureInteraction, ol.interaction.Pointer);

PickFeatureInteraction.handleDownEvent_ = function (event) {
  this.pickedFeature_ = this.featuresAtPixel_(event.pixel, event.map);
  return this.pickedFeature_;
};

PickFeatureInteraction.handleUpEvent_ = function (event) {
  if (this.pickedFeature_) {
    this.dispatchEvent(new PickFeatureEvent(PickFeatureEventType.PICKED, event.coordinate, this.pickedLayer_, this.pickedFeature_));
  }
  return true;
};

PickFeatureInteraction.handleMoveEvent_ = function (event) {
  var elem = event.map.getTargetElement();
  var intersectingFeature = this.featuresAtPixel_(event.pixel, event.map);
  if (intersectingFeature) {
    elem.style.cursor = 'pointer';
  } else {
    elem.style.cursor = '';
  }
};

PickFeatureInteraction.prototype.featuresAtPixel_ = function (pixel, map) {
  var _this2 = this;

  var featureFound = null;
  var intersectingFeature = map.forEachFeatureAtPixel(pixel, function (feature) {
    if (_this2.features_) {
      if (_this2.features_.indexOf(feature) > -1) {
        return feature;
      } else {
        return null;
      }
    }
    return feature;
  }, {
    layerFilter: this.layerFilter_,
    hitTolerance: isMobile && isMobile.any ? 10 : 0
  });
  if (intersectingFeature) {
    featureFound = intersectingFeature;
  }
  return featureFound;
};

PickFeatureInteraction.prototype.shouldStopEvent = function () {
  return false;
};

PickFeatureInteraction.prototype.setMap = function (map) {
  if (!map) {
    var elem = this.getMap().getTargetElement();
    elem.style.cursor = '';
  }
  ol.interaction.Pointer.prototype.setMap.call(this, map);
};

module.exports = PickFeatureInteraction;

},{}],672:[function(require,module,exports){
var _config = require('../../config/config');

var Projections = require('../projection/projections');
var BaseLayers = {};

BaseLayers.OSM = new ol.layer.Tile({
  source: new ol.source.OSM(),
  id: 'osm',
  title: 'OSM',
  basemap: true
});

BaseLayers.BING = {};

BaseLayers.BING.Road = new ol.layer.Tile({
  name: 'Road',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: _config.BING_API_KEY,
    imagerySet: 'Road'
    // use maxZoom 19 to see stretched tiles instead of the BingMaps
    // "no photos at this zoom level" tiles
    // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.TMS = {
  get: function get() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$visible = _ref.visible,
        visible = _ref$visible === undefined ? false : _ref$visible,
        _ref$url = _ref.url,
        url = _ref$url === undefined ? null : _ref$url,
        _ref$source_type = _ref.source_type,
        source_type = _ref$source_type === undefined ? "xyz" : _ref$source_type,
        minZoom = _ref.minZoom,
        maxZoom = _ref.maxZoom,
        projection = _ref.projection,
        attributions = _ref.attributions;

    var source = void 0;
    switch (source_type) {
      case 'xyz':
        source = new ol.source.XYZ({
          url: url,
          minZoom: minZoom,
          maxZoom: maxZoom,
          attributions: attributions,
          projection: projection
        });
        break;
      case 'arcgismapserver':
        source = new ol.source.TileArcGISRest({
          url: url,
          projection: projection,
          attributions: attributions
        });
        break;
      default:
    }
    return new ol.layer.Tile({
      visible: visible,
      source: source,
      basemap: true
    });
  }
};

BaseLayers.WMTS = {
  get: function get() {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        url = _ref2.url,
        layer = _ref2.layer,
        visible = _ref2.visible,
        attributions = _ref2.attributions,
        crs = _ref2.crs,
        _ref2$format = _ref2.format,
        format = _ref2$format === undefined ? 'image/png' : _ref2$format,
        _ref2$opacity = _ref2.opacity,
        opacity = _ref2$opacity === undefined ? 0.7 : _ref2$opacity;

    var projection = Projections.get('EPSG:' + crs);
    var projectionExtent = projection.getExtent();
    var size = ol.extent.getWidth(projectionExtent) / 256;
    var matrixIds = [];
    var resolutions = [];
    for (var i = 0; i < 18; i++) {
      matrixIds[i] = i.toString();
      resolutions[i] = size / Math.pow(2, i);
    }
    url = 'https://hazards.fema.gov/gis/nfhl/rest/services/FIRMette/NFHLREST_FIRMette/MapServer/16';
    return new ol.layer.Tile({
      opacity: opacity,
      source: new ol.source.TileArcGISRest({
        url: url
      })
    });
  }
};

BaseLayers.BING.AerialWithLabels = new ol.layer.Tile({
  name: 'AerialWithLabels',
  visible: true,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: _config.BING_API_KEY,
    imagerySet: 'AerialWithLabels'
    // use maxZoom 19 to see stretched tiles instead of the BingMaps
    // "no photos at this zoom level" tiles
    // maxZoom: 19
  }),
  basemap: true
});

BaseLayers.BING.Aerial = new ol.layer.Tile({
  name: 'Aerial',
  visible: false,
  preload: Infinity,
  source: new ol.source.BingMaps({
    key: _config.BING_API_KEY,
    imagerySet: 'Aerial'
    // use maxZoom 19 to see stretched tiles instead of the BingMaps
    // "no photos at this zoom level" tiles
    // maxZoom: 19
  }),
  basemap: true
});

module.exports = BaseLayers;

},{"../../config/config":644,"../projection/projections":676}],673:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var RasterLayers = {};
var DPI = require('../utils/utils').getDPI();

RasterLayers.TiledWMSLayer = function (layerObj, extraParams) {
  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {},
    tiled: true
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers.WMSLayer = function (layerObj, extraParams) {
  var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';

  var options = {
    layerObj: layerObj,
    extraParams: extraParams || {},
    method: method
  };
  return RasterLayers._WMSLayer(options);
};

RasterLayers.WMTSLayer = function (layerObj, extraParams) {
  var optionsFromCapabilities = ol.source.WMTS.optionsFromCapabilities;
  return new ol.layer.Tile({
    opacity: 1,
    source: new ol.source.WMTS(options)
  });
};

RasterLayers.ImageArgisMapServer = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return new ol.layer.Image({
    source: new ol.source.ImageArcGISRest({
      ratio: options.ratio,
      params: {
        FORMAT: options.format
      },
      url: options.url
    })
  });
};

RasterLayers.TiledArgisMapServer = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return new ol.layer.Tile({
    extent: options.extent,
    source: new ol.source.TileArcGISRest({
      url: options.url
    })
  });
};

RasterLayers._WMSLayer = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var layerObj = options.layerObj;
  var method = options.method || 'GET';
  var extraParams = options.extraParams;
  var tiled = options.tiled || false;
  var projection = layerObj.projection ? layerObj.projection.getCode() : null;
  var params = {
    LAYERS: layerObj.layers || '',
    VERSION: '1.3.0',
    TRANSPARENT: true,
    SLD_VERSION: '1.1.0',
    DPI: DPI
  };
  params = (0, _assign2.default)({}, params, extraParams);
  var sourceOptions = {
    url: layerObj.url,
    params: params,
    ratio: 1,
    projection: projection
  };
  if (method === 'POST') {
    window.URL = window.URL || window.webkitURL;
    sourceOptions.imageLoadFunction = function (image, url) {
      var xhr = new XMLHttpRequest();

      var _url$split = url.split('?'),
          _url$split2 = (0, _slicedToArray3.default)(_url$split, 2),
          _url = _url$split2[0],
          params = _url$split2[1];

      xhr.open('POST', _url);
      xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
      xhr.responseType = 'blob';
      xhr.onload = function () {
        var data = this.response;
        if (data !== undefined) {
          image.getImage().src = window.URL.createObjectURL(data);
        } else {
          image.setState(ol.TileState.ERROR);
        }
      };
      xhr.onerror = function () {
        image.setState(ol.TileState.ERROR);
      };
      xhr.send(params);
    };
  }

  var imageOptions = {
    id: layerObj.id,
    name: layerObj.name,
    opacity: layerObj.opacity || 1.0,
    visible: layerObj.visible,
    maxResolution: layerObj.maxResolution
  };

  var imageClass = void 0;
  var source = void 0;
  if (tiled) {
    source = new ol.source.TileWMS(sourceOptions);
    imageClass = ol.layer.Tile;
  } else {
    source = new ol.source.ImageWMS(sourceOptions);
    imageClass = ol.layer.Image;
  }

  imageOptions.source = source;

  return new imageClass(imageOptions);
};

RasterLayers.XYZLayer = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'GET';

  if (!options.url) {
    return;
  }
  var sourceOptions = {
    url: options.url
  };
  if (options.projection) {
    sourceOptions.projection = options.projection;
  }
  if (options.maxZoom) {
    sourceOptions.maxZoom = options.maxZoom;
  }
  if (options.minZoom) {
    sourceOptions.minZoom = options.minZoom;
  }
  // if (method === 'POST') {
  //   window.URL = window.URL || window.webkitURL;
  //   sourceOptions.tileLoadFunction = function(imageTile, url) {
  //     const xhr = new XMLHttpRequest();
  //     xhr.open('POST', url);
  //     xhr.setRequestHeader('Content-Type', 'image/png');
  //     xhr.responseType = 'blob';
  //     xhr.onload = function() {
  //       const data = this.response;
  //       if (data !== undefined) {
  //         imageTile.getImage().src = window.URL.createObjectURL(data);
  //       } else {
  //         imageTile.setState(ol.TileState.ERROR);
  //       }
  //     };
  //     xhr.onerror = function() {
  //       imageTile.setState(ol.TileState.ERROR);
  //     };
  //     xhr.send();
  //   };
  // }
  return new ol.layer.Tile({
    source: new ol.source.XYZ(sourceOptions)
  });
};

module.exports = RasterLayers;

},{"../utils/utils":678,"babel-runtime/core-js/object/assign":10,"babel-runtime/helpers/slicedToArray":23}],674:[function(require,module,exports){
BaseLayers = require('../layers/bases');

var MapHelpers = {
  createViewer: function createViewer(opts) {
    return new _Viewer(opts);
  }
};

var _Viewer = function _Viewer() {
  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var controls = ol.control.defaults({
    attribution: false,
    zoom: false
  });

  var interactions = ol.interaction.defaults().extend([new ol.interaction.DragRotate()]);
  interactions.removeAt(1); // remove douclickzoom

  var view = void 0;
  if (opts.view instanceof ol.View) {
    view = opts.view;
  } else {
    view = new ol.View(opts.view);
  }
  var options = {
    controls: controls,
    interactions: interactions,
    ol3Logo: false,
    view: view,
    keyboardEventTarget: document
  };
  if (opts.id) {
    options.target = opts.id;
  }
  var map = new ol.Map(options);
  this.map = map;
};

_Viewer.prototype.destroy = function () {
  if (this.map) {
    this.map.dispose();
    this.map = null;
  }
};

_Viewer.prototype.getView = function () {
  return this.map.getView();
};

_Viewer.prototype.updateMap = function (mapObject) {};

_Viewer.prototype.updateView = function () {};

_Viewer.prototype.getMap = function () {
  return this.map;
};

_Viewer.prototype.setTarget = function (id) {
  this.map.setTarget(id);
};

_Viewer.prototype.zoomTo = function (coordinate, zoom) {
  var view = this.map.getView();
  view.setCenter(coordinate);
  view.setZoom(zoom);
};

_Viewer.prototype.goTo = function (coordinates, options) {
  options = options || {};
  var animate = options.animate || true;
  var zoom = options.zoom || false;
  var view = this.map.getView();
  var panAnimation = void 0;
  var duration = 300;
  var zoomAnimation = void 0;
  if (animate) {
    panAnimation = {
      duration: duration,
      center: coordinates
    };
    if (zoom) {
      zoomAnimation = {
        duration: duration,
        zoom: zoom
      };
    } else {
      zoomAnimation = {
        duration: duration,
        resolution: view.getResolution()
      };
    }
    view.animate(panAnimation, zoomAnimation);
  } else {
    view.setCenter(coordinates);
    if (zoom) {
      view.setZoom(zoom);
    }
  }
};

_Viewer.prototype.goToRes = function (coordinates, options) {
  options = options || {};
  var animate = options.animate || true;
  var view = this.map.getView();
  var resolution = options.resolution || view.getResolution();
  var panAnimation = void 0;
  var zoomAnimation = void 0;
  if (animate) {
    panAnimation = {
      duration: 200,
      center: coordinates
    };
    zoomAnimation = {
      duration: 200,
      resolution: resolution
    };
    view.animate(panAnimation, zoomAnimation);
  } else {
    view.setCenter(coordinates);
    view.setResolution(resolution);
  }
};

_Viewer.prototype.fit = function (geometry) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var view = this.map.getView();
  var animate = options.animate || true;
  var panAnimation = void 0;
  var zoomAnimation = void 0;
  var duration = 200;
  if (animate) {
    panAnimation = view.animate({
      duration: duration,
      center: view.getCenter()
    });
    zoomAnimation = view.animate({
      duration: duration,
      resolution: view.getResolution()
    });
  }

  if (options.animate) {
    delete options.animate; // non lo passo al metodo di OL3 perch  un'opzione interna
  }
  options.constrainResolution = options.constrainResolution === undefined && true || options.constrainResolution;
  options.size = this.map.getSize();
  view.fit(geometry, options);
};

_Viewer.prototype.getZoom = function () {
  var view = this.map.getView();
  return view.getZoom();
};

_Viewer.prototype.getResolution = function () {
  var view = this.map.getView();
  return view.getResolution();
};

_Viewer.prototype.getCenter = function () {
  var view = this.map.getView();
  return view.getCenter();
};

_Viewer.prototype.getBBOX = function () {
  return this.map.getView().calculateExtent(this.map.getSize());
};

_Viewer.prototype.getLayerByName = function (layerName) {
  var layers = this.map.getLayers();
  var length = layers.getLength();
  for (var i = 0; i < length; i++) {
    if (layerName === layers.item(i).get('name')) {
      return layers.item(i);
    }
  }
  return null;
};

_Viewer.prototype.removeLayerByName = function (layerName) {
  var layer = this.getLayerByName(layerName);
  if (layer) {
    this.map.removeLayer(layer);
    layer = undefined;
  }
};

_Viewer.prototype.getActiveLayers = function () {
  var activelayers = [];
  this.map.getLayers().forEach(function (layer) {
    var props = layer.getProperties();
    if (props.basemap !== true && props.visible) {
      activelayers.push(layer);
    }
  });

  return activelayers;
};

_Viewer.prototype.removeLayers = function () {
  this.map.getLayers().clear();
};

_Viewer.prototype.getLayersNoBase = function () {
  var layers = [];
  this.map.getLayers().forEach(function (layer) {
    var props = layer.getProperties();
    if (props.basemap != true) {
      layers.push(layer);
    }
  });

  return layers;
};

_Viewer.prototype.addBaseLayer = function (type) {
  var layer = void 0;
  type ? layer = BaseLayers[type] : layer = BaseLayers.BING.Aerial;
  this.map.addLayer(layer);
};

_Viewer.prototype.changeBaseLayer = function (layerName) {
  var baseLayer = this.getLayerByName(layername);
  var layers = this.map.getLayers();
  layers.insertAt(0, baseLayer);
};

module.exports = MapHelpers;

},{"../layers/bases":672}],675:[function(require,module,exports){
var GENERIC_GRID_EXTENT = [0, 0, 8388608, 8388608];

var Projection = function Projection() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  if (!options.crs) return null;
  options.proj4def && proj4.defs(options.crs, options.proj4def);
  this._axisOrientation = options.axisOrientation || 'enu';
  if (options.proj4def) {
    var proj4def = proj4.defs(options.crs);
    if (proj4def.axis !== undefined) this._axisOrientation = proj4def.axis;
    if (options.crs === 'EPSG:3045' || options.crs === 'EPSG:6708') this._axisOrientation = 'neu';
  }
  ol.proj.Projection.call(this, {
    code: options.crs,
    extent: options.extent ? options.extent : GENERIC_GRID_EXTENT,
    axisOrientation: this._axisOrientation
  });
};

ol.inherits(Projection, ol.proj.Projection);

var proto = Projection.prototype;

proto.getAxisOrientation = function () {
  return this._axisOrientation;
};

proto.isInvertedAxisOrientation = function () {
  return this._axisOrientation === 'neu';
};

proto.getOlProjection = function () {};

module.exports = Projection;

},{}],676:[function(require,module,exports){
var Projection = require('./projection');

var Projections = {
  get: function get(crs, proj4def, extent) {
    crs = Projections.normalizeCrs(crs);
    var _proj = ol.proj.projections ? ol.proj.projections : ol.proj;
    var cachedProjection = _proj.get(crs);
    if (cachedProjection) return cachedProjection;
    var projection = new Projection({
      crs: crs,
      proj4def: proj4def,
      extent: extent
    });
    _proj.add ? _proj.add(crs, projection) : _proj.addProjection(projection);
    return projection;
  },
  normalizeCrs: function normalizeCrs(crs) {
    if (typeof crs === 'number') return "EPSG:" + crs;
    crs = crs.replace(/[^\d\.\-]/g, "");
    if (crs !== '') return "EPSG:" + parseInt(crs);
  }
};

Projections.get("EPSG:3045", "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
Projections.get("EPSG:6708", "+proj=utm +zone=33 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs");
Projections.get("EPSG:32632", "+proj=utm +zone=32 +datum=WGS84 +units=m +no_defs");
Projections.get("EPSG:32633", "+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs");
Projections.get("EPSG:25833", "+proj=utm +zone=33 +ellps=GRS80 +units=m +no_defs");
Projections.get("EPSG:23032", "+proj=utm +zone=32 +ellps=intl +units=m +no_defs ");
Projections.get("EPSG:23033", "+proj=utm +zone=33 +ellps=intl +units=m +no_defs");

module.exports = Projections;

},{"./projection":675}],677:[function(require,module,exports){
var utils = {
  merge: function merge(obj1, obj2) {
    var obj3 = {};
    for (var attrname in obj1) {
      obj3[attrname] = obj1[attrname];
    }
    for (var _attrname in obj2) {
      obj3[_attrname] = obj2[_attrname];
    }
    return obj3;
  }
};

module.exports = utils;

},{}],678:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OGC_PIXEL_WIDTH = 0.28;

var INCHES_PER_UNIT = {
  m: 39.37, //
  degrees: 4374754
};

//const DOTS_PER_INCH = ol.has.DEVICE_PIXEL_RATIO * 96; //DPI96
var DOTS_PER_INCH = 96; //DPI96

var utils = {
  getExtentForViewAndSize: function getExtentForViewAndSize(center, resolution, rotation, size) {
    var dx = resolution * size[0] / 2;
    var dy = resolution * size[1] / 2;
    var cosRotation = Math.cos(rotation);
    var sinRotation = Math.sin(rotation);
    var xCos = dx * cosRotation;
    var xSin = dx * sinRotation;
    var yCos = dy * cosRotation;
    var ySin = dy * sinRotation;
    var x = center[0];
    var y = center[1];
    var x0 = x - xCos + ySin;
    var x1 = x - xCos - ySin;
    var x2 = x + xCos - ySin;
    var x3 = x + xCos + ySin;
    var y0 = y - xSin - yCos;
    var y1 = y - xSin + yCos;
    var y2 = y + xSin + yCos;
    var y3 = y + xSin - yCos;
    //return [Math.min(y0, y1, y2, y3),Math.min(x0, x1, x2, x3), Math.max(y0, y1, y2, y3), Math.max(x0, x1, x2, x3)]
    return [Math.min(x0, x1, x2, x3), Math.min(y0, y1, y2, y3), Math.max(x0, x1, x2, x3), Math.max(y0, y1, y2, y3)];
  },
  // function that create a polygon vector layer from bbox
  createPolygonLayerFromBBox: function createPolygonLayerFromBBox(bbox) {
    var polygonFeature = new ol.Feature(new ol.geom.Polygon.fromExtent(bbox));
    var vectorSource = new ol.source.Vector({
      features: [polygonFeature]
    });
    var polygonLayer = new ol.layer.Vector({
      source: vectorSource
    });
    return polygonLayer;
  },
  reverseGeometry: function reverseGeometry(geometry) {
    var reverseCoordinates = function reverseCoordinates(coordinates) {
      coordinates.find(function (coordinate) {
        if (Array.isArray(coordinate)) {
          reverseCoordinates(coordinate);
        } else {
          var _coordinates = (0, _slicedToArray3.default)(coordinates, 2),
              y = _coordinates[0],
              x = _coordinates[1];

          coordinates[0] = x;
          coordinates[1] = y;
          return true;
        }
      });
    };
    var coordinates = geometry.getCoordinates();
    reverseCoordinates(coordinates);
    geometry.setCoordinates(coordinates);
    return geometry;
  },
  resToScale: function resToScale(resolution) {
    var unit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'm';

    var scale = void 0;
    switch (unit) {
      case 'm':
        scale = resolution * 1000 / OGC_PIXEL_WIDTH;
        break;
    }
    return scale;
  },
  scaleToRes: function scaleToRes(scale, unit) {
    unit = unit || 'm';
    var resolution = void 0;
    switch (unit) {
      case 'm':
        resolution = scale * OGC_PIXEL_WIDTH / 1000;
        break;
    }
    return resolution;
  },
  getScaleFromResolution: function getScaleFromResolution(resolution) {
    var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";

    return Math.round(resolution * INCHES_PER_UNIT[units] * DOTS_PER_INCH);
  },
  getResolutionFromScale: function getResolutionFromScale(scale) {
    var units = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "m";

    var normScale = scale > 1.0 ? 1.0 / scale : scale; // just to prevent that scale is passed as 1:10000 or 0.0001
    return 1 / (normScale * INCHES_PER_UNIT[units] * DOTS_PER_INCH);
  },
  getDPI: function getDPI() {
    return DOTS_PER_INCH;
  },
  getMetersFromDegrees: function getMetersFromDegrees(degrees) {
    return degrees * ol.proj.Units.METERS_PER_UNIT.degrees;
  }
};

module.exports = utils;

},{"babel-runtime/helpers/slicedToArray":23}],679:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');

function CatalogService() {
  var _this2 = this;

  this.state = {
    prstate: ProjectsRegistry.state,
    highlightlayers: false,
    externallayers: [],
    layerstrees: [],
    layersgroups: []
  };
  this.setters = {};

  this.addExternalLayer = function (layer) {
    layer.removable = true;
    this.state.externallayers.push(layer);
  };

  this.createLayersGroup = function () {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$title = _ref.title,
        title = _ref$title === undefined ? 'Layers Group' : _ref$title,
        _ref$layers = _ref.layers,
        layers = _ref$layers === undefined ? [] : _ref$layers;

    var nodes = [];
    layers.forEach(function (layer) {
      nodes.push(layer);
    });
    return {
      title: title,
      nodes: nodes
    };
  };

  this.getMajorQgisVersion = function () {
    return ProjectsRegistry.getCurrentProject().getQgisVersion({
      type: 'major'
    });
  };

  // method to add a custom layers group
  this.addLayersGroup = function (layersGroup) {
    this.state.layersgroups.push(layersGroup);
  };

  this.removeExternalLayer = function (name) {
    var _this = this;

    this.state.externallayers.forEach(function (layer, index) {
      if (layer.name === name) {
        _this.state.externallayers.splice(index, 1);
        return false;
      }
    });
  };

  this.addLayersStoreToLayersTrees = function (layersStore) {
    this.state.layerstrees.push({
      tree: layersStore.getLayersTree(),
      storeid: layersStore.getId()
    });
  };

  base(this);

  var layersStores = CatalogLayersStoresRegistry.getLayersStores();
  layersStores.forEach(function (layersStore) {
    _this2.addLayersStoreToLayersTrees(layersStore);
  });

  CatalogLayersStoresRegistry.onafter('addLayersStore', function (layersStore) {
    _this2.addLayersStoreToLayersTrees(layersStore);
  });

  CatalogLayersStoresRegistry.onafter('removeLayersStore', function (layersStore) {
    _this2.state.layerstrees.forEach(function (layersTree, idx) {
      if (layersTree.storeid === layersStore.getId()) {
        _this2.state.layerstrees.splice(idx, 1);
        return false;
      }
    });
  });
  CatalogLayersStoresRegistry.onafter('removeLayersStores', function () {
    _this2.state.layerstrees.forEach(function (layersTree, idx) {
      _this2.state.layerstrees.splice(idx, 1);
      return false;
    });
  });
}

inherit(CatalogService, G3WObject);

module.exports = CatalogService;

},{"core/catalog/cataloglayersstoresregistry":561,"core/g3wobject":569,"core/project/projectsregistry":624,"core/utils/utils":630}],680:[function(require,module,exports){
module.exports = "<!-- item template -->\n<div id=\"catalog\" @contextmenu.prevent.stop=\"\" class=\"tabbable-panel catalog\">\n  <div class=\"tabbable-line\">\n    <ul class=\"nav nav-tabs catalalog-nav-tabs\" role=\"tablist\">\n      <li v-if=\"hasLayers\" role=\"presentation\"  :class=\"{ active: activeTab === 'layers' && 'hasLayers' }\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\">\n        <a href=\"#tree\" aria-controls=\"tree\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"tree\" v-t=\"'data'\"></a>\n      </li>\n      <li v-if=\"hasBaseLayers\" role=\"presentation\" :class=\"{ active: activeTab === 'baselayers' }\" :style=\"{width: !hasLayers ? '100%' : '32%'}\">\n        <a href=\"#baselayers\" aria-controls=\"baselayers\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"baselayers\" v-t=\"'baselayers'\"></a>\n      </li>\n      <li v-if=\"showlegend\" role=\"presentation\" :class=\"{ active: activeTab === 'legend' }\" :style=\"{width: hasBaseLayers ? '32%' : '48%'}\">\n        <a href=\"#legend\" aria-controls=\"legend\" role=\"tab\" data-toggle=\"tab\" data-i18n=\"legend\" v-t=\"'legend'\"></a>\n      </li>\n    </ul>\n    <div class=\"tab-content\">\n      <div role=\"tabpanel\" class=\"tab-pane\" :class=\"{ active: activeTab === 'layers' && 'hasLayers' }\" id=\"tree\">\n        <div id=\"toc_layer_help_text\" v-t=\"'catalog_items.helptext'\">\n          <span class=\"info_helptext_button\">i</span>\n        </div>\n        <ul class=\"tree-root\" v-for=\"_layerstree in state.layerstrees\">\n          <tristate-tree\n            :highlightlayers=\"state.highlightlayers\"\n            :layerstree=\"layerstree\"\n            class=\"item\"\n            :parentFolder=\"false\"\n            :root=\"true\"\n            :parent_mutually_exclusive=\"false\"\n            v-for=\"layerstree in _layerstree.tree\"\n            :storeid=\"_layerstree.storeid\"\n            :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>\n        <ul>\n          <tristate-tree  :externallayers=\"state.externallayers\" :layerstree=\"layerstree\" class=\"item\" v-for=\"layerstree in state.externallayers\" :key=\"layerstree.id\">\n          </tristate-tree>\n        </ul>\n        <ul v-for=\"layersgroup in state.layersgroups\">\n          <layers-group :layersgroup=\"layersgroup\"></layers-group>\n        </ul>\n      </div>\n      <div class=\"tab-pane baselayers\" v-if=\"hasBaseLayers\" role=\"tabpanel\"  :class=\"{ active: activeTab === 'baselayers' || !hasLayers }\" id=\"baselayers\">\n        <ul id=\"baselayers-content\">\n          <li v-if=\"!baselayer.fixed\" v-for=\"baselayer in baselayers\" :key=\"baselayer.title\">\n            <img :src=\"getSrcBaseLayerImage(baselayer)\" @click.stop=\"setBaseLayer(baselayer.id)\" class=\"img-responsive img-thumbnail baselayer\" :style=\"{opacity: currentBaseLayer === baselayer.id ? 1 : 0.5}\" >\n            <div class=\"text-center\">{{ baselayer.title }}</div>\n          <li @click.stop=\"setBaseLayer(null)\">\n            <img :src=\"getSrcBaseLayerImage(null)\" class=\"img-responsive img-thumbnail baselayer\" :style=\"{opacity: currentBaseLayer === null ? 1 : 0.5}\">\n            <div class=\"text-center\" v-t=\"'nobaselayer'\"></div>\n          </li>\n        </ul>\n      </div>\n      <layerslegend @showlegend=\"showLegend\" :legend=\"legend\" :active=\"activeTab === 'legend'\" v-for=\"_layerstree in state.layerstrees\" :layerstree=\"_layerstree\" :key=\"_layerstree.id\"></layerslegend>\n    </div>\n  </div>\n  <ul id=\"layer-menu\" v-click-outside-layer-menu=\"closeLayerMenu\"  tabindex=\"-1\" v-if=\"layerMenu.show\"  :style=\"{top: layerMenu.top + 'px', left: layerMenu.left + 'px' }\">\n    <li v-if=\"canZoom(layerMenu.layer)\" @click.prevent.stop=\"zoomToLayer\">\n      <span :class=\"g3wtemplate.getFontClass('search')\"></span>\n      <span>{{ layerMenu.items.zoomtolayer }}</span>\n    </li>\n    <li v-if=\"layerMenu.layer.openattributetable\" @click.prevent.stop=\"showAttributeTable(layerMenu.layer.id)\">\n      <bar-loader :loading=\"layerMenu.loading.data_table\"></bar-loader>\n      <span :class=\"g3wtemplate.getFontClass('list')\"> </span>  {{ layerMenu.items.open_attribute_table }}\n      </i>\n    </li>\n    <li @click.prevent.stop=\"\" v-if=\"layerMenu.layer.external && !layerMenu.layer.source\" @mouseleave.self=\"showColorMenu(false,$event)\" @mouseover.self=\"showColorMenu(true,$event)\"> Setta/Cambia Colore <i :class=\"g3wtemplate.getFontClass('arrow-right')\" style=\"padding-left:10px;\" aria-hidden=\"true\"></i>\n      <ul v-if=\"layerMenu.colorMenu.show\" style=\"position:fixed\" :style=\"{ top: layerMenu.colorMenu.top + 'px', left: layerMenu.colorMenu.left +   'px' }\">\n        <li style=\"padding:0;\">\n          <chrome-picker\n            @click.prevent.stop=\"\"\n            v-model=\"layerMenu.colorMenu.color\"\n            @change-color=\"onChangeColor\"\n            style=\"width: 100%\">\n          </chrome-picker>\n        </li>\n      </ul>\n    </li>\n    <li v-if=\"canDownloadShp(layerMenu.layer.id)\">\n      <div @click.prevent.stop=\"downloadShp(layerMenu.layer.id)\" >\n        <bar-loader :loading=\"layerMenu.loading.shp\"></bar-loader>\n        <span  :class=\"g3wtemplate.getFontClass('download')\"></span>\n        <span>Download shapefile</span>\n      </div>\n      </i>\n    </li>\n    <li v-if=\"canShowWmsUrl(layerMenu.layer.id)\">\n      <div @click.prevent.stop=\"copyWmsUrl($event, layerMenu.layer.id)\" data-toggle=\"tooltip\" class=\"catalog-menu-wms skin-tooltip-top\" :title=\"copywmsurltooltip\" style=\"max-width:300px\">\n        <span :class=\"g3wtemplate.getFontClass('copy')\"></span>\n        <span>WMS URL</span>\n      </div>\n      </i>\n    </li>\n  </ul>\n</div>\n";

},{}],681:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var t = require('core/i18n/i18n.service').t;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var TableComponent = require('gui/table/vue/table');
var ComponentsRegistry = require('gui/componentsregistry');
var GUI = require('gui/gui');
var ControlsRegistry = require('gui/map/control/registry');
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var Service = require('../catalogservice');
var ChromeComponent = VueColor.Chrome;
var CatalogEventHub = new Vue();
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./catalog.html'));
var QGISVERSION = void 0;

var vueComponentOptions = (0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null,
      legend: this.$options.legend,
      showlegend: false,
      currentBaseLayer: null,
      copywmsurltooltip: t('sdk.catalog.menu.wms.copy'),
      // to show context menu right click
      layerMenu: {
        show: false,
        top: 0,
        left: 0,
        tooltip: false,
        name: '',
        layer: null,
        loading: {
          data_table: false,
          shp: false
        },
        items: {
          zoomtolayer: t("catalog_items.contextmenu.zoomtolayer"),
          open_attribute_table: t("catalog_items.contextmenu.open_attribute_table"),
          showmetadata: t("catalog_items.contextmenu.show_metadata")
        },
        //colorMenu
        colorMenu: {
          show: false,
          top: 0,
          left: 0,
          color: null
        }
      }
    };
  },

  directives: {
    //create a vue directive fro click outside contextmenu
    'click-outside-layer-menu': {
      bind: function bind(el, binding, vnode) {
        this.event = function (event) {
          if (!(el === event.target || el.contains(event.target))) {
            vnode.context[binding.expression](event);
          }
        };
        //add event listener click
        document.body.addEventListener('click', this.event);
      },
      unbind: function unbind(el) {
        document.body.removeEventListener('click', this.event);
      }
    }
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  computed: {
    project: function project() {
      return this.state.prstate.currentProject;
    },
    title: function title() {
      return this.project.state.name;
    },
    baselayers: function baselayers() {
      return this.project.state.baselayers;
    },
    hasBaseLayers: function hasBaseLayers() {
      return this.project.state.baselayers.length > 0;
    },
    hasLayers: function hasLayers() {
      var layerstresslength = 0;
      this.state.layerstrees.forEach(function (layerstree) {
        layerstresslength += layerstree.tree.length;
      });
      return this.state.externallayers.length > 0 || layerstresslength > 0 || this.state.layersgroups.length > 0;
    },
    activeTab: function activeTab() {
      return this.project.state.catalog_tab || 'layers';
    }
  },
  methods: {
    showLegend: function showLegend(bool) {
      this.showlegend = bool;
    },
    setBaseLayer: function setBaseLayer(id) {
      this.currentBaseLayer = id;
      this.project.setBaseLayer(id);
    },
    getSrcBaseLayerImage: function getSrcBaseLayerImage(baseLayer) {
      var type = baseLayer && baseLayer.servertype || baseLayer;
      var image = void 0;
      var customimage = false;
      switch (type) {
        case 'OSM':
          image = 'osm.png';
          break;
        case 'Bing':
          var subtype = baseLayer.source.subtype;
          image = 'bing' + subtype + '.png';
          break;
        case 'TMS':
        case 'WMTS':
          if (baseLayer.icon) {
            customimage = true;
            image = baseLayer.icon;
            break;
          }
        default:
          image = 'nobaselayer.png';
      }
      return !customimage ? GUI.getResourcesUrl() + 'images/' + image : image;
    },

    _hideMenu: function _hideMenu() {
      this.layerMenu.show = false;
    },
    zoomToLayer: function zoomToLayer() {
      var bbox = [this.layerMenu.layer.bbox.minx, this.layerMenu.layer.bbox.miny, this.layerMenu.layer.bbox.maxx, this.layerMenu.layer.bbox.maxy];
      var mapService = GUI.getComponent('map').getService();
      mapService.goToBBox(bbox);
      this._hideMenu();
    },
    canZoom: function canZoom(layer) {
      var canZoom = false;
      if (layer.bbox) {
        bbox = [layer.bbox.minx, layer.bbox.miny, layer.bbox.maxx, layer.bbox.maxy];
        canZoom = bbox.find(function (coordinate) {
          return coordinate > 0;
        });
      }
      return canZoom;
    },
    canShowWmsUrl: function canShowWmsUrl(layerId) {
      var originalLayer = CatalogLayersStoresRegistry.getLayerById(layerId);
      return originalLayer ? !!(!originalLayer.isType('table') && originalLayer.getFullWmsUrl()) : false;
    },
    canDownloadShp: function canDownloadShp(layerId) {
      var layer = CatalogLayersStoresRegistry.getLayerById(layerId);
      return layer ? layer.isShpDownlodable() : false;
    },
    copyWmsUrl: function copyWmsUrl(evt, layerId) {
      var originalLayer = CatalogLayersStoresRegistry.getLayerById(layerId);
      var url = originalLayer.getFullWmsUrl();
      var ancorEement = document.createElement('a');
      ancorEement.href = url;
      var tempInput = document.createElement('input');
      tempInput.value = ancorEement.href;
      document.body.appendChild(tempInput);
      tempInput.select();
      document.execCommand("copy");
      $(evt.target).attr('data-original-title', t('sdk.catalog.menu.wms.copied')).tooltip('show');
      $(evt.target).attr('title', this.copywmsurltooltip).tooltip('fixTitle');
      document.body.removeChild(tempInput);
      ancorEement = null;
    },
    downloadShp: function downloadShp(layerId) {
      var _this = this;

      this.layerMenu.loading.shp = true;
      var layer = CatalogLayersStoresRegistry.getLayerById(layerId);
      layer.getShp().catch(function (err) {
        GUI.notify.error(t("info.server_error"));
      }).finally(function () {
        _this.layerMenu.loading.shp = false;
        _this._hideMenu();
      });
    },

    showAttributeTable: function showAttributeTable(layerId) {
      var _this2 = this;

      this.layerMenu.loading.data_table = false;
      GUI.closeContent();
      var layer = CatalogLayersStoresRegistry.getLayerById(layerId);
      this.layerMenu.loading.data_table = true;
      var tableContent = new TableComponent({
        layer: layer
      });
      tableContent.on('show', function () {
        if (_this2.isMobile()) {
          GUI.hideSidebar();
        }
        _this2.layerMenu.loading.data_table = false;
        _this2._hideMenu();
      });
      tableContent.show({
        title: layer.getName()
      });
    },
    startEditing: function startEditing() {
      var _this3 = this;

      var layer = void 0;
      var catallogLayersStores = CatalogLayersStoresRegistry.getLayersStores();
      catallogLayersStores.forEach(function (layerStore) {
        layer = layerStore.getLayerById(_this3.layerMenu.layer.id);
        if (layer) {
          layer.getLayerForEditing();
          return false;
        }
      });
    },
    closeLayerMenu: function closeLayerMenu() {
      this._hideMenu();
      this.showColorMenu(false);
    },
    onChangeColor: function onChangeColor(val) {
      var mapService = GUI.getComponent('map').getService();
      this.layerMenu.colorMenu.color = val;
      var layer = mapService.getLayerByName(this.layerMenu.name);
      layer.setStyle(mapService.setExternalLayerStyle(val));
    },
    showColorMenu: function showColorMenu(bool, evt) {
      if (bool) {
        var elem = $(evt.target);
        this.layerMenu.colorMenu.top = elem.offset().top;
        this.layerMenu.colorMenu.left = elem.offset().left + elem.width() + (elem.outerWidth() - elem.width()) / 2;
      }
      this.layerMenu.colorMenu.show = bool;
    }
  },
  created: function created() {
    var _this4 = this;

    CatalogEventHub.$on('treenodetoogled', function (storeid, node, parent_mutually_exclusive) {
      var mapService = GUI.getComponent('map').getService();
      if (node.external && !node.source) {
        var layer = mapService.getLayerByName(node.name);
        layer.setVisible(!layer.getVisible());
        node.visible = !node.visible;
        node.checked = node.visible;
      } else if (!storeid) {
        node.visible = !node.visible;
        var _layer = mapService.getLayerById(node.id);
        _layer.setVisible(node.visible);
      } else {
        if (QGISVERSION === 2) {
          var _layer2 = CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id, null, parent_mutually_exclusive);
          mapService.emit('cataloglayertoggled', _layer2);
        } else {
          if (!node.groupdisabled) {
            var _layer3 = CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id, null, parent_mutually_exclusive);
            mapService.emit('cataloglayertoggled', _layer3);
          } else CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayer(node.id, false, parent_mutually_exclusive);
        }
      }
    });
    // event that set all visible or not all children layer of the folder and if parent is mutually exclusive turn off all layer
    CatalogEventHub.$on('treenodestoogled', function (storeid, nodes, isGroupChecked) {
      var layersIds = [];
      if (QGISVERSION === 2) {
        var checkNodes = function checkNodes(obj) {
          if (obj.nodes) {
            if (obj.mutually_exclusive) {
              if (obj.lastLayerIdVisible) layersIds.push(obj.lastLayerIdVisible);else {
                if (!isGroupChecked) {
                  layersIds = CatalogLayersStoresRegistry.getLayersStore(storeid)._getAllSiblingsChildrenLayersId(obj);
                } else {
                  var getLayerIds = function getLayerIds(nodes) {
                    nodes.some(function (node) {
                      if (node.id) {
                        if (node.geolayer) {
                          layersIds.push(node.id);
                          return true;
                        }
                      } else {
                        getLayerIds(node.nodes);
                      }
                    });
                  };
                  getLayerIds(obj.nodes);
                }
              }
            } else {
              obj.nodes.forEach(function (node) {
                checkNodes(node);
              });
            }
          } else {
            if (obj.geolayer) layersIds.push(obj.id);
          }
        };
        nodes.map(checkNodes);
        CatalogLayersStoresRegistry.getLayersStore(storeid).toggleLayers(layersIds, isGroupChecked).then(function (layers) {
          var mapService = GUI.getComponent('map').getService();
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = (0, _getIterator3.default)(layers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var layer = _step.value;

              mapService.emit('cataloglayertoggled', layer);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        });
      } else {
        var layerStore = CatalogLayersStoresRegistry.getLayersStore(storeid);
        var turnOnOffSubGroups = function turnOnOffSubGroups(parentChecked, currentLayersIds, node) {
          if (node.nodes) {
            node.disabled = !parentChecked;
            var _isGroupChecked = node.checked && parentChecked;
            var groupLayers = {
              checked: _isGroupChecked,
              layersIds: []
            };
            var _currentLayersIds = groupLayers.layersIds;
            _parentLayers.push(groupLayers);
            node.nodes.map(turnOnOffSubGroups.bind(null, _isGroupChecked, _currentLayersIds));
          } else if (node.geolayer) {
            if (node.checked) currentLayersIds.push(node.id);
            node.disabled = node.groupdisabled = !parentChecked;
          }
        };
        var _parentLayers = [{
          checked: isGroupChecked,
          layersIds: []
        }];
        var currentLayersIds = _parentLayers[0].layersIds;
        nodes.map(turnOnOffSubGroups.bind(null, isGroupChecked, currentLayersIds));
        for (var i = _parentLayers.length; i--;) {
          var _parentLayers$i = _parentLayers[i],
              _layersIds = _parentLayers$i.layersIds,
              checked = _parentLayers$i.checked;

          layerStore.toggleLayers(_layersIds, checked, QGISVERSION === 2);
        }
      }
    });

    CatalogEventHub.$on('treenodeselected', function (storeid, node) {
      var mapservice = GUI.getComponent('map').getService();
      var layer = CatalogLayersStoresRegistry.getLayersStore(storeid).getLayerById(node.id);
      if (!layer.isSelected()) {
        CatalogLayersStoresRegistry.getLayersStore(storeid).selectLayer(node.id);
        // emit signal of select layer from catalog
        mapservice.emit('cataloglayerselected', layer);
      } else {
        CatalogLayersStoresRegistry.getLayersStore(storeid).unselectLayer(node.id);
        mapservice.emit('cataloglayerunselected', layer);
      }
    });

    CatalogEventHub.$on('showmenulayer', function (layerstree, evt) {
      var layerId = layerstree.id;
      var constMenuHeight = function (layerId) {
        return (1 * _this4.canShowWmsUrl(layerId) + 1 * !!layerstree.bbox + 1 * !!layerstree.openattributetable + 1 * !!layerstree.color + 1 * _this4.canDownloadShp(layerId)) * 30;
      }(layerId);
      _this4.layerMenu.top = evt.y - constMenuHeight;
      _this4.layerMenu.left = evt.x;
      _this4.layerMenu.name = layerstree.name;
      _this4.layerMenu.layer = layerstree;
      _this4.layerMenu.show = true;
      _this4.layerMenu.colorMenu.color = layerstree.color;
      _this4.$nextTick(function () {
        $('.catalog-menu-wms[data-toggle="tooltip"]').tooltip();
      });
    });

    ControlsRegistry.onafter('registerControl', function (id, control) {
      if (id === 'querybbox') {
        control.getInteraction().on('propertychange', function (evt) {
          if (evt.key === 'active') {
            _this4.state.highlightlayers = !evt.oldValue;
          }
        });
      }
    });
  },
  beforeMount: function beforeMount() {
    this.currentBaseLayer = this.project.state.initbaselayer;
  }
});

var InternalComponent = Vue.extend(vueComponentOptions);

Vue.component('g3w-catalog', vueComponentOptions);

Vue.component('layers-group', {
  template: require('./layersgroup.html'),
  props: {
    layersgroup: {
      type: Object
    }
  }
});

var compiledTristateTreeTemplate = (0, _utils.createCompiledTemplate)(require('./tristate-tree.html'));
/* CHILDREN COMPONENTS */
// tree component
Vue.component('tristate-tree', (0, _extends3.default)({}, compiledTristateTreeTemplate, {
  props: ['layerstree', 'storeid', 'highlightlayers', 'parent_mutually_exclusive', 'parentFolder', 'externallayers', 'root', "parent"],
  data: function data() {
    return {
      expanded: this.layerstree.expanded,
      isFolderChecked: true,
      controltoggled: false,
      n_childs: null,
      ishighligtable: false
    };
  },
  computed: {
    isFolder: function isFolder() {
      var _visibleChilds = 0;
      var _childsLength = 0;
      var isFolder = !!this.layerstree.nodes;
      if (isFolder) {
        if (QGISVERSION === 2) {
          // function that count number of layers of each folder and visible layers
          var countLayersVisible = function countLayersVisible(layerstree) {
            //if mutually exclusive count 1
            if (layerstree.mutually_exclusive) {
              _childsLength += 1;
              layerstree.nodes.forEach(function (layer) {
                if (!layer.nodes) {
                  if (layer.checked) {
                    layerstree.lastLayerIdVisible = layer.id;
                    _visibleChilds += 1;
                  }
                } else {
                  var countMEVisibleLayers = function countMEVisibleLayers(nodes) {
                    var vME = nodes.reduce(function (previous, node) {
                      if (node.id) return node.checked || previous;else return countMEVisibleLayers(node.nodes) || previous;
                    }, false);
                    return vME;
                  };
                  _visibleChilds += countMEVisibleLayers(layer.nodes);
                }
              });
            } else {
              // not mutually exclusive
              layerstree.nodes.forEach(function (layer) {
                if (!layer.nodes && layer.geolayer) {
                  _childsLength += 1;
                  if (layer.checked) {
                    _visibleChilds += 1;
                  }
                } else if (layer.nodes) {
                  countLayersVisible(layer);
                }
              });
            }
          };
          countLayersVisible(this.layerstree);
          this.n_childs = _childsLength;
          this.n_visibleChilds = _visibleChilds;
          //set folder is checked based on the behaviour of the child
          this.isFolderChecked = !(this.n_childs - this.n_visibleChilds);
        }
      }
      return isFolder;
    },
    isTable: function isTable() {
      if (!this.isFolder) {
        return !this.layerstree.geolayer && !this.layerstree.external;
      }
    },
    isHidden: function isHidden() {
      return this.layerstree.hidden && this.layerstree.hidden === true;
    },
    selected: function selected() {
      this.layerstree.selected = this.layerstree.disabled && this.layerstree.selected ? false : this.layerstree.selected;
    },
    isHighLight: function isHighLight() {
      return this.highlightlayers && !this.isFolder && this.ishighligtable && this.layerstree.visible;
    },
    isDisabled: function isDisabled() {
      return QGISVERSION === 3 && !this.isFolder && !this.isTable && !this.layerstree.checked || this.layerstree.disabled || this.layerstree.groupdisabled;
    }
  },
  watch: {
    'layerstree.disabled': function layerstreeDisabled(bool) {
      this.layerstree.selected = bool && this.layerstree.selected ? false : this.layerstree.selected;
    }
  },
  methods: {
    toggle: function toggle(isFolder) {
      var _this5 = this;

      if (isFolder) {
        if (QGISVERSION === 2) {
          if (this.layerstree.mutually_exclusive && this.layerstree.nodes.length) {
            if (!this.layerstree.lastLayerIdVisible) {
              var layerId = void 0;
              var getLayerId = function getLayerId(nodes) {
                nodes.some(function (node) {
                  if (node.id) if (node.geolayer) {
                    layerId = node.id;
                    return true;
                  } else {
                    getLayerId(node.nodes);
                  }
                });
              };
              getLayerId(this.layerstree.nodes);
              this.layerstree.lastLayerIdVisible = layerId;
            }
            if (!this.isFolderChecked) {
              CatalogEventHub.$emit('treenodetoogled', this.storeid, {
                id: this.layerstree.lastLayerIdVisible //id of visible layers
              }, this.layerstree.mutually_exclusive);
            } else {
              CatalogEventHub.$emit('treenodestoogled', this.storeid, this.layerstree.nodes, false, this.parent_mutually_exclusive);
            }
            this.isFolderChecked = !this.isFolderChecked;
          } else {
            if (this.isFolderChecked && !this.n_visibleChilds) {
              this.isFolderChecked = true;
            } else if (this.isFolderChecked && this.n_visibleChilds) {
              this.isFolderChecked = false;
            } else {
              this.isFolderChecked = !this.isFolderChecked;
            }
            CatalogEventHub.$emit('treenodestoogled', this.storeid, this.layerstree.nodes, this.isFolderChecked, this.parent_mutually_exclusive);
          }
          if (this.isFolderChecked && this.parent_mutually_exclusive) {
            this.parent.nodes.forEach(function (node) {
              var nodes = [];
              if (node.title !== _this5.layerstree.title) nodes.push(node);
              CatalogEventHub.$emit('treenodestoogled', _this5.storeid, nodes, false, _this5.parent_mutually_exclusive);
            });
          }
        } else {
          this.layerstree.checked = !this.layerstree.checked;
          this.isFolderChecked = this.layerstree.checked && !this.layerstree.disabled;
          CatalogEventHub.$emit('treenodestoogled', this.storeid, this.layerstree.nodes, this.isFolderChecked, this.parent_mutually_exclusive);
        }
      } else {
        if (QGISVERSION === 2) CatalogEventHub.$emit('treenodetoogled', this.storeid, this.layerstree, this.parent_mutually_exclusive);else CatalogEventHub.$emit('treenodetoogled', this.storeid, this.layerstree, this.parent_mutually_exclusive);
      }
    },
    expandCollapse: function expandCollapse() {
      this.layerstree.expanded = !this.layerstree.expanded;
    },
    select: function select() {
      if (!this.isFolder && !this.layerstree.external && !this.isTable) {
        CatalogEventHub.$emit('treenodeselected', this.storeid, this.layerstree);
      }
    },
    triClass: function triClass() {
      if (QGISVERSION === 2) {
        if (this.n_visibleChilds === this.n_childs) {
          //checked
          return this.g3wtemplate.getFontClass('check');
        } else if (this.n_visibleChilds > 0 && this.n_visibleChilds < this.n_childs) {
          if (this.layerstree.mutually_exclusive) {
            //checked
            return this.g3wtemplate.getFontClass('uncheck');
          }
          // white square
          return this.g3wtemplate.getFontClass('filluncheck');
        } else {
          //unchecked
          return this.g3wtemplate.getFontClass('uncheck');
        }
      } else {
        return this.layerstree.checked ? this.g3wtemplate.getFontClass('check') : this.g3wtemplate.getFontClass('uncheck');
      }
    },
    removeExternalLayer: function removeExternalLayer(name) {
      var mapService = GUI.getComponent('map').getService();
      mapService.removeExternalLayer(name);
    },
    showLayerMenu: function showLayerMenu(layerstree, evt) {
      if (!this.isFolder && (this.layerstree.openattributetable || this.layerstree.geolayer || this.layerstree.external)) {
        CatalogEventHub.$emit('showmenulayer', layerstree, evt);
      }
    }
  },
  created: function created() {
    if (!this.isFolder) {
      var layer = CatalogLayersStoresRegistry.getLayerById(this.layerstree.id);
      this.ishighligtable = layer && layer.isFilterable();
    } else {
      if (QGISVERSION === 3 && !this.layerstree.checked) CatalogEventHub.$emit('treenodestoogled', this.storeid, this.layerstree.nodes, this.layerstree.checked, this.parent_mutually_exclusive);
    }
  },

  mounted: function mounted() {
    var _this6 = this;

    if (this.isFolder && !this.root) {
      this.layerstree.nodes.forEach(function (node) {
        if (_this6.parent_mutually_exclusive && !_this6.layerstree.mutually_exclusive) if (node.id) node.uncheckable = true;
      });
    }
  }
}));

var compiletLegendTemplate = (0, _utils.createCompiledTemplate)(require('./legend.html'));

Vue.component('layerslegend', (0, _extends3.default)({}, compiletLegendTemplate, {
  props: ['layerstree', 'legend', 'active'],
  data: function data() {
    return {};
  },
  computed: {
    visiblelayers: function visiblelayers() {
      var _visiblelayers = [];
      var layerstree = this.layerstree.tree;
      var traverse = function traverse(obj) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = (0, _getIterator3.default)(obj), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var layer = _step2.value;

            if (!_.isNil(layer.id) && layer.visible && !layer.exclude_from_legend) {
              _visiblelayers.push(layer);
            }
            if (!_.isNil(layer.nodes)) {
              traverse(layer.nodes);
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      };
      traverse(layerstree);
      return _visiblelayers;
    }
  },
  watch: {
    'layerstree': {
      handler: function handler(val, old) {},
      deep: true
    },
    'visiblelayers': function visiblelayers(visibleLayers) {
      var show = !!visibleLayers.length;
      this.$emit('showlegend', show);
    }
  },
  created: function created() {
    this.$emit('showlegend', !!this.visiblelayers.length);
  }
}));

var compiledLegendItemsTemplate = (0, _utils.createCompiledTemplate)(require('./legend_items.html'));

Vue.component('layerslegend-items', (0, _extends3.default)({}, compiledLegendItemsTemplate, {
  props: ['layers', 'legend'],
  data: function data() {
    return {
      legendurls: []
    };
  },

  watch: {
    layers: function layers(_layers2) {
      this.getLegendSrc(_layers2);
    }
  },
  methods: {
    setError: function setError(legendurl) {
      legendurl.error = true;
      legendurl.loading = false;
    },
    urlLoaded: function urlLoaded(legendurl) {
      legendurl.loading = false;
    },

    getLegendUrl: function getLegendUrl(layer) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var legendurl = void 0;
      var catalogLayers = CatalogLayersStoresRegistry.getLayersStores();
      catalogLayers.forEach(function (layerStore) {
        if (layerStore.getLayerById(layer.id)) {
          legendurl = layerStore.getLayerById(layer.id).getLegendUrl(params);
          return false;
        }
      });
      return legendurl;
    },
    getLegendSrc: function getLegendSrc(_layers) {
      var urlMethodsLayersName = {
        GET: {},
        POST: {}
      };
      var self = this;
      this.legendurls = [];
      var layers = _layers.reverse();
      for (var i = 0; i < layers.length; i++) {
        var layer = layers[i];
        var urlLayersName = layer.source && layer.source.url || layer.external ? urlMethodsLayersName.GET : urlMethodsLayersName[layer.ows_method];
        var url = this.getLegendUrl(layer, this.legend);
        if (layer.source && layer.source.url) urlLayersName[url] = [];else {
          var _url$split = url.split('LAYER='),
              _url$split2 = (0, _slicedToArray3.default)(_url$split, 2),
              prefix = _url$split2[0],
              layerName = _url$split2[1];

          if (!urlLayersName[prefix]) urlLayersName[prefix] = [];
          urlLayersName[prefix].push(layerName);
        }
      }
      for (var method in urlMethodsLayersName) {
        var _urlLayersName = urlMethodsLayersName[method];
        if (method === 'GET') for (var _url2 in _urlLayersName) {
          var legendUrl = _urlLayersName[_url2].length ? _url2 + '&LAYER=' + _urlLayersName[_url2].join(',') : _url2;
          this.legendurls.push({
            loading: true,
            url: legendUrl,
            error: false
          });
        } else {
          var _loop = function _loop(_url3) {
            var xhr = new XMLHttpRequest();

            var _url3$split = _url3.split('?'),
                _url3$split2 = (0, _slicedToArray3.default)(_url3$split, 2),
                _url = _url3$split2[0],
                params = _url3$split2[1];

            params = params.split('&');
            var econdedParams = [];
            params.forEach(function (param) {
              var _param$split = param.split('='),
                  _param$split2 = (0, _slicedToArray3.default)(_param$split, 2),
                  key = _param$split2[0],
                  value = _param$split2[1];

              econdedParams.push(key + '=' + encodeURIComponent(value));
            });
            params = econdedParams.join('&');
            params = params + '&LAYERS=' + encodeURIComponent(_urlLayersName[_url3].join(','));
            xhr.open('POST', _url);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');
            xhr.responseType = 'blob';
            var legendUrlObject = {
              loading: true,
              url: null,
              error: false
            };
            self.legendurls.push(legendUrlObject);
            xhr.onload = function () {
              var data = this.response;
              if (data !== undefined) legendUrlObject.url = window.URL.createObjectURL(data);
              legendUrlObject.loading = false;
            };
            xhr.onerror = function () {
              legendUrlObject.loading = false;
            };
            xhr.send(params);
          };

          for (var _url3 in _urlLayersName) {
            _loop(_url3);
          }
        }
      }
    }
  },
  created: function created() {
    this.getLegendSrc(this.layers);
  }
}));

function CatalogComponent() {
  var _this7 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.resizable = true;
  base(this, options);
  var legend = options.config.legend;

  this.title = "catalog";
  this.mapComponentId = options.mapcomponentid;
  var service = options.service || new Service();
  this.setService(service);
  this.setInternalComponent(new InternalComponent({
    service: service,
    legend: legend
  }));
  this.internalComponent.state = this.getService().state;
  QGISVERSION = service.getMajorQgisVersion();
  var listenToMapVisibility = function listenToMapVisibility(map) {
    var mapService = map.getService();
    _this7.state.visible = !mapService.state.hidden;
    mapService.onafter('setHidden', function (hidden) {
      _this7.state.visible = !mapService.state.hidden;
      _this7.state.expanded = true;
    });
  };
  if (this.mapComponentId) {
    var map = GUI.getComponent(this.mapComponentId);
    !map && ComponentsRegistry.on('componentregistered', function (component) {
      if (component.getId() === _this7.mapComponentId) {
        listenToMapVisibility(component);
      }
    }) || listenToMapVisibility(map);
  }
}

inherit(CatalogComponent, Component);

module.exports = CatalogComponent;

},{"../catalogservice":679,"./catalog.html":680,"./layersgroup.html":682,"./legend.html":683,"./legend_items.html":684,"./tristate-tree.html":685,"babel-runtime/core-js/get-iterator":4,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"core/catalog/cataloglayersstoresregistry":561,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/componentsregistry":691,"gui/gui":710,"gui/map/control/registry":754,"gui/table/vue/table":798,"gui/vue/component":806,"gui/vue/utils":812}],682:[function(require,module,exports){
module.exports = "<div style=\"border: 1px solid #ffffff33; margin: 5px\">\n  <h4 style=\"margin: 5px; font-weight: bold\">{{ layersgroup.title }}</h4>\n  <tristate-tree  :layerstree=\"node\" v-for=\"node in layersgroup.nodes\" class=\"item\">\n  </tristate-tree>\n</div>\n";

},{}],683:[function(require,module,exports){
module.exports = "<div role=\"tabpanel\" class=\"tab-pane\" :class=\"{active:active}\" id=\"legend\">\n  <layerslegend-items :legend=\"legend\" :layers=\"visiblelayers\"></layerslegend-items>\n</div>\n";

},{}],684:[function(require,module,exports){
module.exports = "<div class=\"legend-item\">\n  <figure v-for=\"legendurl in legendurls\" :key=\"legendurl.url\">\n    <bar-loader :loading=\"legendurl.loading\"></bar-loader>\n    <img v-show=\"!legendurl.loading && !legendurl.error\" :src=\"legendurl.url\" @error=\"setError(legendurl)\" @load=\"urlLoaded(legendurl)\">\n    <span class=\"divider\"></span>\n  </figure>\n</div>\n";

},{}],685:[function(require,module,exports){
module.exports = "<li\n  class=\"tree-item\"\n  @contextmenu.prevent.stop=\"showLayerMenu(layerstree, $event)\"\n  @click=\"select()\"\n  :class=\"{selected: !isFolder || !isTable ? layerstree.selected : false, itemmarginbottom: !isFolder,  disabled: isDisabled}\">\n  <span v-if=\"isFolder\"\n    :class=\"[{bold : isFolder}, layerstree.expanded ? g3wtemplate.getFontClass('arrow-down') : g3wtemplate.getFontClass('arrow-right')]\"\n    @click=\"expandCollapse\"\n    class=\"root\">\n  </span>\n  <span v-if=\"isFolder\"\n    @click.stop=\"toggle(true)\"\n    style=\"color: #ffffff\"\n    :class=\"[triClass()]\">\n  </span>\n  <span v-else-if=\"isTable\"\n        v-show=\"!layerstree.hidden\"\n        :class=\"[parentFolder ? 'child' : 'root', g3wtemplate.getFontClass('table')]\">\n  </span>\n  <template v-else>\n    <span style=\"color: red\" v-if=\"layerstree.external && layerstree.removable\"\n          :class=\"g3wtemplate.getFontClass('trash')\"\n          @click=\"removeExternalLayer(layerstree.name)\">\n    </span>\n    <span v-show=\"!layerstree.hidden\"\n      @click.stop=\"toggle(false)\"\n      :class=\"[layerstree.checked  ? g3wtemplate.getFontClass('check'): g3wtemplate.getFontClass('uncheck'),  parentFolder ? 'child' : 'root' ]\"\n      class=\"checkbox-layer\"></span>\n  </template>\n\n  <span v-show=\"!layerstree.hidden || isFolder\"\n    class=\"tree-node-title\"\n    :class=\"{'disabled': layerstree.disabled, 'bold': isFolder, 'highlightlayer': isHighLight }\"> {{ layerstree.title }}\n  </span>\n\n  <ul v-if=\"isFolder\" v-show=\"layerstree.expanded\">\n    <tristate-tree\n      :root=\"false\"\n      :highlightlayers=\"highlightlayers\"\n      :parentFolder=\"isFolder\"\n      :layerstree=\"_layerstree\"\n      :storeid=\"storeid\"\n      :parent=\"layerstree\"\n      :parent_mutually_exclusive=\"!!layerstree.mutually_exclusive\"\n      v-for=\"_layerstree in layerstree.nodes\" :key=\"layerstree.id\">\n    </tristate-tree>\n  </ul>\n</li>\n";

},{}],686:[function(require,module,exports){
var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Chartsfactory = {
  CHARTS: {
    c3: {
      lineXY: require('./vue/c3/line/lineXY')
    }
  },
  /*
  * type: <library(es:c3)>:<chartType:(es.lineXY)>
  * */
  build: function build() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        type = _ref.type,
        _ref$hooks = _ref.hooks,
        hooks = _ref$hooks === undefined ? {} : _ref$hooks;

    var _type$split = type.split(':'),
        _type$split2 = (0, _slicedToArray3.default)(_type$split, 2),
        _type$split2$ = _type$split2[0],
        library = _type$split2$ === undefined ? 'c3' : _type$split2$,
        _type$split2$2 = _type$split2[1],
        chartType = _type$split2$2 === undefined ? 'lineXY' : _type$split2$2;

    var chartVue = this.CHARTS[library][chartType];
    return (0, _assign2.default)(hooks, chartVue);
  }
};

module.exports = Chartsfactory;

},{"./vue/c3/line/lineXY":688,"babel-runtime/core-js/object/assign":10,"babel-runtime/helpers/slicedToArray":23}],687:[function(require,module,exports){
module.exports = "<div class=\"chart_wrapper\">\n  <div style=\"height: 40%; min-height: 200px;  background-color: #ffffff\" :id=\"id\"></div>\n  <div v-for=\"component in components\">\n    <span class=\"divider\"></span>\n    <component\n      @change-item=\"changeItem\"\n      @change-items=\"changeItems\"\n      @select-item=\"selectItem\"\n      @select-all=\"selectAll\"\n      @unselect-all=\"unselectAll\"\n      @unselect-item=\"unselectItem\"\n      :data=\"data\"\n      :selectitems=\"selectitems\"\n      :size=\"size\"\n      :is=\"component\">\n    </component>\n  </div>\n</div>\n";

},{}],688:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id = require('core/utils/utils').getUniqueDomId();
var C3XYLine = {
  template: require('./lineXY.html'),
  props: {
    showdata: {
      type: Boolean,
      default: true
    }

  },
  data: function data() {
    return {
      id: 'graphline' + id,
      selectitems: [],
      data: [],
      components: [],
      config: {
        data: {
          columns: [['x'], ['y']]
        }
      },
      size: {
        width: 0,
        height: 0
      }
    };
  },

  methods: {
    addComponent: function addComponent(component) {
      this.components.push(component);
    },
    addComponents: function addComponents() {
      var _this = this;

      var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      components.forEach(function (component) {
        _this.addComponent(component);
      });
    },
    setConfig: function setConfig() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.config = config;
    },
    setDataOffset: function setDataOffset(offset) {
      var render = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      var data = this.getData();
      for (var i = 0; i < data.length; i++) {
        var item = data[i];
        item.value += offset;
      }
      if (render) {
        this.resize();
      }
    },
    getSelectedItems: function getSelectedItems() {
      return this.selectitems;
    },
    selectItem: function selectItem(id) {
      this.chart.select(['y'], [id]);
    },
    unselectItem: function unselectItem(id) {
      this.chart.unselect(['y'], [id]);
    },
    selectItems: function selectItems() {
      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this.chart.select([y], ids);
    },
    unselectItems: function unselectItems() {
      var ids = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      this.chart.unselect(['y'], ids);
    },
    unselectAll: function unselectAll() {
      this.chart.unselect();
    },
    selectAll: function selectAll() {
      this.chart.select();
    },
    getData: function getData() {
      return this.data;
    },
    resize: function resize() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          width = _ref.width,
          height = _ref.height;

      this.chart.resize({
        width: width,
        height: height || $('#' + this.id).height() - 4
      });
    },
    _setAllowedSpace: function _setAllowedSpace() {
      if (this.components && this.components.length) this.size.height = document.querySelector('.g3wform_content').offsetHeight - this.$el.offsetHeight - document.querySelector('.g3wform_header').offsetHeight - 50;
    },
    _setMaxMin: function _setMaxMin(_ref2) {
      var value = _ref2.value,
          max = _ref2.max,
          min = _ref2.min;

      min = value ? +value : +min;
      max = value ? +value : +max;
      if (min < this.chart.axis.min().y) this.chart.axis.min(min);else if (max > this.chart.axis.max().y) this.chart.axis.max(max);else {
        var dataValues = this.data.map(function (data) {
          return +data.value;
        });
        this.chart.axis.max(Math.max.apply(Math, (0, _toConsumableArray3.default)(dataValues)));
        this.chart.axis.min(Math.min.apply(Math, (0, _toConsumableArray3.default)(dataValues)));
      }
      this.resize();
    },
    changeItems: function changeItems(items) {
      if (items.length === 1) this._setMaxMin(items[0].value);else {
        var max = Math.max.apply(Math, (0, _toConsumableArray3.default)(items.map(function (item) {
          return +item.value;
        })));
        var min = Math.min.apply(Math, (0, _toConsumableArray3.default)(items.map(function (item) {
          return +item.value;
        })));
        this._setMaxMin({
          max: max,
          min: min
        });
      }
      this.resize();
    },
    changeItem: function changeItem(_ref3) {
      var item = _ref3.item,
          _ref3$render = _ref3.render,
          render = _ref3$render === undefined ? true : _ref3$render;

      var value = item.value;
      this._setMaxMin({ value: value });
      if (render) {
        this.resize();
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      var self = _this2;
      _this2.config.data.onselected = function (evt) {
        var _temp = [].concat((0, _toConsumableArray3.default)(self.selectitems), [evt]);
        self.selectitems = _temp;
      };
      _this2.config.data.onunselected = function (evt) {
        self.selectitems = self.selectitems.filter(function (selectitem) {
          return selectitem.index !== evt.index;
        });
      };
      _this2.chart = c3.generate((0, _extends3.default)({
        bindto: '#' + _this2.id
      }, _this2.config));
      var data = _this2.chart.data()[0] ? _this2.chart.data()[0].values : [];
      data.forEach(function (item) {
        _this2.data.push(item);
      });
      _this2._setAllowedSpace();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.data = this.selectitems = null;
    this.chart.destroy();
    this.chart = null;
  }
};

module.exports = C3XYLine;

},{"./lineXY.html":687,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/toConsumableArray":24,"core/utils/utils":630}],689:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _require = require('core/utils/utils'),
    inherit = _require.inherit,
    merge = _require.merge,
    noop = _require.noop,
    base = _require.base,
    capitalize_first_letter = _require.capitalize_first_letter;

var G3WObject = require('core/g3wobject');
var VUECOMPONENTSATTRIBUTES = ['methods', 'computed', 'data', 'components'];

// Class Component (Base)
var Component = function Component() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // internal VUE component
  this.internalComponent = null;
  this._components = [];
  this.id = options.id || Math.random() * 1000;
  this.title = options.title || '';
  this.state = {
    visible: options.visible || true, // visibile
    open: options.open || false, // open,
    resizable: options.resizable || false,
    info: options.info || null,
    sizes: {
      width: 0,
      height: 0
    }
  };
  //setters
  this.setters = {
    setOpen: function setOpen(bool) {
      this.state.open = bool;
      this._setOpen(bool);
    },
    setVisible: function setVisible(bool) {
      this.state.visible = bool;
      this._setVisible(bool);
    },
    reload: function reload() {
      this._reload();
    }
  };

  this.init = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this.vueComponent = this.createVueComponent(options.vueComponentObject);
    this._components = options.components || [];
    var service = options.service || noop;
    var template = options.template;

    this.setService(service);
    this._service.init ? this._service.init(options) : null;
    template && this.setInternalComponentTemplate(template);
    this.setInternalComponent = function () {
      var InternalComponent = Vue.extend(this.vueComponent);
      this.internalComponent = new InternalComponent({
        service: this._service,
        template: template
      });
      this.internalComponent.state = this.getService().state;
    };
    this.setInternalComponent();
  };
  merge(this, options);
  base(this);
};

inherit(Component, G3WObject);

var proto = Component.prototype;

proto.getId = function () {
  return this.id;
};

proto.setId = function (id) {
  this.id = id;
};

proto.getOpen = function () {
  return this.state.open;
};

proto.getVisible = function () {
  return this.state.visible;
};

proto.getTitle = function () {
  return this.state.title;
};

proto.setTitle = function (title) {
  this.state.title = title;
};

proto.getService = function () {
  return this._service;
};

proto.setService = function (service) {
  this._service = service;
};

proto.insertComponentAt = function (index, Component) {
  this._components.splice(index, 0, Component);
};

proto.destroy = function () {
  //TODO
};

proto.removeCompomentAt = function (index) {
  this._components.splice(index, 1);
};

proto.addComponent = function (Component) {
  this._components.push(Component);
};

proto.popComponent = function () {
  return this._components.pop();
};

proto.removeComponent = function (Component) {
  var _this = this;

  this._components.forEach(function (component, index) {
    if (component === Component) {
      _this.splice(index, 1);
      return false;
    }
  });
};

proto.setComponents = function (components) {
  this._components = Array.isArray(components) ? components : [];
};

proto.exendComponents = function (components) {
  _.merge(this._components, components);
};

proto.getInternalComponent = function () {
  return this.internalComponent;
};

proto.setInternalComponent = function (internalComponent) {
  var _this2 = this;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!internalComponent && this.internalComponentClass) this.internalComponent = new this.internalComponentClass();else this.internalComponent = internalComponent;
  var _options$events = options.events,
      events = _options$events === undefined ? [] : _options$events;

  events.forEach(function (event) {
    var name = event.name,
        handler = event.handler;

    _this2.internalComponent.$on(name, function (data) {
      handler && handler(data) || _this2['set' + capitalize_first_letter(name)](data);
    });
  });
};

proto.createVueComponent = function (vueObjOptions) {
  return _.cloneDeep(vueObjOptions);
};

proto.addInternalComponentData = function (data) {
  _.merge(this.internalComponent, data);
};

proto.overwriteServiceMethod = function (methodName, method) {
  this._service[methodName] = method;
};

proto.overwriteServiceMethods = function (methodsOptions) {
  var _this3 = this;

  (0, _entries2.default)(methodsOptions).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        methodName = _ref2[0],
        method = _ref2[1];

    _this3.overwriteServiceMethod(methodName, method);
  });
};

proto.extendService = function (serviceOptions) {
  if (this._service) {
    merge(this._service, serviceOptions);
  }
};

proto.extendInternalComponent = function (internalComponentOptions) {
  var _this4 = this;

  if (this.vueComponent) {
    (0, _entries2.default)(internalComponentOptions).forEach(function (_ref3) {
      var _ref4 = (0, _slicedToArray3.default)(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];

      if (VUECOMPONENTSATTRIBUTES.indexOf(key) > -1) {
        switch (key) {
          case 'methods':
            _this4.extendInternalComponentMethods(value);
            break;
          case 'components':
            _this4.extendInternalComponentComponents(value);
            break;
          default:
            merge(_this4.vueComponent[key], value);
        }
      }
    });
  } else {
    this.vueComponent = internalComponentOptions;
  }
};

proto.extendInternalComponentComponents = function (components) {
  if (components) {
    merge(this.vueComponent.components, components);
  }
};

proto.extendComponents = function (components) {
  this.extendInternalComponentComponents(components);
};

proto.addComponent = function (component) {
  if (component) {
    this.vueComponent.components[component.key] = component.value;
  }
};

proto.extendInternalComponentMethods = function (methods) {
  if (methods) {
    _.forEach(methods, function (value, key) {
      if (!(value instanceof Function)) {
        delete methods[key];
      }
    });
    merge(this.vueComponent.methods, methods);
  }
};

proto.extendInternalComponentComputed = function (computed) {
  if (computed) {
    _.forEach(computed, function (value, key) {
      if (!(value instanceof Function)) {
        delete computed[key];
      }
    });
    merge(this.vueComponent.computed, computed);
  }
};

proto.setInternalComponentTemplate = function (template) {
  if (template) {
    this.vueComponent.template = template;
  }
};

proto.getInternalTemplate = function () {
  return this.vueComponent.template;
};

// hook function to show componet
proto.show = function () {};

proto._setOpen = function (bool) {};

proto._setVisible = function () {};

proto._reload = function () {};

module.exports = Component;

},{"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/utils/utils":630}],690:[function(require,module,exports){
var Component = require('./vue/component');
var ComponentsFactory = {
  build: function build(_ref) {
    var vueComponentObject = _ref.vueComponentObject,
        service = _ref.service;
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var component = new Component(options);
    component.init({
      vueComponentObject: vueComponentObject,
      service: service
    });
    return component;
  }
};

module.exports = ComponentsFactory;

},{"./vue/component":806}],691:[function(require,module,exports){
var G3WObject = require('core/g3wobject');
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;

//class Componet Registry (singleton)
// store all components added
function ComponentsRegistry() {
  this.components = {};
  this.registerComponent = function (component) {
    var id = component.getId();
    if (!this.components[id]) {
      this.components[id] = component;
      this.emit('componentregistered', component);
    }
  };

  this.getComponent = function (id) {
    return this.components[id];
  };

  this.getComponents = function () {
    return this.components;
  };

  this.unregisterComponent = function (id) {
    var component = this.components[id];
    if (component) {
      if (typeof component.destroy === 'function') {
        component.destroy();
      }
      this.components[id] = null;
    }
  };
  base(this);
}
inherit(ComponentsRegistry, G3WObject);

module.exports = new ComponentsRegistry();

},{"core/g3wobject":569,"core/utils/utils":630}],692:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".field[data-v-109e12a6] {\n  background-color: transparent !important;\n  padding-top: 5px;\n  padding-bottom: 5px;\n  display: flex;\n  align-items: center;\n}\n.value[data-v-109e12a6] {\n  position: relative;\n}\n.field div[data-v-109e12a6] {\n  padding-left: 5px;\n  padding-right: 5px;\n}\n\n.field_value[data-v-109e12a6] {\n  padding-left: 0 !important;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "field",
  props: ['state']
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"field"},[(_vm.state.label)?_c('div',{staticClass:"col-sm-6  field_label"},[_vm._t("label",[_vm._v(_vm._s(_vm.state.label))])],2):_vm._e(),_vm._v(" "),_c('div',{staticClass:"field_value",class:[_vm.state.label ? 'col-sm-6' : null ]},[_vm._t("field",[_c('span',{staticStyle:{"word-wrap":"break-word"}},[_vm._v(_vm._s(_vm.state.value))])])],2)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-109e12a6"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-109e12a6", __vue__options__)
  } else {
    hotAPI.reload("data-v-109e12a6", __vue__options__)
  }
})()}

},{"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],693:[function(require,module,exports){
var _text = require('./text.vue');

var _text2 = _interopRequireDefault(_text);

var _link = require('./link.vue');

var _link2 = _interopRequireDefault(_link);

var _image = require('./image.vue');

var _image2 = _interopRequireDefault(_image);

var _geo = require('./geo.vue');

var _geo2 = _interopRequireDefault(_geo);

var _media = require('./media.vue');

var _media2 = _interopRequireDefault(_media);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Fields = {
  simple_field: _text2.default,
  text_field: _text2.default,
  link_field: _link2.default,
  image_field: _image2.default,
  geo_field: _geo2.default,
  photo_field: _image2.default,
  media_field: _media2.default
};

module.exports = Fields;

},{"./geo.vue":696,"./image.vue":697,"./link.vue":698,"./media.vue":699,"./text.vue":700}],694:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var FieldType = {
  SIMPLE: 'simple',
  GEO: 'geo',
  LINK: 'link',
  PHOTO: 'photo',
  PHOTOLINK: "photolink",
  IMAGE: 'image',
  POINTLINK: 'pointlink',
  ROUTE: 'route'
};
var URLPattern = /^(https?:\/\/[^\s]+)/g;
var PhotoPattern = /[^\s]+.(png|jpg|jpeg|gif)$/g;

var Fields = require('./fields');
exports.default = {
  name: "g3w-field",
  props: {
    state: {
      required: true
    }
  },
  components: (0, _extends3.default)({}, Fields),
  computed: {
    type: function type() {
      var value = this.state.value && (0, _typeof3.default)(this.state.value) === 'object' && !this.state.value.coordinates ? this.state.value.value : this.state.value;
      var type = void 0;
      if (!value) {
        type = FieldType.SIMPLE;
      } else if (value && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) == 'object' && value.coordinates) {
        type = FieldType.GEO;
      } else if (value && Array.isArray(value)) {
        if (value.length && value[0].photo) type = FieldType.PHOTO;else type = FieldType.SIMPLE;
      } else if (value.toString().toLowerCase().match(PhotoPattern)) {
        type = FieldType.PHOTO;
      } else if (value.toString().match(URLPattern)) {
        type = FieldType.LINK;
      } else {
        type = FieldType.SIMPLE;
      }
      return type + '_field';
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c(_vm.type,{tag:"component",attrs:{"state":_vm.state}})}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-63a8fb2b"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-63a8fb2b", __vue__options__)
  } else {
    hotAPI.reload("data-v-63a8fb2b", __vue__options__)
  }
})()}

},{"./fields":693,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513}],695:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".modal-content[data-v-78c04645] {\n  background: rgba(255, 255, 255, 0.6);\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n.modal-dialog[data-v-78c04645] {\n  display: inline-block;\n  text-align: left;\n  vertical-align: middle;\n}\n.modal[data-v-78c04645] {\n  text-align: center;\n  padding: 0!important;\n}\n\n.modal[data-v-78c04645]:before {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n  margin-right: -4px;\n}\n\n.carousel .carousel-control span[data-v-78c04645] {\n  color: #3c8dbc\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var ProjectsRegistry = require('core/project/projectsregistry');
exports.default = {
  name: "g3w-images-gallery",
  props: {
    images: {
      type: Array,
      default: []
    },
    id: {
      type: String,
      default: 'gallery'
    },
    active: {
      type: Number
    }
  },
  data: function data() {
    return {
      carouselId: 'carousel_' + Date.now()
    };
  },

  methods: {
    isActive: function isActive(src) {
      return src === active;
    },

    isRelativePath: function isRelativePath(url) {
      if (!_.startsWith(url, '/') && !_.startsWith(url, 'http')) {
        return ProjectsRegistry.getConfig().mediaurl + url;
      }
      return url;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"modal fade modal-fullscreen force-fullscreen",attrs:{"id":_vm.id,"tabindex":"-1","role":"dialog","aria-labelledby":"","aria-hidden":"true"}},[_c('div',{staticClass:"modal-dialog"},[_c('div',{staticClass:"modal-content"},[_c('div',{staticClass:"modal-body"},[_c('div',{staticClass:"carousel slide",attrs:{"id":_vm.carouselId,"data-interval":"false"}},[_c('div',{staticClass:"carousel-inner"},_vm._l((_vm.images),function(image,index){return _c('div',{staticClass:"item",class:_vm.active == index ? 'active' : ''},[_c('img',{staticStyle:{"margin":"auto"},attrs:{"src":_vm.isRelativePath(image.src)}})])}),0),_vm._v(" "),(_vm.images.length> 1)?_c('a',{staticClass:"left carousel-control",attrs:{"href":'#'+_vm.carouselId,"role":"button","data-slide":"prev"}},[_c('span',{class:_vm.g3wtemplate.font['arrow-left']})]):_vm._e(),_vm._v(" "),(_vm.images.length> 1)?_c('a',{staticClass:"right carousel-control",attrs:{"href":'#'+_vm.carouselId,"role":"button","data-slide":"next"}},[_c('span',{class:_vm.g3wtemplate.font['arrow-right']})]):_vm._e()])])])])])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-78c04645"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-78c04645", __vue__options__)
  } else {
    hotAPI.reload("data-v-78c04645", __vue__options__)
  }
})()}

},{"core/project/projectsregistry":624,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],696:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".show-hide-geo[data-v-5acba778] {\n  color: #3C8DBC;\n  cursor: pointer;\n  font-size: 1.2em;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var geoMixin = require('gui/vue/vue.mixins').geoMixin;
exports.default = {
  name: "g3w-geospatial",
  props: {
    data: {}
  },
  mixins: [geoMixin],
  data: function data() {
    return {
      layerId: 'table_layer_' + Date.now(),
      visible: false,
      id: 'geo_table_' + Date.now()
    };
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"geo-content"},[_c('span',{staticClass:"show-hide-geo",class:[_vm.visible ? _vm.g3wtemplate.font['eye-close'] : _vm.g3wtemplate.font['eye']],on:{"click":function($event){$event.stopPropagation();return _vm.showLayer()}}})])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-5acba778"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5acba778", __vue__options__)
  } else {
    hotAPI.reload("data-v-5acba778", __vue__options__)
  }
})()}

},{"gui/vue/vue.mixins":815,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],697:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".img-responsive[data-v-77efe68e] {\n  cursor: pointer;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _field = require('./field.vue');

var _field2 = _interopRequireDefault(_field);

var _gallery = require('./gallery.vue');

var _gallery2 = _interopRequireDefault(_gallery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "image",
  props: ['state'],
  data: function data() {
    return {
      galleryId: 'gallery_' + Date.now(),
      active: null,
      value: this.state.value.mime_type ? this.state.value.value : this.state.value
    };
  },

  components: {
    Gallery: _gallery2.default,
    Field: _field2.default
  },
  computed: {
    values: function values() {
      return Array.isArray(this.value) ? this.value : [this.value];
    }
  },
  methods: {
    getSrc: function getSrc(value) {
      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
        return value.photo;
      }
      return value;
    },
    showGallery: function showGallery(index) {
      this.active = index;
      if ((0, _typeof3.default)(this.value) === 'object') {
        this.value.active = true;
      }
      $('#' + this.galleryId).modal('show');
    },
    getGalleryImages: function getGalleryImages() {
      var _this = this;

      var images = [];
      this.values.forEach(function (image) {
        images.push({
          src: _this.getSrc(image)
        });
      });
      return images;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('field',{attrs:{"state":_vm.state}},[_c('div',{staticStyle:{"text-align":"left"},attrs:{"slot":"field"},slot:"field"},[_vm._l((_vm.values),function(value,index){return _c('img',{staticClass:"img-responsive",staticStyle:{"max-height":"50px"},attrs:{"src":_vm.getSrc(value)},on:{"click":function($event){return _vm.showGallery(index)}}})}),_vm._v(" "),_c('gallery',{attrs:{"id":_vm.galleryId,"active":_vm.active,"images":_vm.getGalleryImages()}})],2)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-77efe68e"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-77efe68e", __vue__options__)
  } else {
    hotAPI.reload("data-v-77efe68e", __vue__options__)
  }
})()}

},{"./field.vue":692,"./gallery.vue":695,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],698:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".field_link[data-v-5d303617] {\n  max-width: 100%;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _field = require('./field.vue');

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "link",
  props: ['state'],
  data: function data() {
    return {
      value: null
    };
  },

  components: {
    Field: _field2.default
  },
  methods: {
    openLink: function openLink(link_url) {
      window.open(link_url, '_blank');
    }
  },
  created: function created() {
    if (this.state.value && (0, _typeof3.default)(this.state.value) === 'object') {
      this.value = this.state.value.value;
    } else {
      this.value = this.state.value;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('field',{attrs:{"state":_vm.state}},[_c('button',{directives:[{name:"t",rawName:"v-t",value:('info.link_button'),expression:"'info.link_button'"}],staticClass:"btn skin-button field_link",attrs:{"slot":"field"},on:{"click":function($event){return _vm.openLink(_vm.value)}},slot:"field"})])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-5d303617"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5d303617", __vue__options__)
  } else {
    hotAPI.reload("data-v-5d303617", __vue__options__)
  }
})()}

},{"./field.vue":692,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],699:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var MediaMixin = require('gui/vue/vue.mixins').mediaMixin;
exports.default = {
  name: "g3w-media",
  mixins: [MediaMixin],
  props: ['state'],
  computed: {
    type: function type() {
      return this.getMediaType(this.state.mime_type).type;
    },
    value: function value() {
      return this.state.value;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return (_vm.value)?_c('div',{staticClass:"preview"},[_c('a',{attrs:{"href":_vm.value,"target":"_blank"}},[_c('div',{staticClass:"previewtype",class:_vm.type},[_c('i',{staticClass:"fa-2x",class:_vm.g3wtemplate.font[_vm.type]})])]),_vm._v(" "),_c('div',{staticClass:"filename"},[_vm._v(_vm._s(_vm.filename))]),_vm._v(" "),_vm._t("default")],2):_vm._e()}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-2bdc4097"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-2bdc4097", __vue__options__)
  } else {
    hotAPI.reload("data-v-2bdc4097", __vue__options__)
  }
})()}

},{"gui/vue/vue.mixins":815,"vue":515,"vue-hot-reload-api":513}],700:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".field_text_table[data-v-4ba00c6c] {\n  background-color: transparent !important;\n}\n.field_text_table .field_label[data-v-4ba00c6c] {\n  font-weight: bold;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _field = require('./field.vue');

var _field2 = _interopRequireDefault(_field);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "text",
  props: ['state'],
  components: {
    Field: _field2.default
  },
  created: function created() {}
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('field',{attrs:{"state":_vm.state}})}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-4ba00c6c"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-4ba00c6c", __vue__options__)
  } else {
    hotAPI.reload("data-v-4ba00c6c", __vue__options__)
  }
})()}

},{"./field.vue":692,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],701:[function(require,module,exports){
module.exports = "<div>\n  <form class=\"form-horizontal g3w-form\">\n    <div class=\"box-primary\">\n      <div class=\"box-body\">\n        <template v-if=\"hasFormStructure\">\n          <tabs\n            :contenttype=\"'editing'\"\n            :addToValidate=\"addToValidate\"\n            :changeInput=\"changeInput\"\n            :tabs=\"state.formstructure\"\n            :fields=\"state.fields\">\n          </tabs>\n          <g3w-form-inputs v-if=\"state.fieldsoutofformstructure.length\"\n            :state=\"state.fieldsoutofformstructure\"\n            :addToValidate=\"addToValidate\"\n            :changeInput=\"changeInput\"\n            @changeinput=\"changeInput\"\n            @addinput=\"addToValidate\">\n          </g3w-form-inputs>\n        </template>\n        <template v-else>\n          <g3w-form-inputs\n            :state=\"state\"\n            :addToValidate=\"addToValidate\"\n            :changeInput=\"changeInput\"\n            @changeinput=\"changeInput\"\n            @addinput=\"addToValidate\">\n          </g3w-form-inputs>\n        </template>\n      </div>\n    </div>\n  </form>\n</div>\n";

},{}],702:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

var _g3wFormInputs = require('../../../../inputs/g3w-form-inputs.vue');

var _g3wFormInputs2 = _interopRequireDefault(_g3wFormInputs);

var _tabs = require('../../../../tabs/tabs.vue');

var _tabs2 = _interopRequireDefault(_tabs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./body.html'));

var BodyFormComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  props: ['state'],
  data: function data() {
    return {
      show: true
    };
  },

  components: {
    Tabs: _tabs2.default,
    G3wFormInputs: _g3wFormInputs2.default
  },
  methods: {
    addToValidate: function addToValidate(input) {
      this.$emit('addtovalidate', input);
    },
    changeInput: function changeInput(input) {
      this.$emit('changeinput', input);
    }
  },
  computed: {
    hasFormStructure: function hasFormStructure() {
      return !!this.state.formstructure;
    }
  }
}));

module.exports = BodyFormComponent;

},{"../../../../inputs/g3w-form-inputs.vue":722,"../../../../tabs/tabs.vue":800,"./body.html":701,"babel-runtime/helpers/extends":22,"gui/vue/utils":812}],703:[function(require,module,exports){
module.exports = "<div class=\"form-group g3wform_footer\">\n  <slot>\n    <div style=\"margin:10px; font-weight: bold\">\n      * <span  v-t=\"'sdk.form.footer.required_fields'\"></span>\n      <div v-if=\"state.footer.message\" :style=\"[state.footer.style] \">{{ state.footer.message }}</div>\n    </div>\n    <button v-for=\"button in state.buttons\" class=\"btn \"\n      :class=\"[button.class]\"\n      @click.stop.prevent=\"exec(button.cbk)\"\n      v-disabled=\"!btnEnabled(button)\">\n      {{ button.title }}\n    </button>\n  </slot>\n</div>\n";

},{}],704:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./footer.html'));
var FooterFormComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  props: ['state'],
  data: function data() {
    return {
      id: "footer",
      active: true
    };
  },

  methods: {
    exec: function exec(cbk) {
      cbk instanceof Function ? cbk(this.state.fields) : function () {
        return this.state.fields;
      }();
    },
    btnEnabled: function btnEnabled(button) {
      return button.type !== 'save' || button.type === 'save' && this.isValid();
    },
    isValid: function isValid() {
      return this.state.valid;
    },
    _enterEventHandler: function _enterEventHandler(evt) {
      if (evt.which === 13) {
        evt.preventDefault();
        if (this.isValid() && this.active) $(this.$el).find('button').click();
      }
    }
  },
  activated: function activated() {
    this.active = true;
  },
  deactivated: function deactivated() {
    this.active = false;
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      document.addEventListener('keydown', _this._enterEventHandler);
    });
  },
  beforeDestroy: function beforeDestroy() {
    document.removeEventListener('keydown', this._enterEventHandler);
  }
}));

module.exports = FooterFormComponent;

},{"./footer.html":703,"babel-runtime/helpers/extends":22,"gui/vue/utils":812}],705:[function(require,module,exports){
module.exports = "<div class=\"g3wform_header box-header with-border\">\n  <span style=\"display:flex;\"\n    class=\"title\"\n    :class=\"[{item_selected: currentindex === index && headers.length > 1},[headers.length > 1 ? 'tabs' : 'one' ]]\"\n    v-for=\"(header, index) in headers\" :key=\"header.title\"\n    @click=\"click(index)\">\n    <span v.if=\"header.icon\" style=\"margin-right: 5px\">\n      <i :class=\"header.icon\"></i>\n    </span>\n    <span>{{ header.title }}</span>\n  </span>\n</div>\n";

},{}],706:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./header.html'));
var HeaderFormComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  props: {
    headers: {
      type: Array,
      default: []
    },
    currentindex: {
      type: Number,
      default: 0
    }
  },
  methods: {
    click: function click(index) {
      if (this.currentindex !== index) {
        this.$emit('clickheader', index);
      }
    }
  }
}));

module.exports = HeaderFormComponent;

},{"./header.html":705,"babel-runtime/helpers/extends":22,"gui/vue/utils":812}],707:[function(require,module,exports){
var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

function FormService() {
  var _this = this;

  this.state = null;
  this.eventBus = new Vue();
  this.setters = {
    setInitForm: function setInitForm(options) {
      this._setInitForm(options);
    },
    setFormStructure: function setFormStructure(formStructure) {
      this.state.formstructure = formStructure;
    },
    // setter change fields
    setFormFields: function setFormFields(fields) {
      this.state.fields = fields;
    },
    setupFields: function setupFields() {
      this._setupFields();
    },
    // setter sinsert data into form
    setFormData: function setFormData(fields) {
      this.setFormFields(fields);
    },
    // setter single field
    setField: function setField(field) {},
    // settere state
    setState: function setState(state) {
      this._setState(state);
    },
    // setter add action
    addActionsForForm: function addActionsForForm(actions) {},
    postRender: function postRender(element) {
      // hook for listener to chenge DOM
    }
  };
  base(this);
  this.init = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    this._setInitForm(options);
  };
  // init form options paased for example by editor
  this._setInitForm = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var layer = options.layer;
    var fields = options.fields;
    this.title = options.title || 'Form';
    this.formId = options.formId;
    this.name = options.name;
    this.pk = options.pk || null;
    this.buttons = options.buttons || [];
    this.context_inputs = options.context_inputs;
    var footer = options.footer || {};
    this.state = {
      loading: false,
      components: [],
      disabledcomponents: [],
      component: null,
      headers: [],
      currentheaderindex: 0,
      fields: null,
      buttons: this.buttons,
      disabled: false,
      valid: true, // global form validation state. True at beginning
      // when input change will be update
      tovalidate: {},
      componentstovalidate: {},
      footer: footer
    };
    this.setFormFields(fields);
    this.setFormStructure(options.formStructure);
    if (layer && options.formStructure) {
      var fieldsoutofformstructure = layer.getFieldsOutOfFormStructure().map(function (field) {
        return field.field_name;
      });
      this.state.fieldsoutofformstructure = {
        fields: fields.filter(function (field) {
          return fieldsoutofformstructure.indexOf(field.name) > -1;
        })
      };
    }
  };
  this.eventBus.$on('set-loading-form', function () {
    var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _this.state.loading = bool;
  });
}

inherit(FormService, G3WObject);

var proto = FormService.prototype;

proto.setLoading = function () {
  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  this.state.loading = bool;
};

proto.setValidComponent = function (_ref) {
  var id = _ref.id,
      valid = _ref.valid;

  this.state.componentstovalidate[id] = valid;
  this.isValid();
};

proto.getValidComponent = function (id) {
  return this.state.componentstovalidate[id];
};

// Every input send to form it valid value that will change the genaral state of form
proto.isValid = function (input) {
  var _this2 = this;

  if (input) {
    if (input.validate.mutually) {
      if (!input.validate.required) {
        if (!input.validate.empty) {
          input.validate.valid = input.validate.mutually.reduce(function (previous, inputname) {
            return previous && _this2.state.tovalidate[inputname].validate.empty;
          }, true);
        } else {
          var countNoTEmptyInputName = [];
          for (var i = input.validate.mutually.length; i--;) {
            var inputname = input.validate.mutually[i];
            !this.state.tovalidate[inputname].validate.empty && countNoTEmptyInputName.push(inputname);
          }
          if (countNoTEmptyInputName.length < 2) {
            input.validate.valid = true;
            input.value = null;
            countNoTEmptyInputName.forEach(function (inputname) {
              _this2.state.tovalidate[inputname].validate.valid = true;
            });
          }
        }
      }
      //check if min_field or max_field is set
    } else if (!input.validate.empty && (input.validate.min_field || input.validate.max_field)) {
      var input_name = input.validate.min_field || input.validate.max_field;
      input.validate.valid = input.validate.min_field ? this.state.tovalidate[input.validate.min_field].validate.empty || 1 * input.value > 1 * this.state.tovalidate[input.validate.min_field].value : this.state.tovalidate[input.validate.max_field].validate.empty || 1 * input.value < 1 * this.state.tovalidate[input.validate.max_field].value;
      if (input.validate.valid) this.state.tovalidate[input_name].validate.valid = true;
    }
  }

  this.state.valid = (0, _values2.default)(this.state.tovalidate).reduce(function (previous, input) {
    return previous && input.validate.valid;
  }, true) && (0, _values2.default)(this.state.componentstovalidate).reduce(function (previous, valid) {
    return previous && valid;
  }, true);
};

proto.addComponents = function () {
  var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(components), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var component = _step.value;

      this.addComponent(component);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

proto.addComponent = function (component) {
  var title = component.id,
      icon = component.icon,
      valid = component.valid;

  if (valid !== undefined) {
    this.state.componentstovalidate[title] = valid;
    this.state.valid = this.state.valid && valid;
    this.eventBus.$emit('add-component-validate', {
      id: title,
      valid: valid
    });
  }
  this.state.headers.push({ title: title, icon: icon });
  this.state.components.push(component.component);
};

proto.replaceComponent = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      index = _ref2.index,
      component = _ref2.component;

  this.state.components.splice(index, 1, component);
};

proto.disableComponent = function (_ref3) {
  var index = _ref3.index,
      disabled = _ref3.disabled;

  if (disabled) this.state.disabledcomponents.push(index);else this.state.disabledcomponents = this.state.disabledcomponents.filter(function (disabledIndex) {
    return disabledIndex !== index;
  });
};

proto.setComponentByIndex = function (index) {
  if (this.state.disabledcomponents.indexOf(index) === -1) {
    this.setIndexHeader(index);
    this.state.component = this.state.components[index];
  }
};

proto.getComponentByIndex = function (index) {
  return this.state.components[index];
};

proto.setComponent = function (component) {
  this.state.component = component;
};

proto.addedComponentTo = function () {
  var formcomponent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'body';

  this.state.addedcomponentto[formcomponent] = true;
};

proto.addToValidate = function (input) {
  this.state.tovalidate[input.name] = input;
};

proto.getState = function () {
  return this.state;
};

proto._setState = function (state) {
  this.state = state;
};

proto.getFields = function () {
  return this.state.fields;
};

proto._getField = function (fieldName) {
  var field = this.state.fields.find(function (field) {
    return field.name === fieldName;
  });
  return field;
};

proto.getEventBus = function () {
  return this.eventBus;
};

proto.setIndexHeader = function (index) {
  this.state.currentheaderindex = index;
};

proto.getContext = function () {
  return this.context_inputs.context;
};

proto.getSession = function () {
  return this.getContext().session;
};

proto.getInputs = function () {
  return this.context_inputs.inputs;
};

//method to clear all the open thinghs opened by service
proto.clearAll = function () {
  this.eventBus.$off('addtovalidate');
  this.eventBus.$off('set-main-component');
  this.eventBus.$off('set-loading-form');
  this.eventBus.$off('component-validation');
  this.eventBus.$off('disable-component');
};

module.exports = FormService;

},{"babel-runtime/core-js/get-iterator":4,"babel-runtime/core-js/object/values":15,"core/g3wobject":569,"core/utils/utils":630}],708:[function(require,module,exports){
module.exports = "<div class=\"g3wform_content\" style=\"position: relative\">\n  <bar-loader :loading=\"state.loading\"></bar-loader>\n  <g3wformheader\n    :currentindex=\"state.currentheaderindex\"\n    :headers=\"state.headers\"\n    @clickheader=\"switchComponent\">\n  </g3wformheader>\n  <div class=\"g3wform_body\" >\n    <keep-alive>\n      <component\n        @hook:activated=\"reloadLayout\"\n        @addtovalidate=\"addToValidate\"\n        @changeinput=\"changeInput\"\n        :state=\"state\"\n        :is=\"state.component\">\n      </component>\n    </keep-alive>\n  </div>\n  <g3w-form-footer :state=\"state\"></g3w-form-footer>\n</div>\n";

},{}],709:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var Service = require('../formservice');
var base = require('core/utils/utils').base;
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./form.html'));
var HeaderFormComponent = require('../components/header/vue/header');
var BodyFormComponent = require('../components/body/vue/body');
var G3wFormFooter = require('gui/form/components/footer/vue/footer');

//vue component
var vueComponentObject = (0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: {},
      switchcomponent: false
    };
  },
  components: {
    g3wformheader: HeaderFormComponent,
    G3wFormFooter: G3wFormFooter
  },
  transitions: { 'addremovetransition': 'showhide' },
  methods: {
    disableComponent: function disableComponent(_ref) {
      var _ref$index = _ref.index,
          index = _ref$index === undefined ? -1 : _ref$index,
          _ref$disabled = _ref.disabled,
          disabled = _ref$disabled === undefined ? false : _ref$disabled;

      this.$options.service.disableComponent({
        index: index,
        disabled: disabled
      });
    },
    switchComponent: function switchComponent(index) {
      this.switchcomponent = true;
      this.$options.service.setComponentByIndex(index);
    },

    changeInput: function changeInput(input) {
      return this.$options.service.isValid(input);
    },
    addToValidate: function addToValidate(input) {
      this.$options.service.addToValidate(input);
    },
    // set layout
    reloadLayout: function reloadLayout() {
      var height = $(this.$el).height();
      if (!height) return;
      var footerHeight = $('.g3wform_footer').height() ? $('.g3wform_footer').height() + 50 : 50;
      $(this.$el).find(".g3wform_body").height(height - ($('.g3wform_header').height() + footerHeight));
    }
  },
  updated: function updated() {
    var _this = this;

    this.$nextTick(function () {
      if (_this.switchcomponent) {
        setTimeout(function () {
          _this.switchcomponent = false;
        }, 0);
      }
    });
  },
  created: function created() {
    var _this2 = this;

    this.$options.service.getEventBus().$on('set-main-component', function () {
      _this2.switchComponent(0);
    });
    this.$options.service.getEventBus().$on('component-validation', function (_ref2) {
      var id = _ref2.id,
          valid = _ref2.valid;

      _this2.$options.service.setValidComponent({
        id: id,
        valid: valid
      });
    });
    this.$options.service.getEventBus().$on('addtovalidate', this.addToValidate);
    this.$options.service.getEventBus().$on('disable-component', this.disableComponent);
  },
  mounted: function mounted() {
    // check if is valid form (it used by footer component)
    this.$options.service.isValid();
  },
  beforeDestroy: function beforeDestroy() {
    this.$options.service.clearAll();
  }
});

function FormComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  options.id = options.id || 'form';
  base(this, options);
  options.service = options.service ? new options.service() : new Service();
  options.vueComponentObject = options.vueComponentObject || vueComponentObject;
  //set statdar element of the form
  var components = options.components || [{ id: options.title, component: BodyFormComponent }];
  // initialize component
  this.init(options);
  this.getService().addComponents(components);
  this.getService().setComponent(components[0].component);

  this.addFormComponents = function () {
    var components = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    this.getService().addComponents(components);
  };

  this.addFormComponent = function (component) {
    component && this.getService().addComponent(component);
  };
  // some utilities methods
  this.addDependecyComponents = function (components) {
    this.getService().addDependecyComponents(components);
  };
  this.addComponentBeforeBody = function (Component) {
    //this.getService().addedComponentTo('body');
    //this.insertComponentAt(1, Component);
  };

  this.addComponentAfterBody = function (Component) {
    //this.getService().addedComponentTo('body');
    //this.insertComponentAt(2, Component)
  };

  this.addComponentBeforeFooter = function () {
    //TODO
  };

  this.addComponentAfterFooter = function (Component) {
    //TODO
  };
  // overwrite father mount method.
  this.mount = function (parent, append) {
    return base(this, 'mount', parent, append).then(function () {
      // set modal window to true
      GUI.setModal(true);
    });
  };

  this.layout = function () {
    this.internalComponent.reloadLayout();
  };
}

inherit(FormComponent, Component);

module.exports = FormComponent;

},{"../components/body/vue/body":702,"../components/header/vue/header":706,"../formservice":707,"./form.html":708,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/form/components/footer/vue/footer":704,"gui/gui":710,"gui/vue/component":806,"gui/vue/utils":812}],710:[function(require,module,exports){
var noop = require('core/utils/utils').noop;
var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var RouterService = require('core/router');
var base = require('core/utils/utils').base;
var ComponentsRegistry = require('gui/componentsregistry');

// API della GUI.
// methods have be defined by application
// app shold call GUI.ready() when GUI is ready
function GUI() {
  this.setters = {
    setContent: function setContent(options) {
      this.emit('opencontent', true);
      this._setContent(options);
    }
  };
  this.isready = false;
  // images urls
  this.getResourcesUrl = noop;
  // show a Vue form
  this.showForm = noop;
  this.closeForm = noop;
  this.showListing = noop;
  this.closeListing = noop;
  this.hideListing = noop;
  // modal
  this.setModal = noop;
  this.showFullModal = noop;
  // modal
  this.showQueryResults = noop;
  this.hideQueryResults = noop;
  this.showPanel = noop;
  this.hidePanel = noop;
  this.reloadComponents = noop;
  this.showUserMessage = noop;
  this.closeUserMessage = noop;
  this.showModalDialog = noop;
  this.addComponent = function (component, placeholder) {};
  this.removeComponent = function (id) {};
  this.setComponent = function (component) {
    ComponentsRegistry.registerComponent(component);
  };
  this.getComponent = function (id) {
    return ComponentsRegistry.getComponent(id);
  };
  this.getComponents = function () {
    return ComponentsRegistry.getComponents();
  };
  this.goto = function (url) {
    RouterService.goto(url);
  };

  this.ready = function () {
    this.emit('ready');
    this.isready = true;
  };

  this.guiResized = function () {
    this.emit('guiresized');
  };

  /* spinner */
  this.showSpinner = function (options) {};
  this.hideSpinner = function (id) {};
  /* end spinner */

  this.notify = noop;
  this.dialog = noop;
  this.isMobile = noop;

  //useful to registere setters
  base(this);
}

inherit(GUI, G3WObject);

module.exports = new GUI();

},{"core/g3wobject":569,"core/router":628,"core/utils/utils":630,"gui/componentsregistry":691}],711:[function(require,module,exports){
module.exports = "<div class=\"form-group\">\n  <slot name=\"label\">\n    <label :for=\"state.name\" class=\"col-sm-4 control-label\">{{ state.label }}\n      <span v-if=\"state.validate && state.validate.required\">*</span>\n    </label>\n  </slot>\n  <div class=\"col-sm-8\">\n    <slot name=\"loading\"></slot>\n    <slot name=\"body\">\n      <input\n        @keyup=\"change()\"\n        v-disabled=\"!isEditable()\"\n        :field=\"state.name\"\n        class=\"form-control\"\n        v-model=\"state.value\"\n        :class=\"{'input-error-validation' : notvalid}\"\n        :id=\"state.name\"\n        :placeholder=\"state.input.label\">\n    </slot>\n    <slot name=\"message\">\n      <p v-if=\"notvalid\" class=\"error-input-message\" v-html=\"state.validate.message\"></p>\n      <p v-else-if=\"state.info\" v-html=\"state.info\"></p>\n    </slot>\n  </div>\n</div>\n";

},{}],712:[function(require,module,exports){
// Base object that has common  inputs methods
var Service = require('../service');

var BaseInput = {
  props: ['state'],
  template: require('./baseinput.html'),
  computed: {
    notvalid: function notvalid() {
      if (this.state.validate.valid === false) this.service.getErrorMessage(this.state);
      return this.state.validate.valid === false;
    }
  },
  methods: {
    // called when input value change
    change: function change() {
      // validate input
      this.state.validate.required && this.service.validate();
      // emit change input
      this.$emit('changeinput', this.state);
    },
    isEditable: function isEditable() {
      return this.service.isEditable();
    },
    isVisible: function isVisible() {}
  },
  created: function created() {
    if (!this.service) {
      this.service = new Service({
        state: this.state
      });
    }
    ///this.service.setValue(this.state.value)
    this.state.validate.message = this.service.getErrorMessage(this.state);
    //if required validate it
    this.state.validate.required && this.service.validate();
    this.$emit('addinput', this.state);
  }
};

var BaseInputComponent = Vue.extend({
  mixins: [BaseInput]
});

module.exports = {
  BaseInput: BaseInput,
  BaseInputComponent: BaseInputComponent
};

},{"../service":745,"./baseinput.html":711}],713:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function CheckBoxService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var value = options.state.input.options.values.find(function (value) {
    return value.checked === false;
  });
  if (options.state.value === null) options.state.value = value.value;
  base(this, options);
}

inherit(CheckBoxService, Service);

var proto = CheckBoxService.prototype;

proto.convertCheckedToValue = function (checked) {
  var option = this.state.input.options.values.find(function (value) {
    return value.checked === checked;
  });
  this.state.value = option.value;
  return this.state.value;
};

proto.convertValueToChecked = function () {
  var valueToCheck = this.state.value;
  if (valueToCheck === null) return null;
  var option = this.state.input.options.values.find(function (value) {
    return value.value == valueToCheck;
  });
  return option.checked;
};

module.exports = CheckBoxService;

},{"core/utils/utils":630,"gui/inputs/service":745}],714:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div style=\"height: 20px; margin-top:8px;\" slot=\"body\">\n    <input\n      @change=\"changeCheckBox\"\n      style=\"width:100%\"\n      v-disabled=\"!isEditable()\"\n      :class=\"{'input-error-validation' : notvalid}\"\n      class=\"magic-checkbox\"\n      v-model=\"value\"\n      type=\"checkbox\"\n      :id=\"id\">\n    <label :for=\"id\">{{ label }}</label>\n  </div>\n</baseinput>\n";

},{}],715:[function(require,module,exports){
var Input = require('gui/inputs/input');
var Service = require('../service');
var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
var WidgetMixins = require('gui/inputs/widgetmixins');

var CheckBoxInput = Vue.extend({
  mixins: [Input, WidgetMixins],
  template: require('./checkbox.html'),
  data: function data() {
    var values = this.state.input.options.values.map(function (value) {
      return value;
    });
    return {
      service: new Service({
        state: this.state,
        // options to customize validator
        validatorOptions: {
          values: values
        }
      }),
      value: null,
      label: null,
      id: getUniqueDomId() // new id
    };
  },
  methods: {
    setLabel: function setLabel() {
      // convert label
      this.label = this.service.convertCheckedToValue(this.value);
    },
    setValue: function setValue() {
      this.value = this.service.convertValueToChecked();
    },

    changeCheckBox: function changeCheckBox() {
      // convert label
      this.setLabel();
      this.widgetChanged();
    },
    stateValueChanged: function stateValueChanged() {
      this.setValue();
      this.setLabel();
    }
  },
  mounted: function mounted() {
    this.value = this.service.convertValueToChecked();
    this.setLabel();
    this.change();
  }
});

module.exports = CheckBoxInput;

},{"../service":713,"./checkbox.html":714,"core/utils/utils":630,"gui/inputs/input":724,"gui/inputs/widgetmixins":752}],716:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ApplicationService = require('core/applicationservice');
var Service = require('gui/inputs/service');

function DateTimePickerService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.validatorOptions = {};
  base(this, options);
}

inherit(DateTimePickerService, Service);

var proto = DateTimePickerService.prototype;

proto.getLocale = function () {
  var applicationConfig = ApplicationService.getConfig();
  return applicationConfig.user.i18n ? applicationConfig.user.i18n : 'en';
};

proto.convertQGISDateTimeFormatToMoment = function (datetimeformat) {
  datetimeformat = datetimeformat.replace('yyyy', 'YYYY');
  var matchDayInDate = datetimeformat.match(/d/g);
  if (matchDayInDate && matchDayInDate.length < 3) {
    datetimeformat = datetimeformat.replace('d'.repeat(matchDayInDate.length), 'D'.repeat(matchDayInDate.length));
  }
  return datetimeformat;
};

proto.setValidatorOptions = function (options) {
  this.validatorOptions = options;
};

module.exports = DateTimePickerService;

},{"core/applicationservice":560,"core/utils/utils":630,"gui/inputs/service":745}],717:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div slot=\"body\" >\n    <div class='input-group date' :id='iddatetimepicker'>\n      <input\n        :id=\"idinputdatetimepiker\"\n        :readonly=\"!isEditable() ? 'readonly' : null\"\n        type='text'\n        v-disabled=\"!isEditable()\"\n        :class=\"{'input-error-validation' : notvalid}\"\n        class=\"form-control\" />\n      <span\n        class=\"input-group-addon caret\">\n        <span\n          :class=\"[timeOnly() ? g3wtemplate.getFontClass('time') :  g3wtemplate.getFontClass('calendar')]\">\n        </span>\n      </span>\n    </div>\n  </div>\n</baseinput>\n";

},{}],718:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');
var Service = require('../service');
var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
var WidgetMixins = require('gui/inputs/widgetmixins');

var DateTimePickerInput = Vue.extend({
  mixins: [Input, WidgetMixins],
  template: require('./datetimepicker.html'),
  data: function data() {
    // creo un unico valore per identificare id
    var uniqueValue = getUniqueDomId();
    // in base al fielddatetimeformat creo la data tramite moment
    return {
      service: new Service({
        state: this.state
      }),
      iddatetimepicker: 'datetimepicker_' + uniqueValue,
      idinputdatetimepiker: 'inputdatetimepicker_' + uniqueValue,
      changed: false
    };
  },
  methods: {
    timeOnly: function timeOnly() {
      return !this.state.input.options.formats[0].date;
    },
    stateValueChanged: function stateValueChanged(value) {
      var datetimedisplayformat = this.service.convertQGISDateTimeFormatToMoment(this.state.input.options.formats[0].displayformat);
      var date = moment(value).format(datetimedisplayformat);
      $('#' + this.idinputdatetimepiker).val(date);
    }
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var fielddatetimeformat = _this.state.input.options.formats[0].fieldformat.replace('yyyy', 'YYYY').replace('dd', 'DD');
      _this.service.setValidatorOptions({
        fielddatetimeformat: fielddatetimeformat
      });
      var date = moment(_this.state.value, fielddatetimeformat, true).isValid() ? moment(_this.state.value, fielddatetimeformat).toDate() : null;
      var locale = _this.service.getLocale();
      var datetimedisplayformat = _this.service.convertQGISDateTimeFormatToMoment(_this.state.input.options.formats[0].displayformat);
      var datetimefieldformat = _this.service.convertQGISDateTimeFormatToMoment(_this.state.input.options.formats[0].fieldformat);
      $(function () {
        $('#' + _this.iddatetimepicker).datetimepicker({
          defaultDate: date,
          format: datetimedisplayformat,
          toolbarPlacement: 'top',
          widgetPositioning: {
            vertical: 'auto',
            horizontal: 'right'
          },
          showClose: true,
          locale: locale
        });
      });
      $('#' + _this.iddatetimepicker).on("dp.change", function (e) {
        var newDate = $('#' + _this.idinputdatetimepiker).val();
        _this.state.value = _.isEmpty(_.trim(newDate)) ? null : moment(newDate, datetimedisplayformat).format(datetimefieldformat);
        _this.widgetChanged();
      });
      $('#' + _this.iddatetimepicker).on("dp.show", function (e) {
        _this.$emit('datetimepickershow');
      });
      $('#' + _this.iddatetimepicker).on("dp.hide", function (e) {
        _this.$emit('datetimepickershow');
      });
    });
  }
});

module.exports = DateTimePickerInput;

},{"../service":716,"./datetimepicker.html":717,"core/utils/utils":630,"gui/inputs/input":724,"gui/inputs/widgetmixins":752}],719:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function FloatService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
}

inherit(FloatService, Service);

module.exports = FloatService;

},{"core/utils/utils":630,"gui/inputs/service":745}],720:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <input\n    @change=\"change\"\n    @input=\"change\"\n    class=\"form-control\"\n    style=\"width:100%\"\n    v-disabled=\"!isEditable()\"\n    :class=\"{'input-error-validation' : notvalid}\"\n    v-model=\"state.value\"\n    slot=\"body\"\n    type=\"number\">\n</baseinput>\n";

},{}],721:[function(require,module,exports){
var Input = require('gui/inputs/input');
var Service = require('../service');

var FloatInput = Vue.extend({
  mixins: [Input],
  template: require('./float.html'),
  data: function data() {
    return {
      service: new Service({
        state: this.state
      })
    };
  }
});

module.exports = FloatInput;

},{"../service":719,"./float.html":720,"gui/inputs/input":724}],722:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _g3wInput = require('./g3w-input.vue');

var _g3wInput2 = _interopRequireDefault(_g3wInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "g3w-form-inputs",
  props: ['state', 'addToValidate', 'changeInput'],
  components: {
    G3wInput: _g3wInput2.default
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('form',{staticClass:"form-horizontal g3w-form"},[_c('div',{staticClass:"box-primary"},[_c('div',{staticClass:"box-body"},[_vm._l((_vm.state.fields),function(field){return [_c('g3w-input',{attrs:{"state":field,"addToValidate":_vm.addToValidate,"changeInput":_vm.changeInput},on:{"addToValidate":_vm.addToValidate,"changeInput":_vm.changeInput}})]})],2)])])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-47a37db3"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-47a37db3", __vue__options__)
  } else {
    hotAPI.reload("data-v-47a37db3", __vue__options__)
  }
})()}

},{"./g3w-input.vue":723,"vue":515,"vue-hot-reload-api":513}],723:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Inputs = require('./inputs');
exports.default = {
  name: "g3w-input",
  props: {
    state: {
      required: true
    },
    addToValidate: {
      type: Function,
      required: true
    },
    changeInput: {
      type: Function,
      required: true
    }
  },
  components: (0, _extends3.default)({}, Inputs),
  computed: {
    type: function type() {
      if (this.state.type !== 'child') return this.state.input.type ? this.state.input.type + '_input' : this.state.type + '_input';
    }
  },
  created: function created() {
    if (this.state.type !== 'child' && !this.state.input.options) this.state.input.options = {};
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.state.type !== 'child')?_c('div',[_c(_vm.type,{tag:"component",attrs:{"addToValidate":_vm.addToValidate,"changeInput":_vm.changeInput,"state":_vm.state},on:{"changeinput":_vm.changeInput,"addinput":_vm.addToValidate}}),_vm._v(" "),_c('span',{staticClass:"divider"})],1):_c('div',{staticClass:"skin-border-color field-child",staticStyle:{"border-top":"2px solid"}},[_c('h4',{staticStyle:{"font-weight":"bold"}},[_vm._v(_vm._s(_vm.state.label))]),_vm._v(" "),_c('div',[_vm._v(" "+_vm._s(_vm.state.description)+" ")]),_vm._v(" "),_vm._l((_vm.state.fields),function(field){return _c('g3w-input',{key:field.name,attrs:{"state":field,"addToValidate":_vm.addToValidate,"changeInput":_vm.changeInput},on:{"changeinput":_vm.changeInput,"addinput":_vm.addToValidate}})})],2)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-cadacdaa"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-cadacdaa", __vue__options__)
  } else {
    hotAPI.reload("data-v-cadacdaa", __vue__options__)
  }
})()}

},{"./inputs":725,"babel-runtime/helpers/extends":22,"vue":515,"vue-hot-reload-api":513}],724:[function(require,module,exports){
var BaseInput = require('./baseinput/baseinput').BaseInput;
var BaseInputComponent = require('./baseinput/baseinput').BaseInputComponent;
var Input = {
  props: ['state'],
  mixins: [BaseInput],
  components: {
    baseinput: BaseInputComponent
  }
};

module.exports = Input;

},{"./baseinput/baseinput":712}],725:[function(require,module,exports){
var InputsComponents = {
  'text_input': require('./text/vue/text'),
  'textarea_input': require('./textarea/vue/textarea'),
  'integer_input': require('./integer/vue/integer'),
  'string_input': require('./text/vue/text'), //temporary
  'float_input': require('./float/vue/float'),
  'radio_input': require('./radio/vue/radio'),
  'check_input': require('./checkbox/vue/checkbox'),
  'range_input': require('./range/vue/range'),
  'datetimepicker_input': require('./datetimepicker/vue/datetimepicker'),
  'unique_input': require('./unique/vue/unique'),
  'select_input': require('./select/vue/select'),
  'media_input': require('./media/vue/media'),
  'select_autocomplete_input': require('./select/vue/select'),
  'picklayer_input': require('./picklayer/vue/picklayer')
};

module.exports = InputsComponents;

},{"./checkbox/vue/checkbox":715,"./datetimepicker/vue/datetimepicker":718,"./float/vue/float":721,"./integer/vue/integer":728,"./media/vue/media":731,"./picklayer/vue/picklayer":734,"./radio/vue/radio":737,"./range/vue/range":740,"./select/vue/select":743,"./text/vue/text":746,"./textarea/vue/textarea":748,"./unique/vue/unique":751}],726:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function IntegerService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
}

inherit(IntegerService, Service);

module.exports = IntegerService;

},{"core/utils/utils":630,"gui/inputs/service":745}],727:[function(require,module,exports){
arguments[4][720][0].apply(exports,arguments)
},{"dup":720}],728:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');
var Service = require('../service');

var IntegerInput = Vue.extend({
  mixins: [Input],
  data: function data() {
    return {
      service: new Service({
        state: this.state
      })
    };
  },
  template: require('./integer.html')
});

module.exports = IntegerInput;

},{"../service":726,"./integer.html":727,"gui/inputs/input":724}],729:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function MediaService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
}

inherit(MediaService, Service);

module.exports = MediaService;

},{"core/utils/utils":630,"gui/inputs/service":745}],730:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div slot=\"body\">\n    <div class=\"g3w_input_button skin-border-color\" @click=\"onClick\" style=\"border-style: solid; border-width: 2px; border-radius: 4px; width:100%; cursor: pointer; text-align: center;\">\n      <i :class=\"g3wtemplate.getFontClass('file-upload')\" class=\"fa-2x skin-color\" style=\"padding: 5px;\">\n        <input\n          :id=\"mediaid\"\n          style=\"display:none\"\n          :name=\"state.name\"\n          :data-url=\"state.input.options.uploadurl\"\n          v-disabled=\"!isEditable()\"\n          :class=\"{'input-error-validation' : notvalid}\"\n          type=\"file\">\n      </i>\n    </div>\n    <bar-loader :loading=\"loading\"></bar-loader>\n    <g3w-media :state=\"data\">\n      <div class=\"clearmedia\" @click=\"clearMedia()\">\n        <i :class=\"g3wtemplate.font['trash-o']\" class=\"g3w-icon\"></i>\n      </div>\n    </g3w-media>\n  </div>\n</baseinput>\n";

},{}],731:[function(require,module,exports){
var InputMixins = require('gui/inputs/input');
var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
var t = require('core/i18n/i18n.service').t;
var Service = require('../service');
var MediaField = require('gui/fields/fields').media_field;
var GUI = require('gui/gui');

var MediaInput = Vue.extend({
  mixins: [InputMixins],
  components: {
    'g3w-media': MediaField
  },
  data: function data() {
    return {
      service: new Service({
        state: this.state
      }),
      data: {
        value: null,
        mime_type: null
      },
      mediaid: 'media_' + getUniqueDomId(),
      loading: false
    };
  },
  template: require('./media.html'),
  methods: {
    onClick: function onClick(e) {
      document.getElementById(this.mediaid).click();
    },
    createImage: function createImage(file, field) {
      var reader = new FileReader();
      reader.onload = function (e) {
        field.value = e.target.result;
      };
      reader.readAsDataURL(file);
    },
    checkFileSrc: function checkFileSrc(value) {
      if (_.isNil(value)) {
        value = '';
      }
      return value;
    },
    clearMedia: function clearMedia() {
      this.data.value = this.data.mime_type = this.state.value = null;
    }
  },
  created: function created() {
    if (this.state.value) {
      this.data.value = this.state.value.value;
      this.data.mime_type = this.state.value.mime_type;
    }
  },
  mounted: function mounted() {
    var _this = this;

    var fieldName = this.state.name;
    var formData = {
      name: fieldName,
      csrfmiddlewaretoken: this.$cookie.get('csrftoken')
    };
    this.$nextTick(function () {
      $('#' + _this.mediaid).fileupload({
        dataType: 'json',
        formData: formData,
        start: function start() {
          _this.loading = true;
        },
        done: function done(e, data) {
          var response = data.result[fieldName];
          if (response) {
            _this.data.value = response.value;
            _this.data.mime_type = response.mime_type;
            _this.state.value = _this.data;
            _this.change();
          }
        },
        fail: function fail() {
          GUI.notify.error(t("info.server_error"));
        },
        always: function always() {
          _this.loading = false;
        }
      });
    });
  },
  beforeDestroy: function beforeDestroy() {
    $('#' + this.mediaid).fileupload('destroy');
  }
});

module.exports = MediaInput;

},{"../service":729,"./media.html":730,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/fields/fields":693,"gui/gui":710,"gui/inputs/input":724}],732:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var PickFeatureInteraction = require('g3w-ol3/src/interactions/pickfeatureinteraction');
var GUI = require('gui/gui');

function PickLayerService() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._layersfields = options.layers || [];
  this._mapService = GUI.getComponent('map').getService();
  var layers = this._layersfields.map(function (option) {
    return _this._mapService.getLayerById(option.layer);
  });
  this._interaction = new PickFeatureInteraction({
    layers: layers
  });
}

var proto = PickLayerService.prototype;

proto.pick = function () {
  var _this2 = this;

  return new _promise2.default(function (resolve, reject) {
    GUI.setModal(false);
    _this2._mapService.addInteraction(_this2._interaction);
    _this2._interaction.once('picked', function (event) {
      var layerId = event.layer.get('id');
      var feature = event.feature;

      var _layersfields$find = _this2._layersfields.find(function (layerfield) {
        return layerfield.layer === layerId;
      }),
          field = _layersfields$find.field;

      var value = feature.getProperties()[field];
      _this2.unpick();
      resolve(value);
    });
  });
};

proto.unpick = function () {
  this._mapService.removeInteraction(this._interaction);
  GUI.setModal(true);
};

proto.clear = function () {
  this.unpick();
  this._mapService = this._interaction = this._field = null;
};

module.exports = PickLayerService;

},{"babel-runtime/core-js/promise":16,"g3w-ol3/src/interactions/pickfeatureinteraction":671,"gui/gui":710}],733:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div slot=\"body\">\n    <span style=\"left: 0; top: 7px; position: absolute\"  :class=\"g3wtemplate.font['crosshairs']\" class=\"skin-color\"></span>\n    <input\n      @input=\"change\"\n      @click=\"pickLayer\"\n      @blur=\"unpick\"\n      style=\"width: 100%;\"\n      :style=\"{cursor: isEditable() ? 'pointer': null}\"\n      class=\"form-control\"\n      readonly=\"readonly\"\n      v-disabled=\"!isEditable()\"\n      :class=\"{'input-error-validation' : notvalid}\"\n      v-model=\"state.value\">\n  </div>\n</baseinput>\n";

},{}],734:[function(require,module,exports){
var Input = require('gui/inputs/input');
var Service = require('../service');

var PickLayerInput = Vue.extend({
  mixins: [Input],
  template: require('./picklayer.html'),
  methods: {
    pickLayer: function pickLayer() {
      var _this = this;

      this.pickservice.pick().then(function (value) {
        _this.state.value = value;
      });
    },
    unpick: function unpick() {
      var _this2 = this;

      setTimeout(function () {
        _this2.pickservice.unpick();
      }, 200);
    }
  },
  created: function created() {
    this.pickservice = new Service(this.state.input.options);
  },
  beforeDestroy: function beforeDestroy() {
    this.pickservice.clear();
    this.pickservice = null;
  }
});

module.exports = PickLayerInput;

},{"../service":732,"./picklayer.html":733,"gui/inputs/input":724}],735:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function RadioService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
}

inherit(RadioService, Service);

module.exports = RadioService;

},{"core/utils/utils":630,"gui/inputs/service":745}],736:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div slot=\"body\">\n    <template v-for=\"(value, index) in state.input.options.values\" :key=\"value.key\">\n      <input\n        :id=\"ids[index]\"\n        :name=\"name\"\n        :value=\"value.value\"\n        style=\"width:100%\"\n        v-disabled=\"!isEditable()\"\n        :class=\"{'input-error-validation' : notvalid}\"\n        class=\"magic-radio\"\n        v-model=\"radio_value\"\n        type=\"radio\">\n      <label :for=\"ids[index]\">{{ value.key }}</label>\n    </template>\n  </div>\n</baseinput>\n";

},{}],737:[function(require,module,exports){
var Input = require('gui/inputs/input');
var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
var Service = require('../service');

var RadioInput = Vue.extend({
  mixins: [Input],
  data: function data() {
    return {
      service: new Service({
        state: this.state
      }),
      ids: [getUniqueDomId(), getUniqueDomId()],
      name: 'name_' + getUniqueDomId(),
      radio_value: this.state.value
    };
  },
  watch: {
    'radio_value': function radio_value() {
      this.state.value = this.radio_value;
      this.change();
    }
  },
  template: require('./radio.html')
});

module.exports = RadioInput;

},{"../service":735,"./radio.html":736,"core/utils/utils":630,"gui/inputs/input":724}],738:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');
var ValidatorClass = require('core/validators/inputs/range');

function RangeService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  var _options$state$input$ = options.state.input.options.values[0],
      min = _options$state$input$.min,
      max = _options$state$input$.max;

  var validator = new ValidatorClass({
    min: 1 * min,
    max: 1 * max
  });
  this.setValidator(validator);
}

inherit(RangeService, Service);

var proto = Service.prototype;

proto.isValueInRange = function (value, min, max) {
  return value <= max && value >= min;
};

module.exports = RangeService;

},{"core/utils/utils":630,"core/validators/inputs/range":636,"gui/inputs/service":745}],739:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n    <input\n      slot=\"body\"\n      @keydown.69.prevent=\"\"\n      @keydown.13.stop=\"\"\n      @change=\"checkValue\"\n      @blur=\"checkValue\"\n      style=\"width:100%; padding-right: 5px;\"\n      class=\"form-control\"\n      v-disabled=\"!isEditable()\"\n      :class=\"{'input-error-validation' : notvalid}\"\n      v-model=\"state.value\"\n      type=\"number\"\n      :step=\"step\">\n</baseinput>\n";

},{}],740:[function(require,module,exports){
var Input = require('gui/inputs/input');
var Service = require('../service');

var RangeInput = Vue.extend({
  mixins: [Input],
  template: require('./range.html'),
  data: function data() {
    var options = this.state.input.options.values[0];
    var min = 1 * options.min;
    var max = 1 * options.max;
    var step = 1 * options.Step;
    return {
      max: max,
      min: min,
      step: step,
      service: new Service({
        state: this.state
      })
    };
  },

  methods: {
    checkValue: function checkValue() {
      this.change();
    }
  },
  created: function created() {
    this.service.setValue(this.state.value);
    this.state.info = '(min: ' + this.min + ' - max: ' + this.max + ')';
  }
});

module.exports = RangeInput;

},{"../service":738,"./range.html":739,"gui/inputs/input":724}],741:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var CatalogLayersStoresRegistry = require('core/catalog/cataloglayersstoresregistry');
var Service = require('gui/inputs/service');

function SelectService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.layer = null;
}

inherit(SelectService, Service);

var proto = SelectService.prototype;

proto._getLayerById = function (layer_id) {
  return CatalogLayersStoresRegistry.getLayerById(layer_id);
};

proto.addValue = function (value) {
  this.state.input.options.values.push(value);
};

proto.getKeyByValue = function () {
  var _this = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      search = _ref.search;

  var options = this.state.input.options;
  var value = options.value,
      key = options.key;

  this.getData({
    key: value,
    value: key,
    search: search
  }).then(function (arrayValues) {
    var _arrayValues = (0, _slicedToArray3.default)(arrayValues, 1),
        _value = _arrayValues[0];

    var key = _value.$value,
        value = _value.text;

    _this.addValue({
      key: key,
      value: value
    });
  }).catch(function (err) {
    console.log(err);
  });
};

proto.getData = function () {
  var _this2 = this;

  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref2$layer_id = _ref2.layer_id,
      layer_id = _ref2$layer_id === undefined ? this.state.input.options.layer_id : _ref2$layer_id,
      _ref2$key = _ref2.key,
      key = _ref2$key === undefined ? this.state.input.options.key : _ref2$key,
      _ref2$value = _ref2.value,
      value = _ref2$value === undefined ? this.state.input.options.value : _ref2$value,
      search = _ref2.search;

  var search_value = (key + '|' + search).trim();
  return new _promise2.default(function (resolve, reject) {
    if (!_this2._layer) {
      _this2._layer = _this2._getLayerById(layer_id);
    }
    _this2._layer.getDataTable({
      suggest: search_value,
      ordering: key
    }).then(function (response) {
      var relationLayerPk = response.pkField;
      var isKeyPk = relationLayerPk === key;
      var isValuePk = relationLayerPk === value;
      var values = [];
      var features = response.features;
      for (var i = 0; i < features.length; i++) {
        values.push({
          text: isKeyPk ? features[i].id : features[i].properties[key],
          id: i,
          $value: isValuePk ? features[i].id : features[i].properties[value]
        });
      }
      resolve(values);
    }).fail(function (err) {
      reject(err);
    });
  });
};

module.exports = SelectService;

},{"babel-runtime/core-js/promise":16,"babel-runtime/helpers/slicedToArray":23,"core/catalog/cataloglayersstoresregistry":561,"core/utils/utils":630,"gui/inputs/service":745}],742:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <div style=\"position:relative; width: 100%\" slot=\"loading\" v-if=\"loadingState === 'loading'\">\n    <bar-loader loading=\"true\"></bar-loader>\n  </div>\n  <select\n    style=\"width:100%;\"\n    slot=\"body\"\n    v-disabled=\"!isEditable() || loadingState === 'loading' || loadingState === 'error'\"\n    class=\"form-control\" >\n    <option :value=\"getValue(value.value)\" v-for=\"value in state.input.options.values\">{{ value.key }}</option>\n  </select>\n  <p v-if=\"loadingState === 'error'\" class=\"error-input-message\" slot=\"message\" v-t=\"'server_error'\"></p>\n</baseinput>\n";

},{}],743:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');
var selectMixin = require('./selectmixin');
var Service = require('../service');

var SelectInput = Vue.extend({
  mixins: [Input, selectMixin],
  data: function data() {
    return {
      service: new Service({
        state: this.state
      })
    };
  },
  template: require('./select.html'),
  watch: {
    'state.input.options.values': function stateInputOptionsValues(values) {
      if (!this.autocomplete && !this.state.value && values.length) this.changeSelect(values[0].value);
    }
  },
  created: function created() {
    this.autocomplete && this.state.value && this.service.getKeyByValue({ search: this.state.value });
    if (!this.state.value) this.state.value = this.state.input.options.values.length ? this.state.input.options.values[0].value : null;
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var selectElement = $(_this.$el).find('select');
      var language = _this.getLanguage();
      if (_this.autocomplete) {
        _this.select2 = selectElement.select2({
          minimumInputLength: 1,
          language: language,
          ajax: {
            delay: 250,
            transport: function transport(params, success, failure) {
              var search = params.data.term;
              // hide previous result if present
              $('.select2-results__option.loading-results').siblings().hide();
              _this.resetValues();
              _this.service.getData({
                search: search
              }).then(function (values) {
                success(values);
              }).catch(function (err) {
                failure(err);
              });
            },
            processResults: function processResults(data, params) {
              params.page = params.page || 1;
              return {
                results: data,
                pagination: {
                  more: false
                }
              };
            }
          }
        });
      } else {
        _this.select2 = selectElement.select2({
          language: language
        });
      }
      _this.state.value && _this.select2.val(_this.state.value).trigger('change');
      _this.select2.on('select2:select', function (event) {
        var value = event.params.data.$value ? event.params.data.$value : event.params.data.id;
        _this.changeSelect(value);
      });
    });
  }
});

module.exports = SelectInput;

},{"../service":741,"./select.html":742,"./selectmixin":744,"gui/inputs/input":724}],744:[function(require,module,exports){
var getAppLanguage = require('core/i18n/i18n.service').getAppLanguage;
var selectMixin = {
  methods: {
    getLanguage: function getLanguage() {
      return getAppLanguage();
    },

    changeSelect: function changeSelect(value) {
      this.state.value = value === 'null' ? null : value;
      this.change();
    },
    getValue: function getValue(value) {
      return value === null ? 'null' : value;
    },
    resetValues: function resetValues() {
      this.state.input.options.values.splice(0);
    }
  },
  computed: {
    autocomplete: function autocomplete() {
      return this.state.input.type === 'select_autocomplete' && this.state.input.options.usecompleter;
    },
    loadingState: function loadingState() {
      return this.state.input.options.loading ? this.state.input.options.loading.state : null;
    }
  },
  watch: {
    notvalid: function notvalid(value) {
      var _this = this;

      this.$nextTick(function () {
        if (_this.select2) value ? _this.select2.data('select2').$container.addClass("input-error-validation") : _this.select2.data('select2').$container.removeClass("input-error-validation");
      });
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.select2 && this.select2.select2('destroy');
    this.select2 = null;
  }
};

module.exports = selectMixin;

},{"core/i18n/i18n.service":572}],745:[function(require,module,exports){
var Validators = require('core/validators/inputs/validators');
var t = require('core/i18n/i18n.service').t;

function Service() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  // set state of input
  this.state = options.state || {};
  // type of input
  this.setValue(this.state.value);
  var type = this.state.type;
  var validatorOptions = options.validatorOptions || this.state.input.options || {};
  // useful for the validator to validate input
  this._validator = Validators.get(type, validatorOptions);
}

var proto = Service.prototype;

proto.getState = function () {
  return this.state;
};

proto.getValue = function () {
  return this.state.value;
};

proto.setValue = function (value) {
  if (value === null || value === undefined) {
    this.state.value = Array.isArray(this.state.input.options) ? this.state.input.options[0].default : Array.isArray(this.state.input.options.values) && this.state.input.options.values.length ? this.state.input.options.values[0] && this.state.input.options.values[0].value || this.state.input.options.values[0] : this.state.input.options.default;
  }
};

proto.addValueToValues = function (value) {
  this.state.input.options.values.unshift(value);
};

proto._getValidatorType = function () {
  return this.state.type;
};

proto.setState = function (state) {
  this.state = _.isObject(state) ? state : {};
};

// return validator
proto.getValidator = function () {
  return this._validator;
};

proto.setValidator = function (validator) {
  this._validator = validator;
};

// general method to check the value of the state is valid or not
proto.validate = function () {
  if (Array.isArray(this.state.value) && this.state.value.length || !_.isEmpty(_.trim(this.state.value))) {
    this.state.validate.empty = false;
    if (this.state.input.type === 'integer' || this.state.input.type === 'float') {
      if (+this.state.value < 0) {
        this.state.value = null;
        this.state.validate.empty = true;
        this.state.validate.valid = !this.state.validate.required;
      } else this.state.validate.valid = this._validator.validate(this.state.value);
    }
    if (this.state.validate.exclude_values && this.state.validate.exclude_values.length) {
      if (this.state.validate.exclude_values.indexOf(this.state.value) !== -1) {
        this.state.validate.valid = false;
        this.state.validate.unique = false;
      } else this.state.validate.unique = true;
    } else this.state.validate.valid = this._validator.validate(this.state.value);
  } else {
    this.state.validate.empty = true;
    this.state.value = null;
    this.state.validate.unique = true;
    // check if require or check validation
    this.state.validate.valid = this.state.validate.required ? false : this._validator.validate(this.state.value);
  }
  return this.state.validate.valid;
};

proto.getErrorMessage = function (input) {
  if (input.validate.mutually) return t("sdk.form.inputs.input_validation_mutually_exclusive") + ' ( ' + input.validate.mutually.join(',') + ' )';else if (input.validate.max_field) return t("sdk.form.inputs.input_validation_max_field") + ' (' + input.validate.max_field + ')';else if (input.validate.min_field) return t("sdk.form.inputs.input_validation_min_field") + ' (' + input.validate.min_field + ')';else if (!input.validate.unique && input.validate.exclude_values) return '' + t("sdk.form.inputs.input_validation_exclude_values");else if (input.validate.required) {
    var message = t("sdk.form.inputs.input_validation_error") + ' ( ' + t("sdk.form.inputs." + input.type) + ' )';
    if (this.state.info) {
      message = message + '\n                 <div>\n                  <b>' + this.state.info + '</b>\n                 </div>         \n      ';
    }
    this.state.validate.message = message;
  } else {
    this.state.validate.message = this.state.info;
  }
};

proto.isEditable = function () {
  return this.state.editable;
};

module.exports = Service;

},{"core/i18n/i18n.service":572,"core/validators/inputs/validators":638}],746:[function(require,module,exports){
// oggetto base utilizzato per i mixins
var Input = require('gui/inputs/input');

var TextInput = Vue.extend({
  mixins: [Input]
});

module.exports = TextInput;

},{"gui/inputs/input":724}],747:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <textarea\n    @input=\"change\"\n    @change=\"change\"\n    slot=\"body\"\n    style=\"max-width: 100%; min-width: 100%\"\n    v-disabled=\"!isEditable()\"\n    :class=\"{'input-error-validation' : notvalid}\"\n    v-model=\"state.value\"></textarea>\n</baseinput>\n";

},{}],748:[function(require,module,exports){
var Input = require('gui/inputs/input');

var TextAreaInput = Vue.extend({
  mixins: [Input],
  template: require('./textarea.html')
});

module.exports = TextAreaInput;

},{"./textarea.html":747,"gui/inputs/input":724}],749:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Service = require('gui/inputs/service');

function UniqueService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
}

inherit(UniqueService, Service);

module.exports = UniqueService;

},{"core/utils/utils":630,"gui/inputs/service":745}],750:[function(require,module,exports){
module.exports = "<baseinput :state=\"state\">\n  <select\n    :id=\"id\"\n    slot=\"body\"\n    style=\"width:100%\"\n    v-disabled=\"!isEditable()\"\n    class=\"form-control\">\n    <option value=\"null\"></option>\n    <option :value=\"getValue(value)\" v-for=\"value in state.input.options.values\" :key=\"value\">{{ getValue(value) }}</option>\n  </select>\n</baseinput>\n";

},{}],751:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Input = require('gui/inputs/input');
var selectMixin = require('gui/inputs/select/vue/selectmixin');
var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
var Service = require('../service');

var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./unique.html'));

var UniqueInput = Vue.extend((0, _extends3.default)({
  mixins: [Input, selectMixin]
}, compiledTemplate, {
  data: function data() {
    var id = 'unique_' + getUniqueDomId();
    return {
      service: new Service({
        state: this.state
      }),
      id: id
    };
  },
  watch: {
    'state.input.options.values': function stateInputOptionsValues(values) {
      var _this = this;

      this.state.value = this.state.value ? this.state.value : null;
      values.indexOf(this.state.value) === -1 && this.service.addValueToValues(this.state.value);
      this.$nextTick(function () {
        _this.state.value && _this.select2.val(_this.state.value).trigger('change');
      });
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      if (_this2.state.input.options.editable) {
        _this2.select2 = $('#' + _this2.id).select2({
          tags: true,
          language: _this2.getLanguage()
        });
        _this2.select2.on('select2:select', function (event) {
          var value = event.params.data.$value ? event.params.data.$value : event.params.data.id;
          _this2.changeSelect(value);
        });
      }
    });
  }
}));

module.exports = UniqueInput;

},{"../service":749,"./unique.html":750,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/inputs/input":724,"gui/inputs/select/vue/selectmixin":744,"gui/vue/utils":812}],752:[function(require,module,exports){
var WidgetMixins = {
  data: function data() {
    return {
      changed: false
    };
  },

  methods: {
    widgetChanged: function widgetChanged() {
      this.changed = true;
      this.change();
    },
    stateValueChanged: function stateValueChanged(value) {
      console.log('need to be implemented by widget'); // method to overwrite
    }
  },
  watch: {
    'state.value': function stateValue(value) {
      this.changed ? this.changed = false : this.stateValueChanged(value);
    }
  }
};

module.exports = WidgetMixins;

},{}],753:[function(require,module,exports){
var ResetControl = require('g3w-ol3/src/controls/resetcontrol');
var QueryControl = require('g3w-ol3/src/controls/querycontrol');
var ZoomBoxControl = require('g3w-ol3/src/controls/zoomboxcontrol');
var QueryBBoxControl = require('g3w-ol3/src/controls/querybboxcontrol');
var QueryByPolygonControl = require('g3w-ol3/src/controls/querybypolygoncontrol');
var GeolocationControl = require('g3w-ol3/src/controls/geolocationcontrol');
var StreetViewControl = require('g3w-ol3/src/controls/streetviewcontrol');
var AddLayersControl = require('g3w-ol3/src/controls/addlayers');
var LengthControl = require('g3w-ol3/src/controls/lengthcontrol');
var AreaControl = require('g3w-ol3/src/controls/areacontrol');
var Control = require('g3w-ol3/src/controls/control');
var OLControl = require('g3w-ol3/src/controls/olcontrol');
var NominatimControl = require('g3w-ol3/src/controls/nominatimcontrol');
var MousePositionControl = require('g3w-ol3/src/controls/mousepositioncontrol');
var ScaleControl = require('g3w-ol3/src/controls/scalecontrol');
var OnClikControl = require('g3w-ol3/src/controls/onclickcontrol');
var ScreenshotControl = require('g3w-ol3/src/controls/screenshotcontrol');

var ControlsFactory = {
  create: function create() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var control = void 0;
    var ControlClass = ControlsFactory.CONTROLS[options.type];
    if (ControlClass) {
      control = new ControlClass(options);
    }
    var visible = control instanceof Control && control.isVisible ? control.isVisible() : true;
    return visible ? control : null;
  }
};

ControlsFactory.CONTROLS = {
  'reset': ResetControl,
  'zoombox': ZoomBoxControl,
  'zoomtoextent': OLControl,
  'query': QueryControl,
  'querybbox': QueryBBoxControl,
  'querybypolygon': QueryByPolygonControl,
  'geolocation': GeolocationControl,
  'streetview': StreetViewControl,
  'zoom': OLControl,
  'scaleline': OLControl,
  'overview': OLControl,
  'nominatim': NominatimControl,
  'addlayers': AddLayersControl,
  'length': LengthControl,
  'area': AreaControl,
  'mouseposition': MousePositionControl,
  'scale': ScaleControl,
  'onclick': OnClikControl,
  'screenshot': ScreenshotControl
};

module.exports = ControlsFactory;

},{"g3w-ol3/src/controls/addlayers":645,"g3w-ol3/src/controls/areacontrol":646,"g3w-ol3/src/controls/control":647,"g3w-ol3/src/controls/geolocationcontrol":648,"g3w-ol3/src/controls/lengthcontrol":650,"g3w-ol3/src/controls/mousepositioncontrol":652,"g3w-ol3/src/controls/nominatimcontrol":653,"g3w-ol3/src/controls/olcontrol":654,"g3w-ol3/src/controls/onclickcontrol":655,"g3w-ol3/src/controls/querybboxcontrol":656,"g3w-ol3/src/controls/querybypolygoncontrol":657,"g3w-ol3/src/controls/querycontrol":658,"g3w-ol3/src/controls/resetcontrol":659,"g3w-ol3/src/controls/scalecontrol":660,"g3w-ol3/src/controls/screenshotcontrol":661,"g3w-ol3/src/controls/streetviewcontrol":662,"g3w-ol3/src/controls/zoomboxcontrol":664}],754:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');

function ControlsRegistry() {

  this._controls = {};
  this.setters = {
    registerControl: function registerControl(id, control) {
      this._registerControl(id, control);
    }
  };

  this._registerControl = function (id, control) {
    this._controls[id] = control;
  };

  this.getControl = function (id) {
    return this._controls[id];
  };

  this.getControls = function () {
    return this._controls;
  };

  this.unregisterControl = function (id) {
    var control = this.getControl(id);
    var mapService = GUI.getComponet('map').getService();
    var map = mapService.getMap();
    if (control) {
      map.removeControl(control);
      delete this._controls[id];
      return true;
    }
    return false;
  };
  base(this);
}

inherit(ControlsRegistry, G3WObject);

module.exports = new ControlsRegistry();

},{"core/g3wobject":569,"core/utils/utils":630,"gui/gui":710}],755:[function(require,module,exports){
var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var t = require('core/i18n/i18n.service').t;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');

var _require = require('core/utils/geo'),
    shpToGeojson = _require.shpToGeojson,
    createSelectedStyle = _require.createSelectedStyle,
    getQueryLayersPromisesByCoordinates = _require.getQueryLayersPromisesByCoordinates,
    getQueryLayersPromisesByGeometry = _require.getQueryLayersPromisesByGeometry,
    getMapLayersByFilter = _require.getMapLayersByFilter;

var GUI = require('gui/gui');
var ApplicationService = require('core/applicationservice');
var ProjectsRegistry = require('core/project/projectsregistry');
var MapLayersStoreRegistry = require('core/map/maplayersstoresregistry');
var Filter = require('core/layers/filter/filter');
var WFSProvider = require('core/layers/providers/wfsprovider');
var ol3helpers = require('g3w-ol3/src/g3w.ol3').helpers;

var _require2 = require('g3w-ol3/src/utils/utils'),
    getScaleFromResolution = _require2.getScaleFromResolution,
    getResolutionFromScale = _require2.getResolutionFromScale;

var ControlsFactory = require('gui/map/control/factory');
var StreetViewService = require('gui/streetview/streetviewservice');
var ControlsRegistry = require('gui/map/control/registry');
var VectorLayer = require('core/layers/vectorlayer');
var debounce = require('core/utils/utils').debounce;
var throttle = require('core/utils/utils').throttle;
var SETTINGS = {
  zoom: {
    maxScale: 2000
  },
  animation: {
    duration: 2000
  }
};

function MapService() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.id = 'MapService';
  this.viewer = null;
  this.target = options.target || null;
  this.maps_container = options.maps_container || null;
  this._layersStoresEventKeys = {};
  this.project = null;
  this._mapControls = [];
  this._mapLayers = [];
  this.mapBaseLayers = {};
  this.layersExtraParams = {};
  this.state = {
    mapUnits: 'm',
    bbox: [],
    hidemaps: [],
    resolution: null,
    center: null,
    loading: false,
    hidden: true,
    scale: 0,
    mapcontrolsalignement: 'rv',
    mapcontrolDOM: null,
    mapcontrolready: false,
    mapcontrolSizes: {
      height: 47,
      width: 47,
      minWidth: 47,
      minHeight: 47
    },
    mapControl: {
      grid: [],
      length: 0,
      currentIndex: 0,
      update: true
    }
  };

  this._greyListenerKey = null;
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
  this.config = options.config || ApplicationService.getConfig();
  this._howManyAreLoading = 0;
  this._layersLoadingError = false;
  // function to show spinner layers
  this._incrementLoaders = function () {
    if (_this._howManyAreLoading === 0) {
      _this.emit('loadstart');
      GUI.showSpinner({
        container: $('#map-spinner'),
        id: 'maploadspinner',
        style: 'transparent'
      });
    }
    _this._howManyAreLoading += 1;
  };

  this._decrementLoaders = function () {
    _this._howManyAreLoading -= 1;
    if (_this._howManyAreLoading === 0) {
      _this.emit('loadend');
      GUI.hideSpinner('maploadspinner');
    }
  };

  this._mapLayerLoadError = function () {
    if (!_this._layersLoadingError) {
      GUI.notify.warning(t('sdk.errors.layers.load'));
      _this._layersLoadingError = true;
    }
    _this._decrementLoaders();
  };

  if (options.project) this.project = options.project;else {
    this.project = ProjectsRegistry.getCurrentProject();
    //on after setting current project
    ProjectsRegistry.onafter('setCurrentProject', function (project) {
      _this.removeLayers();
      _this._removeListeners();
      _this.project = project;
      var changeProjectCallBack = function changeProjectCallBack() {
        _this._resetView();
        _this._setupMapLayers();
        _this._setupVectorLayers();
        _this.viewer.map.getView().on("change:resolution", function (evt) {
          _this._updateMapView();
        });
      };
      ApplicationService.isIframe() && changeProjectCallBack();
      _this.getMap().once('change:size', changeProjectCallBack);
    });
  }
  this._setupListeners();
  this._marker = null;

  this.setters = {
    setupControls: function setupControls() {
      return this._setupControls();
    },

    addHideMap: function addHideMap() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          ratio = _ref.ratio,
          _ref$layers = _ref.layers,
          layers = _ref$layers === undefined ? [] : _ref$layers,
          _ref$mainview = _ref.mainview,
          mainview = _ref$mainview === undefined ? false : _ref$mainview,
          _ref$switchable = _ref.switchable,
          switchable = _ref$switchable === undefined ? false : _ref$switchable;

      var id = 'hidemap_' + Date.now();
      var idMap = {
        id: id,
        map: null,
        switchable: switchable
      };
      this.state.hidemaps.push(idMap);
      return idMap;
    },
    updateMapView: function updateMapView(bbox, resolution, center) {
      this.state.bbox = bbox;
      this.state.resolution = resolution;
      this.state.center = center;
      this.updateMapLayers();
    },
    setHidden: function setHidden(bool) {
      this.state.hidden = bool;
    },
    setupViewer: function setupViewer(width, height) {
      var _this2 = this;

      if (width === 0 || height === 0) {
        return;
      }
      if (this.viewer) {
        this.viewer.destroy();
        this.viewer = null;
      }
      this._setupViewer(width, height);
      this.state.bbox = this.viewer.getBBOX();
      this.state.resolution = this.viewer.getResolution();
      this.state.center = this.viewer.getCenter();
      this._setupAllLayers();
      this.setupControls();
      // set change resolution
      this.viewer.map.getView().on("change:resolution", function (evt) {
        _this2._updateMapView();
      });
      this.emit('viewerset');
    },
    controlClick: function controlClick(active) {
      //SETTER to register map control activated
    }
  };

  this._onCatalogSelectLayer = function (layer) {
    var _this3 = this;

    if (layer) {
      var geometryType = layer.getGeometryType();
      var querable = layer.isQueryable();

      var _loop = function _loop(i) {
        var mapcontrol = _this3._mapControls[i];
        if (mapcontrol.control._onSelectLayer) {
          if (mapcontrol.control.getGeometryTypes().indexOf(geometryType) !== -1) {
            mapcontrol.control.setEnable(querable ? layer.isVisible() : querable);
            // listen changes
            querable && _this3.on('cataloglayertoggled', function (_toggledLayer) {
              if (layer === _toggledLayer) mapcontrol.control.setEnable(layer.isVisible());
            });
          } else mapcontrol.control.setEnable(false);
        }
      };

      for (var i = 0; i < this._mapControls.length; i++) {
        _loop(i);
      }
    }
  };

  this.on('cataloglayerselected', this._onCatalogSelectLayer);

  this._onCatalogUnSelectLayer = function () {
    for (var i = 0; i < this._mapControls.length; i++) {
      var _mapcontrol = this._mapControls[i];
      _mapcontrol.control._onSelectLayer && _mapcontrol.control.setEnable(false);
      this.removeAllListeners('cataloglayertoggled');
    }
  };

  this.on('cataloglayerunselected', this._onCatalogUnSelectLayer);

  this.on('extraParamsSet', function (extraParams, update) {
    update && _this.getMapLayers().forEach(function (mapLayer) {
      mapLayer.update(_this.state, extraParams);
    });
  });

  //CHECK IF MAPLAYESRSTOREREGISTRY HAS LAYERSTORE
  MapLayersStoreRegistry.getLayersStores().forEach(function (layersStore) {
    _this._setUpEventsKeysToLayersStore(layersStore);
  });

  // LISTEN ON EVERY ADDED LAYERSSTORE
  MapLayersStoreRegistry.onafter('addLayersStore', function (layersStore) {
    _this._setUpEventsKeysToLayersStore(layersStore);
  });

  // LISTENER ON REMOVE LAYERSTORE
  MapLayersStoreRegistry.onafter('removeLayersStore', function (layerStore) {
    _this._removeEventsKeysToLayersStore(layerStore);
  });
  base(this);
}

inherit(MapService, G3WObject);

var proto = MapService.prototype;

proto.getScaleFromExtent = function (extent) {
  var resolution = this.getMap().getView().getResolutionForExtent(extent, this.getMap().getSize());
  var scale = getScaleFromResolution(resolution, this.getMapUnits());
  return scale;
};

proto._addHideMap = function () {
  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      ratio = _ref2.ratio,
      _ref2$layers = _ref2.layers,
      layers = _ref2$layers === undefined ? [] : _ref2$layers,
      _ref2$mainview = _ref2.mainview,
      mainview = _ref2$mainview === undefined ? false : _ref2$mainview;

  var idMap = this.state.hidemaps[this.state.hidemaps.length - 1];
  var view = this.getMap().getView();
  var view_options = {
    projection: view.getProjection(),
    center: view.getCenter(),
    resolution: this.getResolution()
  };
  var viewer = ol3helpers.createViewer({
    id: idMap.id,
    view: mainview ? view : view_options
  });
  // set Map
  idMap.map = viewer.getMap();
  // in case of rate
  if (ratio) {
    var _idMap$map$getSize = idMap.map.getSize(),
        _idMap$map$getSize2 = (0, _slicedToArray3.default)(_idMap$map$getSize, 2),
        width = _idMap$map$getSize2[0],
        height = _idMap$map$getSize2[1];

    idMap.map.setSize([width, width * ratio]);
  }

  for (var i = 0; i < layers.length; i++) {
    var layer = layers[i];
    idMap.map.addLayer(layer);
  }
  return idMap.map;
};

proto.removeHideMap = function (id) {
  var index = void 0;
  for (var i = 0; i < this.state.hidemaps.length; i++) {
    if (id === this.state.hidemaps[i].id) {
      index = i;
      break;
    }
  }
  index !== undefined && this.state.hidemaps.splice(index, 1);
};

proto._showHideMapElement = function () {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      map = _ref3.map,
      _ref3$show = _ref3.show,
      show = _ref3$show === undefined ? false : _ref3$show;

  show ? $(map.getTargetElement()).addClass('show') : $(map.getTargetElement()).removeClass('show');
};

proto.createMapImage = function () {
  var _this4 = this;

  var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      map = _ref4.map,
      background = _ref4.background;

  return new _promise2.default(function (resolve, reject) {
    try {
      var canvas = _this4.getMapCanvas(map);
      if (navigator.msSaveBlob) {
        resolve(canvas.msToBlob());
      } else {
        canvas.toBlob(function (blob) {
          resolve(blob);
        });
      }
    } catch (err) {
      reject(err);
    }
  });
};

proto.getApplicationAttribution = function () {
  var _config$group = this.config.group,
      header_terms_of_use_link = _config$group.header_terms_of_use_link,
      header_terms_of_use_text = _config$group.header_terms_of_use_text;

  if (header_terms_of_use_text) {
    return '<a href="' + header_terms_of_use_link + '">' + header_terms_of_use_text + '</a>';
  } else return false;
};

proto.slaveOf = function (mapService, sameLayers) {
  sameLayers = sameLayers || false;
};

proto.setLayersExtraParams = function (params, update) {
  this.layersExtraParams = _.assign(this.layersExtraParams, params);
  this.emit('extraParamsSet', params, update);
};

proto.getProject = function () {
  return this.project;
};

proto.getMap = function () {
  try {
    return this.viewer.map;
  } catch (err) {
    console.log(err);
    console.log(arguments.callee.caller);
  }
};

proto.getMapCanvas = function (map) {
  var viewport = map ? map.getViewport() : $('#' + this.maps_container + ' .g3w-map').last().children('.ol-viewport')[0];
  return $(viewport).children('canvas')[0];
};

proto.getProjection = function () {
  return this.project.getProjection();
};

proto.isAxisOrientationInverted = function () {
  return this.getProjection().getAxisOrientation() === 'neu' ? true : false;
};

proto.getCrs = function () {
  return this.getProjection().getCode();
};

proto.getViewerElement = function () {
  return this.viewer.map.getTargetElement();
};

proto.getViewport = function () {
  return this.viewer.map.getViewport();
};

proto.getResolution = function () {
  return this.viewer.map.getView().getResolution();
};

proto.getEpsg = function () {
  return this.viewer.map.getView().getProjection().getCode();
};

proto.getGetFeatureInfoUrlForLayer = function (layer, coordinates, resolution, epsg, params) {
  var mapLayer = this.getMapLayerForLayer(layer);
  return mapLayer.getGetFeatureInfoUrl(coordinates, resolution, epsg, params);
};

proto.showMarker = function (coordinates) {
  var _this5 = this;

  var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

  this._marker.setPosition(coordinates);
  setTimeout(function () {
    _this5._marker.setPosition();
  }, duration);
};

// return layer by name
proto.getLayerByName = function (name) {
  var layer = this.getMap().getLayers().getArray().find(function (lyr) {
    var layerName = lyr.get('name');
    return layerName && layerName === name;
  });
  return layer;
};

// return layer by id
proto.getLayerById = function (id) {
  return this.getMap().getLayers().getArray().find(function (layer) {
    return layer.get('id') === id;
  });
};

// method do get all feature from vector layer based on coordinates
proto.getVectorLayerFeaturesFromCoordinates = function (layerId, coordinates) {
  var intersectGeom = void 0;
  var features = [];
  var map = this.getMap();
  var vectorLayer = this.getLayerById(layerId);
  if (Array.isArray(coordinates)) {
    if (coordinates.length === 2) {
      var pixel = map.getPixelFromCoordinate(coordinates);
      map.forEachFeatureAtPixel(pixel, function (feature) {
        features.push(feature);
      }, {
        layerFilter: function layerFilter(layer) {
          return layer === vectorLayer;
        }
      });
    } else if (coordinates.length === 4) {
      intersectGeom = ol.geom.Polygon.fromExtent(coordinates);
      switch (vectorLayer.constructor) {
        case VectorLayer:
          features = vectorLayer.getIntersectedFeatures(intersectGeom);
          break;
        case ol.layer.Vector:
          vectorLayer.getSource().getFeatures().forEach(function (feature) {
            if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
              features.push(feature);
            }
          });
          break;
      }
    }
  } else if (coordinates instanceof ol.geom.Polygon || coordinates instanceof ol.geom.MultiPolygon) {
    intersectGeom = coordinates;
    switch (vectorLayer.constructor) {
      case VectorLayer:
        features = vectorLayer.getIntersectedFeatures(intersectGeom);
        break;
      case ol.layer.Vector:
        vectorLayer.getSource().getFeatures().forEach(function (feature) {
          if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
            features.push(feature);
          }
        });
        break;
    }
  }
  return features;
};

proto.getQueryLayerByCoordinates = function () {
  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      layer = _ref5.layer,
      coordinates = _ref5.coordinates;

  var mapProjection = this.getProjection();
  var resolution = this.getResolution();
  return new _promise2.default(function (resolve, reject) {
    layer.query({
      coordinates: coordinates,
      mapProjection: mapProjection,
      resolution: resolution
    }).then(function (response) {
      resolve(response);
    }).fail(function (err) {
      reject(err);
    });
  });
};

proto.getQueryLayerPromiseByCoordinates = function () {
  var _this6 = this;

  var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      layer = _ref6.layer,
      coordinates = _ref6.coordinates;

  return new _promise2.default(function (resolve, reject) {
    var mapProjection = _this6.getProjection();
    var resolution = _this6.getResolution();
    layer.query({
      coordinates: coordinates,
      mapProjection: mapProjection,
      resolution: resolution
    }).then(function (response) {
      resolve(response);
    }).fail(function (error) {
      reject(error);
    });
  });
};

//setup controls
/*
  layout : {
    lv: <options> h : horizontal (default), v vertical
    lh: <options> h: horizontal: v vertical (default)
  }
 */

proto.activeMapControl = function (controlName) {
  var mapControl = this._mapControls.find(function (control) {
    return control.type === controlName;
  });
  var control = mapControl.control;
  !control.isToggled() ? control.toggle() : null;
};

proto.createMapControl = function (type) {
  var _ref7, _ref7$add, _ref7$toggled, _ref7$visible, _ref7$options;

  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (_ref7 = {}, _ref7$add = _ref7.add, add = _ref7$add === undefined ? true : _ref7$add, _ref7$toggled = _ref7.toggled, toggled = _ref7$toggled === undefined ? false : _ref7$toggled, _ref7$visible = _ref7.visible, visible = _ref7$visible === undefined ? true : _ref7$visible, _ref7$options = _ref7.options, options = _ref7$options === undefined ? {} : _ref7$options, _ref7);

  var id = options.id || type;
  var control = ControlsFactory.create((0, _extends3.default)({
    type: type,
    toggled: options.toggled
  }, options.options));
  control && this.addControl(id, type, control, options.add, options.visible);
  return control;
};

proto._setupControls = function () {
  var _this7 = this;

  var baseLayers = getMapLayersByFilter({
    BASELAYER: true
  });
  this.getMapLayers().forEach(function (mapLayer) {
    mapLayer.getSource().setAttributions(_this7.getApplicationAttribution());
  });
  // check if base layer is set. If true add attribution control
  if (this.getApplicationAttribution() || baseLayers.length) {
    var attributionControl = new ol.control.Attribution({
      collapsible: false
    });
    this.getMap().addControl(attributionControl);
  }

  if (this.config && this.config.mapcontrols) {
    var mapcontrols = this.config.mapcontrols;
    var feature_count = this.project.getQueryFeatureCount();
    var map = this.getMap();
    mapcontrols.forEach(function (controlType) {
      var control = void 0;
      switch (controlType) {
        case 'reset':
          if (!isMobile.any) {
            control = ControlsFactory.create({
              type: controlType
            });
          }
          _this7.addControl(controlType, control, false);
          break;
        case 'zoom':
          control = _this7.createMapControl(controlType, {
            options: {
              zoomInLabel: '\uE98A',
              zoomOutLabel: '\uE98B'
            }
          });
          break;
        case 'zoombox':
          if (!isMobile.any) {
            control = _this7.createMapControl(controlType, {});
            control.on('zoomend', function (e) {
              _this7.viewer.fit(e.extent);
            });
          }
          break;
        case 'zoomtoextent':
          control = _this7.createMapControl(controlType, {
            options: {
              label: '\uE98C',
              extent: _this7.project.state.initextent
            }
          });
          break;
        case 'mouseposition':
          if (!isMobile.any) {
            var coordinateLabels = _this7.getProjection().getUnits() === 'm' ? ['X', 'Y'] : ['Lng', 'Lat'];
            var _crs = _this7.getCrs();
            control = _this7.createMapControl(controlType, {
              add: false,
              options: {
                coordinateFormat: function coordinateFormat(coordinate) {
                  return ol.coordinate.format(coordinate, '\xA0' + coordinateLabels[0] + ': {x}, ' + coordinateLabels[1] + ': {y}\xA0\xA0 [' + _crs + ']\xA0', 4);
                },
                projection: _this7.getCrs()
              }
            });
          }
          break;
        case 'screenshot':
          if (!isMobile.any) {
            control = _this7.createMapControl(controlType, {
              options: {
                onclick: function () {
                  var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                    var blobImage;
                    return _regenerator2.default.wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.prev = 0;
                            _context.next = 3;
                            return _this7.createMapImage();

                          case 3:
                            blobImage = _context.sent;

                            saveAs(blobImage, 'map_' + Date.now() + '.png');
                            _context.next = 10;
                            break;

                          case 7:
                            _context.prev = 7;
                            _context.t0 = _context['catch'](0);

                            GUI.notify.error(t("info.server_error"));

                          case 10:
                            return _context.abrupt('return', true);

                          case 11:
                          case 'end':
                            return _context.stop();
                        }
                      }
                    }, _callee, _this7, [[0, 7]]);
                  }));

                  return function onclick() {
                    return _ref8.apply(this, arguments);
                  };
                }()
              }
            });
          }
          break;
        case 'scale':
          control = _this7.createMapControl(controlType, {
            add: false,
            options: {
              coordinateFormat: ol.coordinate.createStringXY(4),
              projection: _this7.getCrs(),
              isMobile: isMobile.any
            }
          });
          break;
        case 'query':
          control = _this7.createMapControl(controlType, {
            add: true,
            toggled: true
          });
          var eventKey = control.on('picked', throttle(function (e) {
            var coordinates = e.coordinates;
            _this7.getMap().getView().setCenter(coordinates);
            // show marker
            _this7.showMarker(coordinates);
            var showQueryResults = GUI.showContentFactory('query');
            // get querable layer
            var layersFilterObject = {
              QUERYABLE: true,
              SELECTEDORALL: true,
              VISIBLE: true
            };
            var querymultilayers = _this7.project.isQueryMultiLayers(controlType);
            var layers = getMapLayersByFilter(layersFilterObject);
            var queryResultsPromise = getQueryLayersPromisesByCoordinates(layers, {
              map: map,
              querymultilayers: querymultilayers,
              feature_count: feature_count,
              coordinates: coordinates
            });
            var queryResultsPanel = showQueryResults('');
            queryResultsPromise.then(function (responses) {
              var layersResults = responses;
              var results = {
                query: layersResults[0] ? layersResults[0].query : null,
                data: []
              };
              layersResults.forEach(function (result) {
                if (result.data) result.data.forEach(function (data) {
                  results.data.push(data);
                });
              });
              queryResultsPanel.setQueryResponse(results, coordinates, _this7.state.resolution);
            }).fail(function () {
              GUI.notify.error(t("info.server_error"));
              GUI.closeContent();
            });
          }));
          control.setEventKey({
            eventType: 'picked',
            eventKey: eventKey
          });
          break;
        case 'querybypolygon':
          var controlQuerableLayers = getMapLayersByFilter({
            QUERYABLE: true,
            SELECTEDORALL: true
          });
          var controlFiltrableLayers = getMapLayersByFilter({
            FILTERABLE: true,
            SELECTEDORALL: true
          });
          var controlLayers = [].concat((0, _toConsumableArray3.default)(new _set2.default([].concat((0, _toConsumableArray3.default)(controlFiltrableLayers), (0, _toConsumableArray3.default)(controlQuerableLayers)))));
          control = _this7.createMapControl(controlType, {
            options: {
              layers: controlLayers,
              help: t("sdk.mapcontrols.querybypolygon.help")
            }
          });
          if (control) {
            var showQueryResults = GUI.showContentFactory('query');
            var _eventKey = control.on('picked', throttle(function (e) {
              var results = {};
              var geometry = void 0;
              var coordinates = e.coordinates;
              _this7.getMap().getView().setCenter(coordinates);
              var layersFilterObject = {
                QUERYABLE: true,
                SELECTED: true,
                VISIBLE: true
              };
              var queryResultsPanel = showQueryResults('');
              var layers = getMapLayersByFilter(layersFilterObject);
              var queryResulsPromise = getQueryLayersPromisesByCoordinates(layers, {
                map: map,
                feature_count: feature_count,
                coordinates: coordinates
              });
              queryResulsPromise.then(function (responses) {
                var layersResults = responses;
                var queriesPromise = void 0;
                results = {};
                // unify results of the promises
                results.query = layersResults[0] ? layersResults[0].query : null;
                if (layersResults[0] && layersResults[0].data.length && layersResults[0].data[0].features.length) {
                  geometry = layersResults[0].data[0].features[0].getGeometry();
                  var excludeLayers = [layersResults[0].data[0].layer];
                  if (geometry) {
                    var filter = new Filter();
                    var layerFilterObject = {
                      ALLNOTSELECTED: true,
                      FILTERABLE: true,
                      VISIBLE: true
                    };
                    var querymultilayers = _this7.project.isQueryMultiLayers(controlType);
                    var filterGeometry = geometry;
                    if (querymultilayers) {
                      var _layers = getMapLayersByFilter(layerFilterObject).filter(function (layer) {
                        return excludeLayers.indexOf(layer) === -1;
                      });
                      queriesPromise = getQueryLayersPromisesByGeometry(_layers, {
                        geometry: geometry,
                        bbox: false,
                        feature_count: feature_count,
                        projection: _this7.getProjection()
                      });
                    } else {
                      var d = $.Deferred();
                      queriesPromise = d.promise();
                      var _layers2 = getMapLayersByFilter(layerFilterObject);
                      if (_layers2.length === 0) d.resolve([]);else {
                        var queryResponses = [];
                        var _feature_count = _this7.project.getQueryFeatureCount();
                        var mapCrs = _this7.getCrs();
                        var layersLenght = _layers2.length;
                        _layers2.forEach(function (layer) {
                          var layerCrs = layer.getProjection().getCode();
                          if (mapCrs !== layerCrs) filterGeometry = geometry.clone().transform(mapCrs, layerCrs);
                          filter.setGeometry(filterGeometry);
                          layer.query({
                            filter: filter,
                            feature_count: _feature_count
                          }).then(function (response) {
                            queryResponses.push(response);
                          }).always(function () {
                            layersLenght -= 1;
                            if (layersLenght === 0) d.resolve(queryResponses);
                          });
                        });
                      }
                    }
                    _this7.highlightGeometry(geometry);
                  }
                  queriesPromise.then(function (args) {
                    layersResults = args;
                    var results = {
                      query: layersResults[0] ? layersResults[0].query : null,
                      data: []
                    };
                    layersResults.forEach(function (result) {
                      if (result.data) result.data.forEach(function (data) {
                        results.data.push(data);
                      });
                    });
                    queryResultsPanel.setZoomToResults(false);
                    queryResultsPanel.setQueryResponse(results, geometry, _this7.state.resolution);
                  }).fail(function (error) {
                    GUI.notify.error(t("info.server_error"));
                    GUI.closeContent();
                  }).always(function () {
                    _this7.clearHighlightGeometry();
                  });
                } else queryResultsPanel.setQueryResponse([]);
              }).fail(function () {
                GUI.notify.error(t("info.server_error"));
                GUI.closeContent();
              });
            }));
            control.setEventKey({
              eventType: 'picked',
              eventKey: _eventKey
            });
          }
          break;
        case 'querybbox':
          if (!isMobile.any && _this7.filterableLayersAvailable()) {
            var _controlLayers = getMapLayersByFilter({
              SELECTEDORALL: true,
              FILTERABLE: true,
              VISIBLE: true
            });
            control = _this7.createMapControl(controlType, {
              options: {
                layers: _controlLayers,
                help: t("sdk.mapcontrols.querybybbox.help")
              }
            });
            if (control) {
              var _eventKey2 = control.on('bboxend', function (e) {
                var bbox = e.extent;
                var filterBBox = bbox;
                var center = ol.extent.getCenter(bbox);
                _this7.getMap().getView().setCenter(center);
                var layersFilterObject = {
                  SELECTEDORALL: true,
                  FILTERABLE: true,
                  VISIBLE: true
                };
                var layers = getMapLayersByFilter(layersFilterObject);
                var queriesPromise = void 0;
                var querymultilayers = _this7.project.isQueryMultiLayers(controlType);
                if (querymultilayers) {
                  var _layers3 = getMapLayersByFilter(layersFilterObject);
                  queriesPromise = getQueryLayersPromisesByGeometry(_layers3, {
                    geometry: bbox,
                    bbox: true,
                    feature_count: feature_count,
                    projection: _this7.getProjection()
                  });
                } else {
                  var d = $.Deferred();
                  queriesPromise = d.promise();
                  var queryResponses = [];
                  var _feature_count2 = _this7.project.getQueryFeatureCount();
                  var layersLenght = layers.length;
                  layers.forEach(function (layer) {
                    var filter = new Filter();
                    var mapCrs = _this7.getCrs();
                    var layerCrs = layer.getProjection().getCode();
                    if (mapCrs !== layerCrs) {
                      var geometry = ol.geom.Polygon.fromExtent(bbox);
                      filterBBox = geometry.transform(mapCrs, layerCrs).getExtent();
                    }
                    filter.setBBOX(filterBBox);
                    layer.query({
                      filter: filter,
                      feature_count: _feature_count2
                    }).then(function (response) {
                      queryResponses.push(response);
                    }).always(function () {
                      layersLenght -= 1;
                      if (layersLenght === 0) d.resolve(queryResponses);
                    });
                  });
                }
                var showQueryResults = GUI.showContentFactory('query');
                var queryResultsPanel = showQueryResults('');
                queryResultsPanel.setZoomToResults(false);
                queriesPromise.then(function (args) {
                  layersResults = args;
                  var results = {
                    query: layersResults[0] ? layersResults[0].query : null,
                    data: []
                  };
                  layersResults.forEach(function (result) {
                    if (result.data) result.data.forEach(function (data) {
                      results.data.push(data);
                    });
                  });
                  queryResultsPanel.setQueryResponse(results, bbox, _this7.state.resolution);
                }).fail(function (error) {
                  var msg = t("info.server_error");
                  if (error) {
                    msg += ' ' + error;
                  }
                  GUI.notify.error(msg);
                  GUI.closeContent();
                });
              });
              control.setEventKey({
                eventType: 'bboxend',
                eventKey: _eventKey2
              });
            }
          }
          break;
        case 'streetview':
          // streetview
          control = _this7.createMapControl(controlType, {});
          control.setProjection(_this7.getProjection());
          _this7.on('viewerset', function () {
            _this7.viewer.map.addLayer(control.getLayer());
          });
          if (!isMobile.any) {
            $script("https://maps.googleapis.com/maps/api/js?key=AIzaSyBCHtKGx3yXWZZ7_gwtJKG8a_6hArEFefs", function () {
              var position = {
                lat: null,
                lng: null
              };
              var closeContentFnc = function closeContentFnc() {
                control.clearMarker();
              };
              var streetViewService = new StreetViewService();
              streetViewService.onafter('postRender', function (position) {
                control.setPosition(position);
              });
              if (control) {
                _this7._setMapControlVisible({
                  control: control,
                  visible: true
                });
                control.on('picked', throttle(function (e) {
                  GUI.off('closecontent', closeContentFnc);
                  var coordinates = e.coordinates;
                  var lonlat = ol.proj.transform(coordinates, _this7.getProjection().getCode(), 'EPSG:4326');
                  position.lat = lonlat[1];
                  position.lng = lonlat[0];
                  streetViewService.showStreetView(position);
                  GUI.on('closecontent', closeContentFnc);
                }));
                control.on('disabled', function () {
                  GUI.closeContent();
                  GUI.off('closecontent', closeContentFnc);
                });
              }
            });
          }
          break;
        case 'scaleline':
          conntrol = _this7.createMapControl(controlType, {
            add: false,
            options: {
              position: 'br'
            }
          });
          break;
        case 'overview':
          if (!isMobile.any) {
            if (!_this7.config.overviewproject) {
              return;
            }
            var overviewProjectGid = _this7.config.overviewproject.gid;
            if (overviewProjectGid) {
              ProjectsRegistry.getProject(overviewProjectGid).then(function (project) {
                var overViewMapLayers = _this7.getOverviewMapLayers(project);
                var viewOptions = _this7._calculateViewOptions({
                  width: 200, // at monent hardocded
                  height: 150,
                  project: project
                });
                var view = new ol.View(viewOptions);
                var mainView = _this7.getMap().getView();
                view.on('change:center', function () {
                  var currentCenter = this.getCenter();
                  var center = mainView.constrainCenter(currentCenter);
                  if (center[0] !== currentCenter[0] || center[1] !== currentCenter[1]) {
                    view.setCenter(center);
                  }
                });
                control = _this7.createMapControl(controlType, {
                  add: false,
                  options: {
                    position: 'bl',
                    className: 'ol-overviewmap ol-custom-overviewmap',
                    collapseLabel: $('<span class="' + GUI.getFontClass('arrow-left') + '"></span>')[0],
                    label: $('<span class="' + GUI.getFontClass('arrow-right') + '"></span>')[0],
                    collapsed: false,
                    layers: overViewMapLayers,
                    view: view
                  }
                });
              });
            }
          }
          break;
        case 'nominatim':
          control = _this7.createMapControl(controlType, {
            add: false,
            options: {
              isMobile: isMobile.any,
              bbox: _this7.project.state.initextent,
              mapCrs: 'EPSG:' + _this7.project.state.crs,
              placeholder: t("mapcontrols.nominatim.placeholder"),
              noresults: t("mapcontrols.nominatim.noresults"),
              notresponseserver: t("mapcontrols.nominatim.notresponseserver"),
              fontIcon: GUI.getFontClass('search')
            }
          });
          control.on('addresschosen', function (evt) {
            var coordinate = evt.coordinate;
            var geometry = new ol.geom.Point(coordinate);
            _this7.highlightGeometry(geometry);
          });

          $('#search_nominatim').click(debounce(function () {
            control.nominatim.query($('input.gcd-txt-input').val());
          }));
          break;
        case 'geolocation':
          control = _this7.createMapControl(controlType);
          control.on('click', throttle(function (evt) {
            _this7.showMarker(evt.coordinates);
          }));
          control.on('error', function (e) {
            GUI.showUserMessage({
              type: 'warning',
              message: t("mapcontrols.geolocations.error"),
              autoclose: true
            });
          });
          break;
        case 'addlayers':
          if (!isMobile.any) {
            control = _this7.createMapControl(controlType, {});
            control.on('addlayer', function () {
              _this7.emit('addexternallayer');
            });
          }
          break;
        case 'length':
          if (!isMobile.any) {
            control = _this7.createMapControl(controlType, {
              options: {
                tipLabel: t('sdk.mapcontrols.measures.length.tooltip'),
                interactionClassOptions: {
                  projection: _this7.getProjection(),
                  help: t('sdk.mapcontrols.measures.length.help')
                }
              }
            });
          }
          break;
        case 'area':
          if (!isMobile.any) {
            control = _this7.createMapControl(controlType, {
              options: {
                tipLabel: t('sdk.mapcontrols.measures.area.tooltip'),
                interactionClassOptions: {
                  projection: _this7.getProjection(),
                  help: t('sdk.mapcontrols.measures.area.help')
                }
              }
            });
          }
          break;
      }
    });
    //this._setMapControlsInsideContainerLenght();
    //this.state.mapcontrolready = true;
    return this.getMapControls();
  }
};

proto._setMapControlsGrid = function (length) {
  var grid = this.state.mapControl.grid;
  if (length < 2) {
    var rC = grid[grid.length - 1];
    grid.push({
      rows: rC.rows * 2,
      columns: 2
    });
    return;
  }
  if (length === 2) {
    if (grid.length) {
      var _rC = grid[grid.length - 1];
      grid.push({
        rows: _rC.columns,
        columns: _rC.rows
      });
    } else {
      grid.push({
        rows: 1,
        columns: 2
      });
    }
  } else if (length === 3) {
    var _rC2 = grid[grid.length - 1];
    grid.push({
      rows: 2 * _rC2.rows,
      columns: length
    });
  } else {
    grid.push({
      rows: grid.length + 1 + ((0, _isInteger2.default)(length) ? 0 : 1),
      columns: (0, _isInteger2.default)(length) ? length : parseInt(length) + 1
    });
    var _length = (0, _isInteger2.default)(length) ? length : parseInt(length);
    this._setMapControlsGrid(_length / 2);
  }
};

proto._setMapControlsInsideContainerLenght = function () {
  var _this8 = this;

  this.state.mapControl.length = 1;
  // count the mapcontrol insied g3w-map-control container
  this._mapControls.forEach(function (control) {
    var map = _this8.getMap();
    _this8.state.mapControl.length += control.mapcontrol ? 1 : 0;
    control.control.changelayout ? control.control.changelayout(map) : null;
  });
  // add 1 id odd number
  this.state.mapControl.length += this.state.mapControl.length % 2;
  this.state.mapControl.grid = [];
  this._setMapControlsGrid(this.state.mapControl.length);
};

proto.filterableLayersAvailable = function () {
  var layers = getMapLayersByFilter({
    FILTERABLE: true,
    SELECTEDORALL: true
  });
  return layers.some(function (layer) {
    return layer.getProvider('filter') instanceof WFSProvider;
  });
};

proto.setMapControlsAlignement = function () {
  var alignement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'rv';

  this.state.mapcontrolsalignement = alignement;
};

proto.getMapControlsAlignement = function () {
  return this.state.mapcontrolsalignement;
};

proto.isMapControlsVerticalAlignement = function () {
  return this.state.mapcontrolsalignement.indexOf('v') !== -1;
};

proto.setMapControlsVerticalAlignement = function () {
  this.state.mapcontrolsalignement = this.state.mapcontrolsalignement[0] + 'v';
};

proto.setMapControlsHorizontalAlignement = function () {
  this.state.mapcontrolsalignement = this.state.mapcontrolsalignement[0] + 'h';
};

proto.flipControlsHorizontally = function () {
  this.state.mapcontrolsalignement = this.state.mapcontrolsalignement[0] === 'r' ? 'l' + this.state.mapcontrolsalignement[1] : 'r' + this.state.mapcontrolsalignement[1];
};

proto.flipMapControlsVertically = function () {
  this.state.mapcontrolsalignment = this.state.mapcontrolsalignement[1] === 'v' ? this.state.mapcontrolsalignement[0] + 'h' : this.state.mapcontrolsalignement[0] + 'v';
};

proto.setMapControlsContainer = function (mapControlDom) {
  this.state.mapcontrolDOM = mapControlDom;
};

proto._updateMapControlsLayout = function () {
  var _this9 = this;

  var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      width = _ref9.width,
      height = _ref9.height;

  // update only when all control are ready
  if (this.state.mapcontrolready && this.state.mapControl.update) {
    var changed = false;
    // count the mapcontrol insied g3w-map-control container
    this._mapControls.forEach(function (control) {
      var map = _this9.getMap();
      control.control.changelayout ? control.control.changelayout(map) : null;
    });
    // check if is vertical
    if (this.isMapControlsVerticalAlignement()) {
      var mapControslHeight = this.state.mapControl.grid[this.state.mapControl.currentIndex].columns * this.state.mapcontrolSizes.minWidth;
      // get bottom controls
      var bottomMapControls = $('.ol-control-b' + this.getMapControlsAlignement()[0]);
      var bottomMapControlTop = bottomMapControls.length ? $(bottomMapControls[bottomMapControls.length - 1]).position().top : height;
      var freeSpace = bottomMapControlTop > 0 ? bottomMapControlTop - mapControslHeight : height - mapControslHeight;
      if (freeSpace < 10) {
        if (isMobile.any) {
          this.setMapControlsAlignement('rh');
          return;
        } else this.state.mapControl.currentIndex = this.state.mapControl.currentIndex === this.state.mapControl.grid.length - 1 ? this.state.mapControl.currentIndex : this.state.mapControl.currentIndex + 1;
        changed = true;
      } else {
        // check if there enought space to expand mapcontrols
        var nextHeight = this.state.mapControl.currentIndex > 0 ? this.state.mapControl.grid[this.state.mapControl.currentIndex - 1].columns * this.state.mapcontrolSizes.minWidth - mapControslHeight : mapControslHeight;
        if (freeSpace > nextHeight) {
          changed = true;
          this.state.mapControl.currentIndex = this.state.mapControl.currentIndex === 0 ? this.state.mapControl.currentIndex : this.state.mapControl.currentIndex - 1;
        }
      }
      if (changed) {
        mapControslHeight = this.state.mapControl.grid[this.state.mapControl.currentIndex].columns * this.state.mapcontrolSizes.minWidth;
        mapControlsWidth = this.state.mapControl.grid[this.state.mapControl.currentIndex].rows * this.state.mapcontrolSizes.minWidth;
        this.state.mapcontrolDOM.css('height', mapControslHeight + 'px');
        this.state.mapcontrolDOM.css('width', mapControlsWidth + 'px');
      }
    } else {
      if (isMobile.any) {
        this.setMapControlsAlignement('rv');
      }
    }
  }
};

proto._setMapControlVisible = function (_ref10) {
  var control = _ref10.control,
      _ref10$visible = _ref10.visible,
      visible = _ref10$visible === undefined ? true : _ref10$visible;

  control && (visible && $(control.element).show() || $(control.element).hide());
};

proto._addControlToMapControls = function (control) {
  var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var controlElement = control.element;
  if (!visible) control.element.style.display = "none";
  $('.g3w-map-controls').append(controlElement);
};

proto.getMapControlByType = function () {
  var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      type = _ref11.type;

  var mapControl = this._mapControls.find(function (mapControl) {
    return type === mapControl.type;
  });
  return mapControl && mapControl.control;
};

proto.addControl = function (id, type, control) {
  var _this10 = this;

  var addToMapControls = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
  var visible = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;

  this.state.mapcontrolready = false;
  this.viewer.map.addControl(control);
  this._mapControls.push({
    id: id,
    type: type,
    control: control,
    visible: visible,
    mapcontrol: addToMapControls && visible
  });
  control.on('controlclick', function (active) {
    _this10.controlClick(active);
  });
  $(control.element).find('button').tooltip({
    placement: 'bottom',
    trigger: 'hover'
  });
  if (addToMapControls) this._addControlToMapControls(control, visible);else {
    var $mapElement = $('#' + this.getMap().getTarget());
    this._updateMapControlsLayout({
      width: $mapElement.width(),
      height: $mapElement.height()
    });
  }
  ControlsRegistry.registerControl(type, control);
  this._setMapControlsInsideContainerLenght();
  this.state.mapcontrolready = true;
};

proto.showControl = function (type) {
  this.showControls([type]);
};

proto.hideControl = function (type) {
  this.hideControls([type]);
};

proto.showControls = function (types) {
  this.toggleControls(true, types);
};

proto.hideControls = function (types) {
  this.toggleControls(false, types);
};

proto.showAllControls = function () {
  this.toggleControls(true);
};

proto.hideAllControls = function () {
  this.toggleControls(false);
};

proto.toggleControls = function (toggle, types) {
  this._removeControls();
  this._mapControls.forEach(function (controlObj) {
    if (types) {
      if (types.indexOf(controlObj.type) > -1) {
        controlObj.visible = toggle;
      }
    } else {
      controlObj.visible = toggle;
    }
  });
  this._layoutControls();
};

proto._layoutControls = function () {
  var _this11 = this;

  this._mapControls.forEach(function (controlObj) {
    if (controlObj.visible) {
      _this11.viewer.map.addControl(controlObj.control);
    }
  });
};

proto.getMapControls = function () {
  return this._mapControls;
};

proto.removeControlById = function (id) {
  var _this12 = this;

  this._mapControls.forEach(function (controlObj, ctrlIdx) {
    if (id === controlObj.id) {
      _this12._mapControls.splice(ctrlIdx, 1);
      var control = controlObj.control;
      _this12.viewer.map.removeControl(control);
      control.hideControl && control.hideControl();
      return false;
    }
  });
};

proto.removeControl = function (type) {
  var _this13 = this;

  this._mapControls.forEach(function (controlObj, ctrlIdx) {
    if (type === controlObj.type) {
      _this13._mapControls.splice(ctrlIdx, 1);
      var control = controlObj.control;
      _this13.viewer.map.removeControl(control);
      control.hideControl && control.hideControl();
      return false;
    }
  });
};

proto._removeControls = function () {
  var _this14 = this;

  this._mapControls.forEach(function (controlObj) {
    _this14.viewer.map.removeControl(controlObj.control);
  });
};

proto._unToggleControls = function () {
  var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref12$close = _ref12.close,
      close = _ref12$close === undefined ? true : _ref12$close;

  this._mapControls.forEach(function (controlObj) {
    if (controlObj.control.isToggled && controlObj.control.isToggled()) {
      controlObj.control.toggle(false);
      close && GUI.closeContent();
    }
  });
};

proto.deactiveMapControls = function () {
  this._unToggleControls({
    close: false
  });
};

proto.addMapLayers = function (mapLayers) {
  var _this15 = this;

  mapLayers.reverse().forEach(function (mapLayer) {
    _this15.addMapLayer(mapLayer);
  });
};

proto.addMapLayer = function (mapLayer) {
  this._mapLayers.push(mapLayer);
  this.addLayerToMap(mapLayer);
};

proto.getMapLayers = function () {
  return this._mapLayers;
};

proto.getBaseLayers = function () {
  return this.mapBaseLayers;
};

proto.getMapLayerForLayer = function (layer) {
  var multilayerId = 'layer_' + layer.getMultiLayerId();
  var mapLayers = this.getMapLayers();
  var mapLayer = mapLayers.find(function (mapLayer) {
    return mapLayer.getId() === multilayerId;
  });
  return mapLayer;
};

proto.getProjectLayer = function (layerId) {
  return MapLayersStoreRegistry.getLayerById(layerId);
};

proto._setSettings = function () {
  var maxScale = this.getScaleFromExtent(this.project.state.initextent);
  // settings maxScale
  SETTINGS.zoom.maxScale = 2000 > maxScale ? maxScale : 2000;
};

proto._resetView = function () {
  var _viewer$map$getSize = this.viewer.map.getSize(),
      _viewer$map$getSize2 = (0, _slicedToArray3.default)(_viewer$map$getSize, 2),
      width = _viewer$map$getSize2[0],
      height = _viewer$map$getSize2[1];

  var extent = this.project.state.extent;
  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  var maxResolution = Math.max(maxxRes, minyRes) > this.viewer.map.getView().getMaxResolution() ? Math.max(maxxRes, minyRes) : this.viewer.map.getView().getMaxResolution();
  var view = new ol.View({
    extent: extent,
    projection: this.viewer.map.getView().getProjection(),
    center: this.viewer.map.getView().getCenter(),
    resolution: this.viewer.map.getView().getResolution(),
    maxResolution: maxResolution
  });
  this._setSettings();
  this.viewer.map.setView(view);
};

proto._calculateViewOptions = function () {
  var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      project = _ref13.project,
      width = _ref13.width,
      height = _ref13.height;

  var initextent = project.state.initextent;
  var projection = this.getProjection();
  var extent = project.state.extent;
  var maxxRes = ol.extent.getWidth(extent) / width;
  var minyRes = ol.extent.getHeight(extent) / height;
  var maxResolution = Math.max(maxxRes, minyRes);
  var initxRes = ol.extent.getWidth(initextent) / width;
  var inityRes = ol.extent.getHeight(initextent) / height;
  var resolution = Math.max(initxRes, inityRes);
  var center = ol.extent.getCenter(initextent);
  return {
    projection: projection,
    center: center,
    extent: extent,
    maxResolution: maxResolution,
    resolution: resolution
  };
};

// set view based on project config
proto._setupViewer = function (width, height) {
  var _this16 = this;

  this.viewer = ol3helpers.createViewer({
    id: this.target,
    view: this._calculateViewOptions({
      width: width,
      height: height,
      project: this.project
    })
  });

  this._setSettings();
  this.state.size = this.viewer.map.getSize();
  //set mapunit
  this.state.mapUnits = this.viewer.map.getView().getProjection().getUnits();

  if (this.config.background_color) {
    $('#' + this.target).css('background-color', this.config.background_color);
  }

  $(this.viewer.map.getViewport()).prepend('<div id="map-spinner" style="position:absolute; top: 50%; right: 50%"></div>');

  this.viewer.map.getInteractions().forEach(function (interaction) {
    _this16._watchInteraction(interaction);
  });

  this.viewer.map.getInteractions().on('add', function (interaction) {
    _this16._watchInteraction(interaction.element);
  });

  this.viewer.map.getInteractions().on('remove', function (interaction) {
    //this._onRemoveInteraction(interaction);
  });

  this._marker = new ol.Overlay({
    position: undefined,
    positioning: 'center-center',
    element: document.getElementById('marker'),
    stopEvent: false
  });

  this.viewer.map.addOverlay(this._marker);
  this.emit('ready');
};

proto.getMapUnits = function () {
  return this.state.mapUnits;
};

proto._removeListeners = function () {
  if (this._setBaseLayerListenerKey) {
    this.project.un('setBaseLayer', this._setBaseLayerListenerKey);
  }
};

// remove all events of layersStore
proto._removeEventsKeysToLayersStore = function (layerStore) {
  var layerStoreId = layerStore.getId();
  if (this._layersStoresEventKeys[layerStoreId]) {
    this._layersStoresEventKeys[layerStoreId].forEach(function (eventObj) {
      _.forEach(eventObj, function (eventKey, event) {
        layerStore.un(event, eventKey);
      });
    });
    delete this._layersStoresEventKeys[layerStoreId];
  }
};

// register all events of layersStore and relative keys
proto._setUpEventsKeysToLayersStore = function (layerStore) {
  var _this17 = this;

  var layerStoreId = layerStore.getId();
  // check if already store a key of events
  this._layersStoresEventKeys[layerStoreId] = [];
  //SETVISIBILITY EVENT
  var layerVisibleKey = layerStore.onafter('setLayersVisible', function (layersIds) {
    layersIds.forEach(function (layerId) {
      var layer = layerStore.getLayerById(layerId);
      var mapLayer = _this17.getMapLayerForLayer(layer);
      mapLayer && _this17.updateMapLayer(mapLayer);
    });
  });
  this._layersStoresEventKeys[layerStoreId].push({
    setLayersVisible: layerVisibleKey
  });
  //ADD LAYER
  var addLayerKey = layerStore.onafter('addLayer', function (layer) {
    if (layer.getType() === 'vector') {
      var mapLayer = layer.getMapLayer();
      _this17.addLayerToMap(mapLayer);
    }
  });
  this._layersStoresEventKeys[layerStoreId].push({
    addLayer: addLayerKey
  });
  // REMOVE LAYER
  var removeLayerKey = layerStore.onafter('removeLayer', function (layer) {
    if (layer.getType() === 'vector') {
      var olLayer = layer.getOLLayer();
      _this17.viewer.map.removeLayer(olLayer);
    }
  });

  this._layersStoresEventKeys[layerStoreId].push({
    removeLayer: removeLayerKey
  });
};

proto._setupListeners = function () {
  var _this18 = this;

  this._setBaseLayerListenerKey = this.project.onafter('setBaseLayer', function () {
    _this18.updateMapLayers();
  });
};

// SETUP ALL LAYERS
proto._setupAllLayers = function () {
  this._setupBaseLayers();
  this._setupMapLayers();
  this._setupVectorLayers();
};

//SETUP BASELAYERS
proto._setupBaseLayers = function () {
  var _this19 = this;

  var baseLayers = getMapLayersByFilter({
    BASELAYER: true
  });
  if (!baseLayers.length) {
    return;
  }
  this.mapBaseLayers = {};
  baseLayers.forEach(function (layer) {
    var baseMapLayer = layer.getMapLayer();
    _this19.registerMapLayerListeners(baseMapLayer);
    _this19.mapBaseLayers[layer.getId()] = baseMapLayer;
  });
  var reverseBaseLayers = (0, _values2.default)(this.mapBaseLayers).reverse();
  reverseBaseLayers.forEach(function (baseMapLayer) {
    baseMapLayer.update(_this19.state, _this19.layersExtraParams);
    _this19.addLayerToMap(baseMapLayer);
  });
};

//SETUP MAPLAYERS
proto._setupMapLayers = function () {
  var _this20 = this;

  var layers = getMapLayersByFilter({
    BASELAYER: false,
    VECTORLAYER: false
  });
  this._setMapProjectionToLayers(layers);
  //group layer by mutilayer
  var multiLayers = _.groupBy(layers, function (layer) {
    return layer.getMultiLayerId();
  });
  var mapLayers = [];
  (0, _entries2.default)(multiLayers).forEach(function (_ref14) {
    var _ref15 = (0, _slicedToArray3.default)(_ref14, 2),
        id = _ref15[0],
        layers = _ref15[1];

    var multilayerId = 'layer_' + id;
    var mapLayer = void 0;
    var layer = layers[0] || [];
    if (layers.length === 1) {
      mapLayer = layer.getMapLayer({
        id: multilayerId,
        projection: _this20.getProjection()
      }, {});
      _this20.registerMapLayerListeners(mapLayer);
      mapLayer.addLayer(layer);
      mapLayers.push(mapLayer);
    } else {
      mapLayer = layer.getMapLayer({
        id: multilayerId,
        projection: _this20.getProjection()
      }, _this20.layersExtraParams);
      _this20.registerMapLayerListeners(mapLayer);
      layers.reverse().forEach(function (sub_layer) {
        mapLayer.addLayer(sub_layer);
      });
      mapLayers.push(mapLayer);
    }
  });
  this.addMapLayers(mapLayers);
  this.updateMapLayers();
  return mapLayers;
};

//SETUP VECTORLAYERS
proto._setupVectorLayers = function () {
  var _this21 = this;

  var layers = getMapLayersByFilter({
    VECTORLAYER: true
  });
  this._setMapProjectionToLayers(layers);
  layers.forEach(function (layer) {
    var mapVectorLayer = layer.getMapLayer();
    _this21.addLayerToMap(mapVectorLayer);
  });
};

proto.removeLayers = function () {
  this._removeMapLayers();
  //this.viewer.removeLayers();
};

proto.removeAllLayers = function () {
  this.viewer.removeLayers();
};

proto.addLayerToMap = function (layer) {
  var olLayer = layer.getOLLayer();
  if (olLayer) this.getMap().addLayer(olLayer);
};

proto._setMapProjectionToLayers = function (layers) {
  var _this22 = this;

  // setup mapProjection on ech layers
  layers.forEach(function (layer) {
    layer.setMapProjection(_this22.getProjection());
  });
};

proto.createMapLayer = function (layer) {
  layer.setMapProjection(this.getProjection());
  var multilayerId = 'layer_' + layer.getMultiLayerId();
  var mapLayer = layer.getMapLayer({
    id: multilayerId,
    projection: this.getProjection()
  }, this.layersExtraParams);
  mapLayer.addLayer(layer);
  return mapLayer;
};

proto.getOverviewMapLayers = function (project) {
  var WMSLayer = require('core/layers/map/wmslayer');
  var projectLayers = project.getLayersStore().getLayers({
    GEOLAYER: true,
    BASELAYER: false
  });
  var multiLayers = _.groupBy(projectLayers, function (layer) {
    return layer.getMultiLayerId();
  });
  var overviewMapLayers = [];

  (0, _entries2.default)(multiLayers).forEach(function (_ref16) {
    var _ref17 = (0, _slicedToArray3.default)(_ref16, 2),
        id = _ref17[0],
        layers = _ref17[1];

    var multilayerId = 'overview_layer_' + id;
    var tiled = layers[0].state.tiled;
    var config = {
      url: project.getWmsUrl(),
      id: multilayerId,
      tiled: tiled
    };
    var mapLayer = new WMSLayer(config);
    layers.reverse().forEach(function (layer) {
      mapLayer.addLayer(layer);
    });
    overviewMapLayers.push(mapLayer.getOLLayer(true));
  });

  return overviewMapLayers.reverse();
};

proto.updateMapLayer = function (mapLayer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { force: false };

  !options.force ? mapLayer.update(this.state, this.getResolution()) : mapLayer.update(this.state, { "time": Date.now() });
};

// run update function on ech mapLayer
proto.updateMapLayers = function () {
  var _this23 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.getMapLayers().forEach(function (mapLayer) {
    _this23.updateMapLayer(mapLayer, options);
  });
  var baseLayers = this.getBaseLayers();
  //updatebase layer
  (0, _values2.default)(baseLayers).forEach(function (baseLayer) {
    baseLayer.update(_this23.state, _this23.layersExtraParams);
  });
};

// register map Layer listeners of creation
proto.registerMapLayerListeners = function (mapLayer) {
  mapLayer.on('loadstart', this._incrementLoaders);
  mapLayer.on('loadend', this._decrementLoaders);
  mapLayer.on('loaderror', this._mapLayerLoadError);
};

// unregister listeners of mapLayers creation
proto.unregisterMapLayerListeners = function (mapLayer) {
  mapLayer.off('loadstart', this._incrementLoaders);
  mapLayer.off('loadend', this._decrementLoaders);
  mapLayer.off('loaderror', this._mapLayerLoadError);
};

proto.setTarget = function (elId) {
  this.target = elId;
};

proto.addInteraction = function (interaction, close) {
  this._unToggleControls({
    close: close
  });
  this.viewer.map.addInteraction(interaction);
  interaction.setActive(true);
};

proto.removeInteraction = function (interaction) {
  this.viewer.map.removeInteraction(interaction);
};

proto._watchInteraction = function (interaction) {
  var _this24 = this;

  interaction.on('change:active', function (e) {
    if (e.target instanceof ol.interaction.Pointer && e.target.getActive()) {
      _this24.emit('mapcontrol:active', e.target);
    }
  });
};

proto.zoomTo = function (coordinate, zoom) {
  zoom = _.isNumber(zoom) ? zoom : 6;
  this.viewer.zoomTo(coordinate, zoom);
};

proto.goTo = function (coordinates, zoom) {
  var options = {
    zoom: zoom || 6
  };
  this.viewer.goTo(coordinates, options);
};

proto.goToRes = function (coordinates, resolution) {
  this.viewer.goToRes(coordinates, {
    resolution: resolution
  });
};

proto.zoomToFeatures = function (features) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { highlight: false };

  var extent = void 0;
  var geometryType = void 0;
  var geometryCoordinates = [];
  var highlight = options.highlight;

  for (var i = 0; i < features.length; i++) {
    var feature = features[i];
    var geometry = feature.getGeometry ? feature.getGeometry() : feature.geometry;
    if (geometry) {
      extent = !extent ? geometry.getExtent() : ol.extent.extend(extent, geometry.getExtent());
      if (highlight) {
        geometryType = geometryType || geometry.getType();
        var coordinates = geometry.getCoordinates();
        geometryCoordinates.push(geometryType.includes('Multi') && coordinates.length ? coordinates[0] : coordinates);
      }
    }
  }
  if (highlight && extent) {
    try {
      var olClassGeomType = geometryType.includes('Multi') ? geometryType : 'Multi' + geometryType;
      options.highLightGeometry = new ol.geom[olClassGeomType]();
      options.highLightGeometry.setCoordinates(geometryCoordinates);
    } catch (e) {
      console.log(e);
    }
  }
  extent && this.zoomToExtent(extent, options);
};

proto.zoomToExtent = function (extent) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var map = this.getMap();
  var projectInitExtent = this.project.state.initextent;
  var inside = ol.extent.containsExtent(projectInitExtent, extent);
  // max resolution of the map
  var maxResolution = getResolutionFromScale(SETTINGS.zoom.maxScale, this.getMapUnits()); // map resolution of the map
  var center = ol.extent.getCenter(extent);
  // check if
  if (inside) {
    // calculate main resolutions
    var currentResolution = map.getView().getResolution(); // Current Resolution
    var extentResolution = map.getView().getResolutionForExtent(extent, map.getSize()); // resolution of request extent
    ////
    // set the final resolution to go to
    var resolution = extentResolution > maxResolution ? extentResolution : maxResolution;
    resolution = currentResolution < resolution && currentResolution > extentResolution ? currentResolution : resolution;
    this.goToRes(center, resolution);
  } else this.goToRes(center, maxResolution); // set max resolution
  options.highLightGeometry && this.highlightGeometry(options.highLightGeometry, {
    zoom: false
  });
};

proto.goToBBox = function (bbox) {
  bbox = this.isAxisOrientationInverted() ? [bbox[1], bbox[0], bbox[3], bbox[2]] : bbox;
  this.viewer.fit(bbox);
};

proto.goToWGS84 = function (coordinates, zoom) {
  coordinates = ol.proj.transform(coordinates, 'EPSG:4326', 'EPSG:' + this.project.state.crs);
  this.goTo(coordinates, zoom);
};

proto.extentToWGS84 = function (extent) {
  return ol.proj.transformExtent(extent, 'EPSG:' + this.project.state.crs, 'EPSG:4326');
};

proto.getResolutionForMeters = function (meters) {
  var viewport = this.viewer.map.getViewport();
  return meters / Math.max(viewport.clientWidth, viewport.clientHeight);
};

var highlightLayer = null;
var animatingHighlight = false;

proto.highlightGeometry = function (geometryObj) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  this.clearHighlightGeometry();
  var zoom = typeof options.zoom === 'boolean' ? options.zoom : true;
  var hide = options.hide;
  if (hide) {
    hide = typeof hide === 'function' ? hide : null;
  }
  var customStyle = options.style;
  var defaultStyle = function defaultStyle(feature) {
    var styles = [];
    var geometryType = feature.getGeometry().getType();
    var style = createSelectedStyle({
      geometryType: geometryType
    });
    styles.push(style);
    return styles;
  };
  var highlight = typeof options.highlight == 'boolean' ? options.highlight : true;
  var duration = options.duration || SETTINGS.animation.duration;
  var geometry = void 0;
  if (geometryObj instanceof ol.geom.Geometry) {
    geometry = geometryObj;
  } else {
    var format = new ol.format.GeoJSON();
    geometry = format.readGeometry(geometryObj);
  }
  if (zoom) {
    var extent = geometry.getExtent();
    this.zoomToExtent(extent);
  }
  if (highlight) {
    var feature = new ol.Feature({
      geometry: geometry
    });
    if (!highlightLayer) {
      highlightLayer = new ol.layer.Vector({
        source: new ol.source.Vector(),
        style: defaultStyle
      });
      highlightLayer.setMap(this.viewer.map);
    }
    if (customStyle) {
      highlightLayer.setStyle(customStyle);
    }

    highlightLayer.getSource().clear();
    highlightLayer.getSource().addFeature(feature);
    if (hide) {
      var callback = function callback() {
        highlightLayer.getSource().clear();
        if (customStyle) highlightLayer.setStyle(defaultStyle);
      };
      hide(callback);
    } else if (duration) {
      if (duration !== Infinity) {
        animatingHighlight = true;
        setTimeout(function () {
          highlightLayer.getSource().clear();
          if (customStyle) highlightLayer.setStyle(defaultStyle);
          animatingHighlight = false;
        }, duration);
      }
    }
  }
};

proto.clearHighlightGeometry = function () {
  if (highlightLayer && !animatingHighlight) {
    highlightLayer.getSource().clear();
  }
};

proto.refreshMap = function (options) {
  this.updateMapLayers(options);
};

// called when layout (window) resize
proto.layout = function (_ref18) {
  var width = _ref18.width,
      height = _ref18.height;

  if (!this.viewer) {
    this.setupViewer(width, height);
  } else {
    this.setHidden(width === 0 || height === 0);
    this.getMap().updateSize();
    this.state.hidemaps.forEach(function (hidemap) {
      hidemap.map.updateSize();
    });
    this._updateMapView();
    this._updateMapControlsLayout({ width: width, height: height });
  }
};

// function to remove maplayers
proto._removeMapLayers = function () {
  var _this25 = this;

  this.getMapLayers().forEach(function (mapLayer) {
    _this25.unregisterMapLayerListeners(mapLayer);
    _this25.viewer.map.removeLayer(mapLayer.getOLLayer());
  });
  this._mapLayers = [];
};

proto.getMapBBOX = function () {
  return this.viewer.getBBOX();
};

proto._updateMapView = function () {
  var bbox = this.viewer.getBBOX();
  var resolution = this.viewer.getResolution();
  var center = this.viewer.getCenter();
  var size = this.getMap().getSize();
  this.updateMapView(bbox, resolution, center, size);
};

proto.getMapSize = function () {
  var map = this.viewer.map;
  return map.getSize();
};

proto.setInnerGreyCoverScale = function (scale) {
  this._drawShadow.scale = scale;
};

proto._resetDrawShadowInner = function () {
  this._drawShadow = {
    type: 'coordinate',
    outer: [],
    inner: [],
    scale: null,
    rotation: null
  };
};

proto.setInnerGreyCoverBBox = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var map = this.viewer.map;
  var type = options.type || 'coordinate';
  var inner = options.inner || null;
  var rotation = options.rotation;
  var scale = options.scale;
  var lowerLeftInner = void 0;
  var upperRightInner = void 0;
  if (inner) {
    switch (type) {
      case 'coordinate':
        lowerLeftInner = map.getPixelFromCoordinate([inner[0], inner[1]]);
        upperRightInner = map.getPixelFromCoordinate([inner[2], inner[3]]);
        break;
      case 'pixel':
        lowerLeftInner = [inner[0], inner[1]];
        upperRightInner = [inner[2], inner[3]];
        break;
    }
    var y_min = lowerLeftInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_min = lowerLeftInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    var y_max = upperRightInner[1] * ol.has.DEVICE_PIXEL_RATIO;
    var x_max = upperRightInner[0] * ol.has.DEVICE_PIXEL_RATIO;
    this._drawShadow.inner[0] = x_min;
    this._drawShadow.inner[1] = y_min;
    this._drawShadow.inner[2] = x_max;
    this._drawShadow.inner[3] = y_max;
  }
  if (_.isNil(scale)) this._drawShadow.scale = this._drawShadow.scale || 1;else this._drawShadow.scale = scale;

  if (_.isNil(rotation)) this._drawShadow.rotation = this._drawShadow.rotation || 0;else this._drawShadow.rotation = rotation;

  this._drawShadow.outer && map.render();
};

// grey map precompose mapcompose
proto.startDrawGreyCover = function (message) {
  var _this26 = this;

  // after rendering the layer, restore the canvas context
  var map = this.viewer.map;
  var x_min = void 0,
      x_max = void 0,
      y_min = void 0,
      y_max = void 0,
      rotation = void 0,
      scale = void 0;
  this.stopDrawGreyCover();
  var postcompose = function postcompose(evt) {
    var ctx = evt.context;
    var size = _this26.getMap().getSize();
    // Inner polygon,must be counter-clockwise
    var height = size[1] * ol.has.DEVICE_PIXEL_RATIO;
    var width = size[0] * ol.has.DEVICE_PIXEL_RATIO;
    _this26._drawShadow.outer = [0, 0, width, height];
    ctx.restore();
    ctx.beginPath();
    // Outside polygon, must be clockwise
    ctx.moveTo(0, 0);
    ctx.lineTo(width, 0);
    ctx.lineTo(width, height);
    ctx.lineTo(0, height);
    ctx.lineTo(0, 0);
    ctx.closePath();
    // end external bbox (map is cover)
    if (_this26._drawShadow.inner.length) {
      ctx.save();
      x_min = _this26._drawShadow.inner[0];
      y_min = _this26._drawShadow.inner[3];
      x_max = _this26._drawShadow.inner[2];
      y_max = _this26._drawShadow.inner[1];
      rotation = _this26._drawShadow.rotation;
      scale = _this26._drawShadow.scale;
      // Inner polygon,must be counter-clockwise antiorario
      ctx.translate((x_max + x_min) / 2, (y_max + y_min) / 2);
      ctx.rotate(rotation * Math.PI / 180);
      ctx.moveTo(-((x_max - x_min) / 2), (y_max - y_min) / 2);
      ctx.lineTo((x_max - x_min) / 2, (y_max - y_min) / 2);
      ctx.lineTo((x_max - x_min) / 2, -((y_max - y_min) / 2));
      ctx.lineTo(-((x_max - x_min) / 2), -((y_max - y_min) / 2));
      ctx.lineTo(-((x_max - x_min) / 2), (y_max - y_min) / 2);
      ctx.closePath();
      // end inner bbox
    }
    ctx.fillStyle = 'rgba(0, 5, 25, 0.40)';
    ctx.fill();
    if (message) {
      ctx.font = "bold 25px Arial";
      ctx.fillStyle = "#ffffff";
      ctx.textAlign = "center";
      var arrayMessages = message.split('\n');
      for (var i = 0; i < arrayMessages.length; i++) {
        ctx.fillText(arrayMessages[i], width / 2, height / 2 + 30 * i);
      }
      //ctx.fillText(message,width/2, height/2);
    }
    ctx.restore();
  };
  this._greyListenerKey = map.on('postcompose', postcompose);
};

proto.stopDrawGreyCover = function () {
  var map = this.getMap();
  if (this._greyListenerKey) {
    ol.Observable.unByKey(this._greyListenerKey);
    this._greyListenerKey = null;
    this._drawShadow.inner.length && this._resetDrawShadowInner();
  }
  map.render();
};

proto.removeExternalLayer = function (name) {
  var layer = this.getLayerByName(name);
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  QueryResultService.unregisterVectorLayer(layer);
  this.viewer.map.removeLayer(layer);
  catalogService.removeExternalLayer(name);
};

proto.addExternalLayer = function (externalLayer) {
  var _this27 = this;

  var vectorLayer = void 0,
      name = void 0,
      data = void 0,
      color = void 0,
      type = void 0;
  var map = this.viewer.map;
  var catalogService = GUI.getComponent('catalog').getService();
  var QueryResultService = GUI.getComponent('queryresults').getService();
  if (externalLayer instanceof ol.layer.Vector) {
    vectorLayer = externalLayer;
    name = vectorLayer.get('name');
    externalLayer = {
      name: name,
      title: name,
      removable: true,
      external: true,
      visible: true

    };
  } else {
    name = externalLayer.name;
    type = externalLayer.type;
    crs = externalLayer.crs;
    data = externalLayer.data;
    color = externalLayer.color;
  }
  var layer = this.getLayerByName(name);
  var loadExternalLayer = function loadExternalLayer(format, data) {
    var epsg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : crs;

    var features = format.readFeatures(data, {
      dataProjection: epsg,
      featureProjection: _this27.getEpsg()
    });
    var vectorSource = new ol.source.Vector({
      features: features
    });
    var vectorLayer = new ol.layer.Vector({
      source: vectorSource,
      name: name
    });
    vectorLayer.setStyle(_this27.setExternalLayerStyle(color));
    var extent = vectorLayer.getSource().getExtent();
    externalLayer.bbox = {
      minx: extent[0],
      miny: extent[1],
      maxx: extent[2],
      maxy: extent[3]
    };
    externalLayer.checked = true;
    map.addLayer(vectorLayer);
    QueryResultService.registerVectorLayer(vectorLayer);
    catalogService.addExternalLayer(externalLayer);
    map.getView().fit(extent);
    return vectorLayer;
  };
  if (!layer) {
    var format = void 0;
    switch (type) {
      case 'geojson':
        format = new ol.format.GeoJSON();
        loadExternalLayer(format, data);
        break;
      case 'kml':
        format = new ol.format.KML({
          extractStyles: false
        });
        loadExternalLayer(format, data);
        break;
      case 'zip':
        shpToGeojson({
          url: data,
          encoding: 'big5',
          EPSG: crs
        }, function (geojson) {
          var data = (0, _stringify2.default)(geojson);
          format = new ol.format.GeoJSON({});
          loadExternalLayer(format, data, "EPSG:4326");
        });
        break;
    }
  } else {
    GUI.notify.info(t("layer_is_added"));
  }
};

proto.setExternalLayerStyle = function (color) {
  color = color.rgba;
  color = 'rgba(' + color.r + ',' + color.g + ',' + color.b + ',' + color.a + ')';
  var defaultStyle = {
    'Point': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'LineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'Polygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPoint': new ol.style.Style({
      image: new ol.style.Circle({
        fill: new ol.style.Fill({
          color: color
        }),
        radius: 5,
        stroke: new ol.style.Stroke({
          color: color,
          width: 1
        })
      })
    }),
    'MultiLineString': new ol.style.Style({
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    }),
    'MultiPolygon': new ol.style.Style({
      fill: new ol.style.Fill({
        color: 'rgba(255,255,255,0.5)'
      }),
      stroke: new ol.style.Stroke({
        color: color,
        width: 3
      })
    })
  };
  var styleFunction = function styleFunction(feature, resolution) {
    var featureStyleFunction = feature.getStyleFunction();
    if (featureStyleFunction) {
      return featureStyleFunction.call(feature, resolution);
    } else {
      return defaultStyle[feature.getGeometry().getType()];
    }
  };

  return styleFunction;
};

module.exports = MapService;

},{"babel-runtime/core-js/json/stringify":6,"babel-runtime/core-js/number/is-integer":7,"babel-runtime/core-js/object/entries":12,"babel-runtime/core-js/object/values":15,"babel-runtime/core-js/promise":16,"babel-runtime/core-js/set":17,"babel-runtime/helpers/asyncToGenerator":20,"babel-runtime/helpers/extends":22,"babel-runtime/helpers/slicedToArray":23,"babel-runtime/helpers/toConsumableArray":24,"babel-runtime/regenerator":26,"core/applicationservice":560,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/layers/filter/filter":584,"core/layers/map/wmslayer":599,"core/layers/providers/wfsprovider":606,"core/layers/vectorlayer":611,"core/map/maplayersstoresregistry":612,"core/project/projectsregistry":624,"core/utils/geo":629,"core/utils/utils":630,"g3w-ol3/src/g3w.ol3":665,"g3w-ol3/src/utils/utils":678,"gui/gui":710,"gui/map/control/factory":753,"gui/map/control/registry":754,"gui/streetview/streetviewservice":792}],756:[function(require,module,exports){
module.exports = "<!-- Modal -->\n<div class=\"modal fade\" id=\"modal-addlayer\" role=\"dialog\">\n  <div class=\"modal-dialog\">\n    <!-- Modal content-->\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n        <h4 style=\"font-weight: bold\" v-t=\"'mapcontrols.add_layer_control.header'\" class=\"modal-title\"></h4>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"form-group\">\n          <label v-t=\"'mapcontrols.add_layer_control.select_projection'\" for=\"proiezione-layer\"></label>\n          <select class=\"form-control\" id=\"proiezione-layer\" v-model=\"layer.crs\">\n            <option v-for=\"option in options\" :value=\"option\">{{option}}</option>\n          </select>\n        </div>\n        <p v-t=\"'mapcontrols.add_layer_control.select_color'\" style=\"font-weight: 700;\"></p>\n        <chrome-picker v-model=\"layer.color\" @change-color=\"onChangeColor\" style=\"width:90%;margin:auto\"></chrome-picker>\n        <form id=\"addcustomlayer\">\n          <input type=\"file\" title=\" \" @change=\"onAddLayer($event)\" accept=\".kml,.geojson, .KML, .GEOJSON, .zip\">\n          <h4 v-t=\"'mapcontrols.add_layer_control.drag_layer'\"></h4>\n          <h4 v-if=\"layer.name\">{{ layer.name }}</h4>\n          <div>\n            <i :class=\"g3wtemplate.getFontClass('cloud-upload')\" class=\"fa-5x\" aria-hidden=\"true\"></i>\n          </div>\n          <p>.geojson, .kml, .zip(shapefile)</p>\n        </form>\n      </div>\n      <div class=\"modal-footer\">\n        <button v-t=\"'add'\" type=\"button\" class=\"btn btn-success pull-left\" @click=\"addLayer\" data-dismiss=\"modal\"></button>\n        <button v-t=\"'close'\" type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\" @click=\"clearLayer\"></button>\n      </div>\n    </div>\n  </div>\n</div>\n";

},{}],757:[function(require,module,exports){
var EPSG = ["EPSG:3003", "EPSG:3004", "EPSG:3045", "EPSG:3857", "EPSG:4326", "EPSG:6708", "EPSG:23032", "EPSG:23033", "EPSG:25833", "EPSG:32632", "EPSG:32633"];

//Vue color componet
var ChromeComponent = VueColor.Chrome;
ChromeComponent.mounted = function () {
  this.$nextTick(function () {
    // remove all the tihing that aren't useful
    $('.vue-color__chrome__toggle-btn').remove();
    $('.vue-color__editable-input__label').remove();
    $('.vue-color__chrome__saturation-wrap').css('padding-bottom', '100px');
    $('.vue-color__chrome').css({
      'box-shadow': '0 0 0 0',
      'border': '1px solid #97A1A8'
    });
  });
};

var AddLayerComponent = {
  template: require('./addlayer.html'),
  props: ['service'],
  data: function data() {
    return {
      options: EPSG,
      layer: {
        name: null,
        type: null,
        crs: null,
        color: {
          hex: '#194d33',
          rgba: {
            r: 25,
            g: 77,
            b: 51,
            a: 1
          },
          a: 1
        },
        data: null,
        visible: true,
        title: null,
        id: null,
        external: true
      }
    };
  },
  components: {
    'chrome-picker': ChromeComponent
  },
  created: function created() {
    this.layer.crs = this.service.getCrs();
    this.service.on('addexternallayer', function () {
      $('#modal-addlayer').modal('show');
    });
  },
  methods: {
    onChangeColor: function onChangeColor(val) {
      this.layer.color = val;
    },
    onAddLayer: function onAddLayer(evt) {
      var _this = this;

      var reader = new FileReader();
      var name = evt.target.files[0].name;
      this.layer.name = name;
      this.layer.title = name;
      this.layer.id = name;
      var type = evt.target.files[0].name.split('.');
      this.layer.type = type[type.length - 1].toLowerCase();
      if (this.layer.type == 'zip') {
        this.layer.data = evt.target.files[0];
        $('input:file').val(null);
      } else {
        reader.onload = function (evt) {
          _this.layer.data = evt.target.result;
          $('input:file').val(null);
        };
        reader.readAsText(evt.target.files[0]);
      }
    },
    addLayer: function addLayer() {
      if (this.layer.name) {
        var layer = _.cloneDeep(this.layer);
        this.service.addExternalLayer(layer);
        $('#modal-addlayer').modal('hide');
        this.clearLayer();
      }
    },
    clearLayer: function clearLayer() {
      this.layer.name = null;
      this.layer.title = null;
      this.layer.id = null;
      this.layer.type = null;
      this.layer.crs = this.service.getCrs();
      this.layer.color = {
        hex: '#194d33',
        rgba: {
          r: 25,
          g: 77,
          b: 51,
          a: 1
        },
        a: 1
      };
      this.layer.data = null;
    }
  }
};

module.exports = AddLayerComponent;

},{"./addlayer.html":756}],758:[function(require,module,exports){
module.exports = "<div :id=\"maps_container\">\n  <div v-for=\"hidemap in hidemaps\"\n       :id=\"hidemap.id\"\n       :key=\"hidemap.id\"\n       class=\"g3w-map hidemap\">\n  </div>\n  <div :id=\"target\" class=\"g3w-map\">\n    <div class=\"g3w-map-controls\" :class=\"mapcontrolsalignement\"></div>\n    <div style=\"display: none;\">\n      <div id=\"marker\"></div>\n    </div>\n    <addlayer :service=\"service\"></addlayer>\n  </div>\n</div>\n\n\n\n";

},{}],759:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var merge = require('core/utils/utils').merge;
var Component = require('gui/vue/component');
var AddLayerComponent = require('./addlayer');
var MapService = require('../mapservice');
var templateCompiled = (0, _utils.createCompiledTemplate)(require('./map.html'));

// map vue component
var vueComponentOptions = (0, _extends3.default)({}, templateCompiled, {
  data: function data() {
    var service = this.$options.service;

    return {
      target: this.$options.target,
      maps_container: this.$options.maps_container,
      service: service,
      hidemaps: this.$options.service.state.hidemaps
    };
  },
  components: {
    'addlayer': AddLayerComponent
  },
  computed: {
    mapcontrolsalignement: function mapcontrolsalignement() {
      return this.service.state.mapcontrolsalignement;
    }
  },
  mounted: function mounted() {
    var _this = this;

    var mapService = this.$options.service;
    this.crs = mapService.getCrs();
    this.$nextTick(function () {
      mapService.setMapControlsContainer($('.g3w-map-controls'));
    });
    // listen of after addHideMap
    mapService.onafter('addHideMap', function () {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          ratio = _ref.ratio,
          _ref$layers = _ref.layers,
          layers = _ref$layers === undefined ? [] : _ref$layers,
          _ref$mainview = _ref.mainview,
          mainview = _ref$mainview === undefined ? false : _ref$mainview,
          _ref$switchable = _ref.switchable,
          switchable = _ref$switchable === undefined ? false : _ref$switchable;

      _this.$nextTick(function () {
        mapService._addHideMap({ ratio: ratio, layers: layers, mainview: mainview, switchable: switchable });
      });
    });
  },
  methods: {
    showHideControls: function showHideControls() {
      var mapControls = this.$options.service.getMapControls();
      mapControls.forEach(function (control) {
        if (control.type !== "scaleline") control.control.showHide();
      });
    }
  }
});
// interanl registration
var InternalComponent = Vue.extend(vueComponentOptions);

Vue.component('g3w-map', vueComponentOptions);

function MapComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.id = "map-component";
  this.title = "Catalogo dati";
  var target = options.target || "map";
  var maps_container = options.maps_container || "g3w-maps";
  options.target = target;
  options.maps_container = maps_container;
  this.setService(new MapService(options));
  merge(this, options);
  this.internalComponent = new InternalComponent({
    service: this._service,
    target: target,
    maps_container: maps_container
  });
}

inherit(MapComponent, Component);

var proto = MapComponent.prototype;

proto.layout = function (width, height) {
  $('#' + this.target).height(height);
  $('#' + this.target).width(width);
  this._service.layout({ width: width, height: height });
};

module.exports = MapComponent;

},{"../mapservice":755,"./addlayer":757,"./map.html":758,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/vue/component":806,"gui/vue/utils":812}],760:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var t = require('core/i18n/i18n.service').t;
var ProjectsRegistry = require('core/project/projectsregistry');
var ProjectMetadataComponent = require('./vue/components/project/project');
var METADATAGROUPS = {
  general: ['title', 'name', 'description', 'abstract', 'keywords', 'fees', 'accessconstraints', 'contactinformation', 'wms_url'],
  spatial: ['crs', 'extent'],
  layers: ['layers']
};

function MetadataService() {
  this.content = null;
  this.show = false;
  this.state = {
    name: '',
    groups: {}
  };
  this._buildProjectGroupMetadata();
}

inherit(MetadataService, G3WObject);

var proto = MetadataService.prototype;

proto._buildProjectGroupMetadata = function () {
  var project = ProjectsRegistry.getCurrentProject().getState();
  this.state.name = project.title;
  var groups = {};
  (0, _entries2.default)(METADATAGROUPS).forEach(function (_ref) {
    var _ref2 = (0, _slicedToArray3.default)(_ref, 2),
        groupName = _ref2[0],
        value = _ref2[1];

    groups[groupName] = {};
    value.forEach(function (field) {
      var fieldValue = project.metadata && project.metadata[field] ? project.metadata[field] : project[field];
      if (!!fieldValue) {
        groups[groupName][field] = {
          label: t(['sdk', 'metadata', 'groups', groupName, 'fields', field].join('.')), // get traslation here
          value: fieldValue
        };
      }
    });
  });
  this.state.groups = groups;
};

proto.getProjectMetadata = function () {
  return this.state;
};

proto.getLayersMetadata = function () {
  return this.state.groups.layers;
};

proto.getLayerMetadata = function (id) {
  var layerMetadata = this.state.groups.layers.filter(function (layer) {
    return layer.id === id;
  });
  return layerMetadata[0];
};

proto.showMetadata = function (bool) {
  this.show = bool;
  if (this.show) {
    this.content = new ProjectMetadataComponent({
      state: this.getProjectMetadata(),
      service: this
    });
    GUI.setContent({
      content: this.content,
      title: t("sdk.metadata.title"),
      perc: 100
    });
    this.show = true;
  } else {
    GUI.closeContent();
  }
};

proto.reload = function () {
  this.emit('reload');
  this._buildProjectGroupMetadata();
};

module.exports = MetadataService;

},{"./vue/components/project/project":766,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/gui":710}],761:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".layer_header[data-v-e97885ac] {\n  border-bottom: 1px solid rgba(226, 226, 226, 0.3);\n  padding-bottom: 10px;\n  cursor: pointer;\n  color: #2c3b41;\n  font-weight: bold;\n}\n.layer-header-icon[data-v-e97885ac] {\n  margin-right: 10px;\n}\n.layer_header span[data-v-e97885ac] {\n  position: absolute;\n  right: 5px;\n}\n.metadata-label[data-v-e97885ac] {\n  font-weight: bold;\n  font-size: 1.1em;\n}\n.row[data-v-e97885ac] {\n  margin-bottom: 10px;\n}\n.nav-tabs[data-v-e97885ac] { border-bottom: 0px solid #DDD; }\n.nav-tabs > li.active > a[data-v-e97885ac], .nav-tabs > li.active > a[data-v-e97885ac]:focus, .nav-tabs > li.active > a[data-v-e97885ac]:hover { border-width: 0; }\n.nav-tabs > li > a[data-v-e97885ac] { border: none; color: #aeaeae; }\n.nav-tabs > li.active > a[data-v-e97885ac], .nav-tabs > li > a[data-v-e97885ac]:hover { border: none; background: transparent; }\n.nav-tabs > li > a[data-v-e97885ac]::after { content: \"\"; height: 2px; position: absolute; width: 100%; left: 0px; bottom: -1px; transition: all 250ms ease 0s; transform: scale(0); }\n.nav-tabs > li.active > a[data-v-e97885ac]::after, .nav-tabs > li:hover > a[data-v-e97885ac]::after { transform: scale(1); }\n.tab-nav > li > a[data-v-e97885ac]::after { background: #21527d none repeat scroll 0% 0%; color: #fff; }\n.tab-pane[data-v-e97885ac] { padding: 15px 0; }\n.tab-content[data-v-e97885ac] {\n  padding: 20px;\n  background-color: #f9f9f9;\n  overflow: auto;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _metadatamixin = require('../metadatamixin');

var _metadatamixin2 = _interopRequireDefault(_metadatamixin);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "layer",
  mixins: [_metadatamixin2.default],
  props: {
    state: {}
  },
  data: function data() {
    return {
      show: false
    };
  },

  computed: {
    isSpatial: function isSpatial() {
      return this.state.geometrytype != 'No geometry';
    }
  },
  methods: {
    showHideInfo: function showHideInfo() {
      this.show = !this.show;
    }
  },
  mounted: function mounted() {}
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('h4',{staticClass:"layer_header",attrs:{"data-toggle":"collapse","data-target":'#' + _vm.state.id},on:{"click":_vm.showHideInfo}},[_c('i',{staticClass:"layer-header-icon",class:[_vm.isSpatial ? _vm.g3wtemplate.font['map']: _vm.g3wtemplate.font['table']],attrs:{"aria-hidden":"true"}}),_vm._v(_vm._s(_vm.state.name)+"\n    "),_c('span',{staticClass:"fa",class:[_vm.show ? _vm.g3wtemplate.font['eye-close'] : _vm.g3wtemplate.font['eye']]})]),_vm._v(" "),_c('div',{staticClass:"collapse",attrs:{"id":_vm.state.id}},[_c('ul',{staticClass:"metadata-nav-tabs nav nav-tabs",attrs:{"role":"tablist"}},[_c('li',{staticClass:"active",attrs:{"role":"presentation"}},[_c('a',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.groups.general'),expression:"'sdk.metadata.groups.layers.groups.general'"}],attrs:{"href":'#layer_general_' + _vm.state.id,"aria-controls":"general","role":"tab","data-toggle":"tab"}})]),_vm._v(" "),(_vm.isSpatial)?_c('li',{attrs:{"role":"presentation"}},[_c('a',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.groups.spatial'),expression:"'sdk.metadata.groups.layers.groups.spatial'"}],attrs:{"href":'#layer_spatial_' + _vm.state.id,"aria-controls":"profile","role":"tab","data-toggle":"tab"}})]):_vm._e()]),_vm._v(" "),_c('div',{staticClass:"tab-content"},[_c('div',{staticClass:"tab-pane active",attrs:{"role":"tabpanel","id":'layer_general_' + _vm.state.id}},[_c('div',{staticClass:"container-fluid"},[(_vm.findAttributeFormMetadataAttribute('title'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.title'),expression:"'sdk.metadata.groups.layers.fields.subfields.title'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_vm._v(_vm._s(_vm.state.metadata.title))])]):_vm._e(),_vm._v(" "),(_vm.findMetadataAttribute('name'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.name'),expression:"'sdk.metadata.groups.layers.fields.subfields.name'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_vm._v(_vm._s(_vm.state.name))])]):_vm._e(),_vm._v(" "),(_vm.findMetadataAttribute('source'))?_c('div',{staticClass:"row metadata-layer-source"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.source'),expression:"'sdk.metadata.groups.layers.fields.subfields.source'"}],staticClass:"col-md-2 col-sm-12 metadata-label metadata-layer-source-value-key"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value metadata-layer-source-value"},[_vm._v(_vm._s(_vm.state.source.type))])]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('abstract'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.abstract'),expression:"'sdk.metadata.groups.layers.fields.subfields.abstract'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_vm._v(_vm._s(_vm.state.metadata.abstract[0]))])]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('keywords'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.keywords'),expression:"'sdk.metadata.groups.layers.fields.subfields.keywords'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_c('div',[_vm._v(_vm._s(_vm.state.metadata.keywords.join(', ')))])])]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('metadataurl') && _vm.state.metadata.metadataurl.onlineresources)?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.metadataurl'),expression:"'sdk.metadata.groups.layers.fields.subfields.metadataurl'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_c('a',{attrs:{"href":_vm.state.metadata.metadataurl.onlineresources}},[_vm._v(_vm._s(_vm.state.metadata.metadataurl.onlineresources))])])]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('dataurl') && _vm.state.metadata.dataurl.onlineresources)?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.dataurl'),expression:"'sdk.metadata.groups.layers.fields.subfields.dataurl'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value"},[_c('a',{attrs:{"href":_vm.state.metadata.dataurl.onlineresources}},[_vm._v(_vm._s(_vm.state.metadata.dataurl.onlineresources))])])]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('attributes'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.attributes'),expression:"'sdk.metadata.groups.layers.fields.subfields.attributes'"}],staticClass:"col-md-2 col-sm-12 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-md-10 col-sm-12 value",staticStyle:{"overflow":"auto"}},[_c('table',{staticClass:"table"},[_c('thead',[_c('tr',_vm._l((_vm.state.metadata.attributes[0]),function(value,header){return _c('th',[_vm._v(_vm._s(header))])}),0)]),_vm._v(" "),_c('tbody',_vm._l((_vm.state.metadata.attributes),function(attribute){return _c('tr',_vm._l((attribute),function(value,header){return _c('td',[_vm._v(_vm._s(value))])}),0)}),0)])])]):_vm._e()])]),_vm._v(" "),_c('div',{staticClass:"tab-pane",attrs:{"role":"tabpanel","id":'layer_spatial_'+_vm.state.id}},[_c('div',{staticClass:"container-fluid"},[(_vm.findMetadataAttribute('crs'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.crs'),expression:"'sdk.metadata.groups.layers.fields.subfields.crs'"}],staticClass:"col-sm-3 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value"},[_vm._v(_vm._s(_vm.state.crs))])]):_vm._e(),_vm._v(" "),(_vm.findMetadataAttribute('geometrytype'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.geometrytype'),expression:"'sdk.metadata.groups.layers.fields.subfields.geometrytype'"}],staticClass:"col-sm-3 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value"},[_vm._v(_vm._s(_vm.state.geometrytype))])]):_vm._e(),_vm._v(" "),(_vm.findMetadataAttribute('bbox'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.bbox'),expression:"'sdk.metadata.groups.layers.fields.subfields.bbox'"}],staticClass:"col-sm-3 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value"},_vm._l((_vm.state.bbox),function(value,key){return _c('p',[_c('span',{staticStyle:{"font-weight":"bold","margin-right":"5px"}},[_vm._v(_vm._s(key))]),_vm._v(" "),_c('span',[_vm._v(_vm._s(value))])])}),0)]):_vm._e(),_vm._v(" "),(_vm.findAttributeFormMetadataAttribute('crs'))?_c('div',{staticClass:"row"},[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.fields.subfields.crs'),expression:"'sdk.metadata.groups.layers.fields.subfields.crs'"}],staticClass:"col-sm-3 metadata-label"}),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value"},_vm._l((_vm.state.metadata.crs),function(crs){return _c('div',[_c('span',[_vm._v(_vm._s(crs))])])}),0)]):_vm._e()])])])])])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-e97885ac"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e97885ac", __vue__options__)
  } else {
    hotAPI.reload("data-v-e97885ac", __vue__options__)
  }
})()}

},{"../metadatamixin":762,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],762:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  methods: {
    findAttributeFormMetadataAttribute: function findAttributeFormMetadataAttribute(name) {
      return this.state.metadata ? this.state.metadata[name] !== undefined : false;
    },
    findMetadataAttribute: function findMetadataAttribute(name) {
      return this.state[name] !== undefined;
    }
  }
};

},{}],763:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".metadata-label[data-v-11019fc2] {\n  font-weight: bold;\n  font-size: 1.1em;\n}\n.bbox-labels[data-v-11019fc2] {\n  font-weight: bold;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "metadatabbox",
  props: {
    data: {}
  },
  data: function data() {
    return {
      bboxlabels: ['MINX', 'MINY', 'MAXX', 'MAXY']
    };
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"col-sm-3 metadata-label"},[_vm._v(_vm._s(_vm.data.label))]),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value",staticStyle:{"margin-top":"0"}},_vm._l((_vm.data.value),function(value,index){return _c('div',[_c('span',{staticClass:"bbox-labels"},[_vm._v(_vm._s(_vm.bboxlabels[index]))]),_vm._v("  "+_vm._s(value)+"\n    ")])}),0)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-11019fc2"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-11019fc2", __vue__options__)
  } else {
    hotAPI.reload("data-v-11019fc2", __vue__options__)
  }
})()}

},{"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],764:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".metadata-label[data-v-5558c350] {\n  font-weight: bold;\n  font-size: 1.1em;\n}\n.metadata-contact-label[data-v-5558c350] {\n  font-weight: bold;\n}\n.contact-icon[data-v-5558c350] {\n  margin-right: 3px;\n}\n.row[data-v-5558c350] {\n  margin-bottom: 5px;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _keys = require("babel-runtime/core-js/object/keys");

var _keys2 = _interopRequireDefault(_keys);

var _typeof2 = require("babel-runtime/helpers/typeof");

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "metadatacontatcs",
  props: {
    data: {}
  },
  data: function data() {
    return {
      iconsClass: {
        contactelectronicmailaddress: this.g3wtemplate.getFontClass("mail"),
        personprimary: this.g3wtemplate.getFontClass("user"),
        contactvoicetelephone: this.g3wtemplate.getFontClass("mobile")
      }
    };
  },

  methods: {
    sanitizeValue: function sanitizeValue(value) {
      if (value !== null && value !== undefined) {
        if ((typeof value === "undefined" ? "undefined" : (0, _typeof3.default)(value)) === 'object') {
          value = (0, _keys2.default)(value).length ? value : '';
        } else if (Array.isArray(value)) {
          value = value.length ? value : '';
        }
      }
      return value;
    },
    geti18n: function geti18n(key) {}
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"col-sm-3 metadata-label"},[_vm._v(_vm._s(_vm.data.label))]),_vm._v(" "),_c('div',{staticClass:"col-sm-9 value",staticStyle:{"margin-top":"0"}},_vm._l((_vm.data.value),function(value,key){return _c('div',[_c('div',{staticClass:"row"},[_c('div',{staticClass:"col-sm-3 metadata-contact-label"},[_c('i',{staticClass:"contact-icon",class:_vm.iconsClass[key],attrs:{"aria-hidden":"true"}}),_vm._v(" "),_c('span',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.general.fields.subfields.contactinformation.' + key),expression:"'sdk.metadata.groups.general.fields.subfields.contactinformation.' + key"}]})]),_vm._v(" "),_c('div',{staticClass:"col-sm-9"},[(key === 'personprimary')?_vm._l((value),function(subvalue,key){return _c('div',[_c('span',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.general.fields.subfields.contactinformation.' + key),expression:"'sdk.metadata.groups.general.fields.subfields.contactinformation.' + key"}],staticClass:"metadata-contact-label"}),_vm._v(" "),_c('span',[_vm._v(_vm._s(subvalue))])])}):_c('div',[(key === 'contactelectronicmailaddress')?[_c('a',{attrs:{"href":'mailto:' + _vm.sanitizeValue(value)}},[_vm._v(_vm._s(_vm.sanitizeValue(value)))])]:[_vm._v("\n              "+_vm._s(_vm.sanitizeValue(value))+"\n            ")]],2)],2)])])}),0)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-5558c350"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-5558c350", __vue__options__)
  } else {
    hotAPI.reload("data-v-5558c350", __vue__options__)
  }
})()}

},{"babel-runtime/core-js/object/keys":14,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],765:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".metadata-label[data-v-b4b91cbc] {\n  font-weight: bold;\n  font-size: 1.1em;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "metadatatabcontent",
  props: {
    data: {},
    fieldName: {}
  },
  computed: {
    arrayToString: function arrayToString() {
      return this.data.value.join(', ');
    }
  },
  methods: {
    isArrayorObject: function isArrayorObject(value) {
      return Array.isArray(value) || (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object';
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('div',{staticClass:"col-sm-3 metadata-label"},[_vm._v(_vm._s(_vm.data.label)+" ")]),_vm._v(" "),(_vm.fieldName == 'keywords')?_c('div',{staticClass:"col-sm-9 value"},[_vm._v("\n    "+_vm._s(_vm.arrayToString)+"\n  ")]):(_vm.fieldName == 'wms_url')?_c('div',{staticClass:"col-sm-9 value",staticStyle:{"margin-top":"0"}},[_c('span',[_vm._v(_vm._s(_vm.data.value))])]):(!_vm.isArrayorObject(_vm.data.value))?_c('div',{staticClass:"col-sm-9 value",staticStyle:{"margin-top":"0"}},[_c('span',{domProps:{"innerHTML":_vm._s(_vm.data.value)}})]):_c('div',{staticClass:"col-sm-9 value",staticStyle:{"margin-top":"0"}},_vm._l((_vm.data.value),function(value,key){return _c('div',[_c('span',[_vm._v(_vm._s(value))])])}),0)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-b4b91cbc"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-b4b91cbc", __vue__options__)
  } else {
    hotAPI.reload("data-v-b4b91cbc", __vue__options__)
  }
})()}

},{"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],766:[function(require,module,exports){
var _project = require('./project.vue');

var _project2 = _interopRequireDefault(_project);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var Component = require('gui/vue/component');
var base = require('core/utils/utils').base;


function ProjectComponent() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$state = _ref.state,
      state = _ref$state === undefined ? {} : _ref$state,
      service = _ref.service;

  base(this);
  var vueComponent = Vue.extend(_project2.default);
  this.setService(service);
  this.internalComponent = new vueComponent({
    state: state
  });
  this.layout = function () {};
}

inherit(ProjectComponent, Component);

module.exports = ProjectComponent;

},{"./project.vue":767,"core/utils/utils":630,"gui/vue/component":806}],767:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".metadata-item-tab[data-v-e8434e8c] {\n  height: 90px;\n  margin-right: 10px;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n  margin-bottom: 10px;\n}\n\n.metadata-item-tab.spatial[data-v-e8434e8c] {\n  background-color: #019A4C;\n}\n\n.metadata-item-tab.layers[data-v-e8434e8c] {\n  background-color: #FF9B21;\n}\n\n.metadata-body[data-v-e8434e8c] {\n  overflow-y: auto;\n  overflow-x: hidden;\n}\n\n.metadata-body div[data-v-e8434e8c] {\n  margin-top: 10px;\n}\n\n.tab-title[data-v-e8434e8c] {\n  position: absolute;\n  bottom: 10px;\n  right: auto;\n}\n\n.row-info[data-v-e8434e8c] {\n  padding-bottom: 5px;\n  border-bottom: 1px solid #e2e2e2;\n}\n\n.row-info .label[data-v-e8434e8c] {\n  font-weight: bold;\n}\n\n.h_90[data-v-e8434e8c] {\n  height: 90%;\n}\n.h_100[data-v-e8434e8c] {\n  height: 100%;\n}\n\n#project-catalog[data-v-e8434e8c] {\n  padding: 3px 10px 3px 10px;\n  position: relative;\n  overflow: auto;\n}\n.nav-tabs-wrapper[data-v-e8434e8c] {\n  display: inline-block;\n  margin-bottom: -6px;\n  margin-left: 1.25%;\n  margin-right: 1.25%;\n  position: relative;\n  width: 100%;\n}\n\n.nav-tabs[data-v-e8434e8c] {\n  border-bottom: 0 none;\n}\n.nav-stacked[data-v-e8434e8c] {\n  font-size: 1.2em;\n  font-weight: 700;\n  padding: 10px 0;\n}\n.nav-stacked li a[data-v-e8434e8c] {\n  color: #ffffff;\n}\n\n.left-vertical-tabs[data-v-e8434e8c] {\n  padding-left: 0 !important;\n}\n\n.nav-tabs > li.active > a[data-v-e8434e8c] {\n  background-color: #2c3b41 !important;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _layer = require('../layer/layer.vue');

var _layer2 = _interopRequireDefault(_layer);

var _metadatatabcontent = require('./metadatatabcontent.vue');

var _metadatatabcontent2 = _interopRequireDefault(_metadatatabcontent);

var _metadatabboxcontent = require('./metadatabboxcontent.vue');

var _metadatabboxcontent2 = _interopRequireDefault(_metadatabboxcontent);

var _metadatacontactscontent = require('./metadatacontactscontent.vue');

var _metadatacontactscontent2 = _interopRequireDefault(_metadatacontactscontent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "project",
  data: function data() {
    return {
      state: this.$options.state,
      iconsClass: {
        info: this.g3wtemplate.getFontClass("info-circle"),
        globe: this.g3wtemplate.getFontClass("globe"),
        bars: this.g3wtemplate.getFontClass("bars")
      }
    };
  },

  components: {
    'metadata-layer': _layer2.default,
    'metadata-tab-content': _metadatatabcontent2.default,
    'metadata-bbox-content': _metadatabboxcontent2.default,
    'metadata-contacts-content': _metadatacontactscontent2.default

  },
  methods: {
    isArrayorObject: function isArrayorObject(value) {
      return Array.isArray(value) || (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object';
    },
    setComponent: function setComponent(key) {
      var component = void 0;
      switch (key) {
        case 'extent':
          component = 'metadata-bbox-content';
          break;
        case 'contactinformation':
          component = 'metadata-contacts-content';
          break;
        default:
          component = 'metadata-tab-content';
      }
      return component;
    }
  },
  mounted: function mounted() {
    this.$nextTick(function () {});
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"project-catalog"}},[_c('h2',[_vm._v(_vm._s(_vm.state.name))]),_vm._v(" "),_c('div',{staticClass:"container-fluid h_90",attrs:{"id":"project-catalog-container"}},[_c('div',{staticClass:"row h_100"},[_c('div',{staticClass:"col-sm-3 metadata-header left-vertical-tabs"},[_c('div',{staticClass:"nav-tabs-wrapper stacked"},[_c('ul',{staticClass:"nav nav-tabs  nav-stacked",attrs:{"role":"tablist"}},[_c('li',{staticClass:"active"},[_c('a',{staticClass:"metadata-item-tab general",attrs:{"data-toggle":"tab","href":"#general"}},[_c('div',{staticClass:"title title_center"},[_c('i',{staticClass:"fa-2x",class:_vm.iconsClass.info,attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.general.title'),expression:"'sdk.metadata.groups.general.title'"}],staticClass:"tab-title"})])]),_vm._v(" "),_c('li',[_c('a',{staticClass:"metadata-item-tab spatial",attrs:{"data-toggle":"tab","href":"#spatial"}},[_c('div',{staticClass:"title title_center"},[_c('i',{staticClass:"fa-2x",class:_vm.iconsClass.globe,attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.spatial.title'),expression:"'sdk.metadata.groups.spatial.title'"}],staticClass:"tab-title"})])]),_vm._v(" "),_c('li',[_c('a',{staticClass:"metadata-item-tab layers",attrs:{"data-toggle":"tab","href":"#layers"}},[_c('div',{staticClass:"title title_center"},[_c('i',{staticClass:"fa-2x",class:_vm.iconsClass.bars,attrs:{"aria-hidden":"true"}})]),_vm._v(" "),_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.metadata.groups.layers.title'),expression:"'sdk.metadata.groups.layers.title'"}],staticClass:"tab-title"})])])])])]),_vm._v(" "),_c('div',{staticClass:"col-sm-9 metadata-body tab-content"},[_c('div',{staticClass:"tab-pane fade in active nano-content",attrs:{"id":"general"}},[_vm._l((_vm.state.groups.general),function(data,key){return _c('div',{staticClass:"row h_100 row-info"},[_c(_vm.setComponent(key),{tag:"component",attrs:{"data":data,"fieldName":key}})],1)})],2),_vm._v(" "),_c('div',{staticClass:"tab-pane fade",attrs:{"id":"spatial"}},[_c('div',{staticClass:"container-fluid"},[_vm._l((_vm.state.groups.spatial),function(data,key){return _c('div',{staticClass:"row row-info"},[_c(_vm.setComponent(key),{tag:"component",attrs:{"data":data,"fieldName":key}})],1)})],2)]),_vm._v(" "),_c('div',{staticClass:"tab-pane fade",attrs:{"id":"layers"}},_vm._l((_vm.state.groups.layers.layers.value),function(layer){return _c('metadata-layer',{attrs:{"state":layer}})}),1)])])])])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-e8434e8c"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-e8434e8c", __vue__options__)
  } else {
    hotAPI.reload("data-v-e8434e8c", __vue__options__)
  }
})()}

},{"../layer/layer.vue":761,"./metadatabboxcontent.vue":763,"./metadatacontactscontent.vue":764,"./metadatatabcontent.vue":765,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],768:[function(require,module,exports){
module.exports = "<div></div>\n\n";

},{}],769:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var MetadataService = require('gui/metadata/metadataservice');
var templateCompiled = (0, _utils.createCompiledTemplate)(require('./metadata.html'));

var InternalComponent = Vue.extend((0, _extends3.default)({}, templateCompiled, {
  data: function data() {
    return {
      state: null
    };
  },
  mounted: function mounted() {
    this.$nextTick(function () {});
  }
}));

var MetadataComponent = function MetadataComponent() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.title = "sdk.metadata.title";
  var service = options.service || new MetadataService(options);
  this.setService(service);
  this._service.on('reload', function () {
    _this.setOpen(false);
  });
  this.setInternalComponent = function () {
    this.internalComponent = new InternalComponent({
      service: service
    });
    this.internalComponent.state = service.state;
    return this.internalComponent;
  };
  this._setOpen = function (bool) {
    this._service.showMetadata(bool);
  };
};

inherit(MetadataComponent, Component);

module.exports = MetadataComponent;

},{"./metadata.html":768,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/metadata/metadataservice":760,"gui/vue/component":806,"gui/vue/utils":812}],770:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var resolvedValue = require('core/utils/utils').resolve;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');

var Panel = function Panel() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.id = options.id || null;
  this.title = options.title || '';
  this.internalPanel = options.panel || null;
};

inherit(Panel, G3WObject);

var proto = Panel.prototype;

proto.getId = function () {
  return this.id;
};

proto.getTitle = function () {
  return this.title;
};

proto.getInternalPanel = function () {
  return this.internalPanel;
};

proto.setInternalPanel = function (internalPanel) {
  this.internalPanel = internalPanel;
};

proto.show = function () {
  GUI.showPanel(this);
};

proto.mount = function (parent) {
  var panel = this.internalPanel;
  var iCinstance = panel.$mount();
  $(parent).append(iCinstance.$el);
  iCinstance.$nextTick(function () {
    $(parent).localize();
    if (panel.onShow) {
      panel.onShow();
    }
  });
  return resolvedValue(true);
};

proto.unmount = function () {
  var panel = this.internalPanel;
  var d = $.Deferred();
  panel.$destroy(true);
  $(panel.$el).remove();
  if (panel.onClose) {
    panel.onClose();
  }
  this.internalComponent = null;
  d.resolve();
  return d.promise();
};

proto.onResize = function (parentWidth, parentHeight) {};

module.exports = Panel;

},{"core/g3wobject":569,"core/utils/utils":630,"gui/gui":710}],771:[function(require,module,exports){
var scale = [{
  value: 500,
  label: '1:500'
}, {
  value: 1000,
  label: '1:1.000'
}, {
  value: 2000,
  label: '1:2.000'
}, {
  value: 2500,
  label: '1:2.500'
}, {
  value: 5000,
  label: '1:5.000'
}, {
  value: 10000,
  label: '1:10.000'
}, {
  value: 20000,
  label: '1:20.000'
}, {
  value: 25000,
  label: '1:25.000'
}, {
  value: 50000,
  label: '1:50.000'
}, {
  value: 100000,
  label: '1:100.000'
}, {
  value: 250000,
  label: '1:250.000'
}, {
  value: 500000,
  label: '1:500.000'
}, {
  value: 1000000,
  label: '1:1.000.000'
}, {
  value: 5000000,
  label: '1:5.000.000'
}, {
  value: 10000000,
  label: '1:10.000.000'
}, {
  value: 20000000,
  label: '1:20.000.000'
}, {
  value: 50000000,
  label: '1:50.000.000'
}, {
  value: 100000000,
  label: '1:100.000.000'
}, {
  value: 250000000,
  label: '1:250.000.000'
}, {
  value: 500000000,
  label: '1:500.000.000'
}];

var dpis = [150, 300];

var formats = [{
  value: 'pdf',
  label: 'PDF'
}, {
  value: 'png',
  label: 'PNG'
}];

module.exports = {
  scale: scale,
  dpis: dpis,
  formats: formats
};

},{}],772:[function(require,module,exports){
var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _entries = require('babel-runtime/core-js/object/entries');

var _entries2 = _interopRequireDefault(_entries);

var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var t = require('core/i18n/i18n.service').t;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var ProjectsRegistry = require('core/project/projectsregistry');
var PrintService = require('core/print/printservice');

var _require = require('g3w-ol3/src/utils/utils'),
    getScaleFromResolution = _require.getScaleFromResolution,
    getResolutionFromScale = _require.getResolutionFromScale,
    getMetersFromDegrees = _require.getMetersFromDegrees;

var printConfig = require('./printconfig');
var PrintPage = require('./vue/printpage');
var scale = printConfig.scale;
var dpis = printConfig.dpis;
var formats = printConfig.formats;

function PrintComponentService() {
  base(this);
  this.printService = new PrintService();
  this._initialized = false;
  this.state = {
    loading: false
  };
  this._moveMapKeyEvent = null;
  // istanzio il componete page per la visualizzazione del pdf
  this._page = null;
  this._mapService = null;
  this._map = null;
  this._mapUnits;
  this._scalesResolutions = {};
  this.init = function () {
    this._project = ProjectsRegistry.getCurrentProject();
    this.state.print = this._project.state.print;
    this.state.visible = this.state.print && this.state.print.length ? true : false;
    this.state.isShow = false;
    this.state.url = null;
    this.state.output = {
      url: null,
      method: this._project.getOwsMethod(),
      layers: true,
      format: null,
      loading: false,
      type: null
    };
    this.state.printextent = {
      minx: [0, 0],
      miny: [0, 0],
      maxx: [0, 0],
      maxy: [0, 0]
    };
    if (this.state.visible) {
      this.state.template = this.state.print[0].name;
      this.state.rotation = 0;
      this.state.inner = [0, 0, 0, 0];
      this.state.center = null;
      this.state.size = null;
      this.state.scale = scale;
      this.state.scala = null;
      this.state.dpis = dpis;
      this.state.dpi = dpis[0];
      this.state.formats = formats;
      this.state.output.format = formats[0].value;
      this.state.map = null; //;this.state.print[0].maps[0].name;
      this.state.width = null; //this.state.print[0].maps[0].w;
      this.state.height = null; //this.state.print[0].maps[0].h;
    }
  };

  this.changeTemplate = function () {
    var _this = this;

    if (!this.state.template) return;
    var template = this.state.template;
    this.state.print.forEach(function (print) {
      if (print.name === template) {
        _this.state.width = print.maps[0].w;
        _this.state.height = print.maps[0].h;
        _this.state.map = print.maps[0].name;
      }
    });
    this._setPrintArea();
  };

  this.changeScale = function () {
    if (!this.state.scala) return;
    this._setPrintArea();
  };

  this.changeRotation = function () {
    this._mapService.setInnerGreyCoverBBox({
      rotation: this.state.rotation
    });
  };

  this._getPrintExtent = function () {
    var _ref = [].concat((0, _toConsumableArray3.default)(this.state.printextent.lowerleft), (0, _toConsumableArray3.default)(this.state.printextent.upperright)),
        minx = _ref[0],
        miny = _ref[1],
        maxx = _ref[2],
        maxy = _ref[3];

    var extent = this._mapService.isAxisOrientationInverted() ? [miny, minx, maxy, maxx] : [minx, miny, maxx, maxy];
    return extent.join();
  };

  this._getOptionsPrint = function () {
    var options = {
      scale: this.state.scala,
      extent: this._getPrintExtent(),
      rotation: this.state.rotation,
      dpi: this.state.dpi, // dpi
      template: this.state.template,
      map: this.state.map,
      format: this.state.output.format //(map0)
    };
    return options;
  };

  this.setPrintAreaAfterCloseContent = function () {
    var _this2 = this;

    this._map.on('postrender', function () {
      _this2._setPrintArea();
    });
    this.stopLoading();
  };

  this.print = function () {
    var _this3 = this;

    this.state.output.url = null;
    this.state.output.layers = true;
    this._page = new PrintPage({
      service: this
    });
    GUI.setContent({
      content: this._page,
      title: t("print"),
      perc: 100
    });
    var options = this._getOptionsPrint();
    this.printService.print(options, method = this.state.output.method).then(function (data) {
      _this3.state.output.url = data.url;
      _this3.state.output.layers = data.layers;
      _this3.state.output.mime_type = data.mime_type;
    }).catch(function () {
      _this3.showError();
    });
  };

  this.startLoading = function () {
    this.state.output.loading = true;
  };

  this.stopLoading = function () {
    this.state.output.loading = false;
  };

  this.showError = function () {
    GUI.notify.error(t("info.server_error"));
    GUI.closeContent();
  };

  this._calculateInternalPrintExtent = function () {
    var resolution = this._map.getView().getResolution();
    var scala = parseFloat(this.state.scala);
    var resolutionInMeters = this._mapService.getMapUnits() === 'm' ? resolution : getMetersFromDegrees(resolution);
    var w = this.state.width / 1000.0 * scala / resolutionInMeters * ol.has.DEVICE_PIXEL_RATIO;
    var h = this.state.height / 1000.0 * scala / resolutionInMeters * ol.has.DEVICE_PIXEL_RATIO;
    // get current map center ( in pixel)
    var center = [this.state.size[0] * ol.has.DEVICE_PIXEL_RATIO / 2, // X
    this.state.size[1] * ol.has.DEVICE_PIXEL_RATIO / 2 // Y
    ];
    // Calculate the inner bbox in pixel
    var xmin = center[0] - w / 2;
    var ymin = center[1] - h / 2;
    var xmax = center[0] + w / 2;
    var ymax = center[1] + h / 2;
    this.state.printextent.lowerleft = this._map.getCoordinateFromPixel([xmin, ymax]) ? this._map.getCoordinateFromPixel([xmin, ymax]) : this.state.printextent.lowerleft;
    this.state.printextent.upperright = this._map.getCoordinateFromPixel([xmax, ymin]) ? this._map.getCoordinateFromPixel([xmax, ymin]) : this.state.printextent.upperright;

    this.state.inner = [xmin, ymax, xmax, ymin];
  };

  this._setPrintArea = function () {
    this.state.size = this._map.getSize();
    var resolution = this._map.getView().getResolution();
    this.state.currentScala = getScaleFromResolution(resolution, this._mapUnits);
    this.state.center = this._map.getView().getCenter();
    this._calculateInternalPrintExtent();
    this._mapService.setInnerGreyCoverBBox({
      type: 'pixel',
      inner: this.state.inner,
      rotation: this.state.rotation
    });
  };

  this._clearPrint = function () {
    ol.Observable.unByKey(this._moveMapKeyEvent);
    this._moveMapKeyEvent = null;
    this._mapService.stopDrawGreyCover();
  };

  this._setAllScalesBasedOnMaxResolution = function (maxResolution) {
    var _this4 = this;

    var resolution = maxResolution;
    var mapScala = getScaleFromResolution(resolution, this._mapUnits);
    var orderScales = _.orderBy(this.state.scale, ['value'], ['desc']);
    var scale = [];
    orderScales.forEach(function (scala) {
      if (mapScala > scala.value) {
        scale.push(scala);
        resolution = getResolutionFromScale(scala.value, _this4._mapUnits);
        _this4._scalesResolutions[scala.value] = resolution;
        resolution = resolution / 2;
      }
    });
    this.state.scale = _.orderBy(scale, ['value'], ['asc']);
  };

  this._setInitialScalaSelect = function () {
    var _this5 = this;

    var initialResolution = this._map.getView().getResolution();
    var initialScala = getScaleFromResolution(initialResolution, this._mapUnits);
    var found = false;
    this.state.scale.forEach(function (scala, index) {
      if (initialScala < scala.value && !_this5.state.scala) {
        var idx = index ? index - 1 : index;
        _this5.state.scala = _this5.state.scale[idx].value;
        $('#scala').val(_this5.state.scala);
        found = true;
        return false;
      }
    });
    if (!found) {
      this.state.scala = this.state.scale[this.state.scale.length - 1].value;
    }
  };

  this._setCurrentScala = function (resolution) {
    var _this6 = this;

    (0, _entries2.default)(this._scalesResolutions).forEach(function (_ref2) {
      var _ref3 = (0, _slicedToArray3.default)(_ref2, 2),
          scala = _ref3[0],
          res = _ref3[1];

      if (res === resolution) {
        _this6.state.scala = scala;
        return false;
      }
    });
  };

  this._setMoveendMapEvent = function () {
    var _this7 = this;

    this._moveMapKeyEvent = this._map.on('moveend', function () {
      _this7._setPrintArea();
    });
  };

  this._showPrintArea = function () {
    this._setPrintArea();
    this._mapService.startDrawGreyCover();
  };

  this._initPrintConfig = function () {
    var resolution = void 0;
    if (!this._initialized) {
      var maxResolution = this._map.getView().getMaxResolution();
      this._setAllScalesBasedOnMaxResolution(maxResolution);
      this._setInitialScalaSelect();
      this._initialized = true;
    } else {
      resolution = this._map.getView().getResolution();
      this._setCurrentScala(resolution);
    }
  };

  this._setMapInfo = function () {
    var _this8 = this;

    this.state.print[0].maps.forEach(function (map) {
      if (map.name === 'map0') {
        _this8.state.map = map.name;
        _this8.state.width = map.w;
        _this8.state.height = map.h;
        return false;
      }
    });
  };

  this.showPrintArea = function (bool) {
    var _this9 = this;

    // close content if open
    GUI.closeContent().then(function (mapComponent) {
      requestAnimationFrame(function () {
        _this9._mapService = mapComponent.getService();
        _this9._mapUnits = _this9._mapService.getMapUnits();
        _this9._mapService.getMap().once('postrender', function (evt) {
          _this9._map = evt.map;
          if (bool) {
            _this9._setMapInfo();
            _this9._setMoveendMapEvent();
            _this9._initPrintConfig();
            _this9._showPrintArea();
          } else {
            _this9._clearPrint();
          }
        });
        _this9._mapService.getMap().renderSync();
      });
    });
  };

  this.reload = function () {
    var _this10 = this;

    this._project = ProjectsRegistry.getCurrentProject();
    this._mapService = GUI.getComponent('map').getService();
    this._map = this._mapService.viewer.map;
    this.state.print = this._project.state.print;
    this.state.visible = this.state.print && this.state.print.length ? true : false;
    if (this.state.visible) {
      this.state.template = this.state.print[0].name;
      if (!this._initialized) {
        this.init();
      }
      this._initPrintConfig();
      this._mapService.on('changeviewaftercurrentproject', function () {
        var maxResolution = _this10._map.getView().getMaxResolution();
        _this10.state.scale = scale;
        _this10._setAllScalesBasedOnMaxResolution(maxResolution);
      });
    } else {
      this._clearPrint();
    }
  };
}

inherit(PrintComponentService, G3WObject);

module.exports = PrintComponentService;

},{"./printconfig":771,"./vue/printpage":776,"babel-runtime/core-js/object/entries":12,"babel-runtime/helpers/slicedToArray":23,"babel-runtime/helpers/toConsumableArray":24,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/print/printservice":619,"core/project/projectsregistry":624,"core/utils/utils":630,"g3w-ol3/src/utils/utils":678,"gui/gui":710}],773:[function(require,module,exports){
module.exports = "<ul id=\"print\" class=\"treeview-menu\">\n  <li>\n    <form id=\"g3w-search-form\" class=\"form-horizonal\">\n      <div class=\"box-body\">\n        <label for=\"templates\">Template</label>\n        <select class=\"form-control\" @change=\"onChangeTemplate\" v-model=\"state.template\" id=\"templates\" placeholder=\"Seleziona il template\">\n          <option v-for=\"print in state.print\" :value=\"print.name\">{{ print.name }}</option>\n        </select>\n        <label for=\"scala\" v-t=\"'sdk.print.scale'\"></label>\n        <select class=\"form-control\" @change=\"onChangeScale\" v-model=\"state.scala\" id=\"scala\" placeholder=\"Seleziona la scala\">\n          <option v-for=\"scala in state.scale\" :value=\"scala.value\">{{ scala.label }}</option>\n        </select>\n        <label for=\"dpi\">dpi</label>\n        <select class=\"form-control\" @change=\"onChangeDpi\"  v-model=\"state.dpi\" id=\"dpi\" placeholder=\"Seleziona i dpi\">\n          <option v-for=\"dpi in state.dpis\" >{{ dpi }}</option>\n        </select>\n        <label for=\"rotation\" v-t=\"'sdk.print.rotation'\"></label>\n        <input min=\"-360\" max=\"360\"  @input=\"onChangeRotation\" v-model=\"state.rotation\" id=\"rotation\" class=\"form-control\" type=\"number\">\n        <label for=\"format\" v-t=\"'sdk.print.format'\"></label>\n        <select class=\"form-control\" v-model=\"state.output.format\" id=\"format\" placeholder=\"Seleziona formato stampa\">\n          <option v-for=\"format in state.formats\" :value=\"format.value\">{{ format.label }}</option>\n        </select>\n      </div>\n      <div class=\"box-footer\" style=\"background-color: transparent\">\n        <span>\n          <button id=\"printbutton\" style=\"width:100%; font-weight: bold\" class=\"btn skin-button\" @click.stop.prevent=\"print\" v-disabled=\"disabled\">{{ button.title }}</button>\n        </span>\n      </div>\n    </form>\n  </li>\n</ul>\n";

},{}],774:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var Component = require('gui/vue/component');
var PrintService = require('gui/print/printservice');
var base = require('core/utils/utils').base;
var t = require('core/i18n/i18n.service').t;
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./print.html'));

var vueComponentOptions = (0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null,
      button: {
        title: t('create_print'),
        class: "btn-success",
        type: "stampa",
        disabled: false
      }
    };
  },
  computed: {
    disabled: function disabled() {
      return this.state.output.loading;
    }
  },
  methods: {
    onChangeTemplate: function onChangeTemplate() {
      this.$options.service.changeTemplate();
    },
    onChangeScale: function onChangeScale() {
      this.$options.service.changeScale();
    },
    onChangeFormat: function onChangeFormat() {},
    onChangeDpi: function onChangeDpi() {},
    onChangeRotation: function onChangeRotation(evt) {
      if (this.state.rotation >= 0 && !_.isNil(this.state.rotation) && this.state.rotation != '') {
        this.state.rotation = this.state.rotation > 360 ? 360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else if (this.state.rotation < 0) {
        this.state.rotation = this.state.rotation < -360 ? -360 : this.state.rotation;
        evt.target.value = this.state.rotation;
      } else {
        this.state.rotation = 0;
      }
      this.$options.service.changeRotation();
    },
    print: function print() {
      this.$options.service.print();
    }
  }
});

function PrintComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.title = "print";
  this.vueComponent = vueComponentOptions;
  this.internalComponent = null;
  var service = options.service || new PrintService();
  this.setService(service);
  this._service.init();
  this.setInternalComponent = function () {
    var InternalComponent = Vue.extend(this.vueComponent);
    this.internalComponent = new InternalComponent({
      service: service
    });
    this.state.visible = service.state.visible;
    this.internalComponent.state = service.state;
    return this.internalComponent;
  };

  this._reload = function () {
    var service = this.getService();
    service.reload();
    this.state.visible = service.state.visible;
  };

  this._setOpen = function (bool) {
    this._service.showPrintArea(bool);
  };
}

inherit(PrintComponent, Component);

module.exports = PrintComponent;

},{"./print.html":773,"babel-runtime/helpers/extends":22,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/print/printservice":772,"gui/vue/component":806,"gui/vue/utils":812}],775:[function(require,module,exports){
module.exports = "<div id=\"pdf-output\" style=\"height:100%\">\n  <transition :duration=\"500\" name=\"fade\">\n    <bar-loader :loading=\"loading\"></bar-loader>\n  </transition>\n  <div v-if=\"showdownloadbutton\" style=\"display:flex; justify-content: flex-end; margin-bottom: 5px;\">\n    <a :href=\"jpegimageurl\" :download=\"downloadImageName\">\n      <button class=\"btn skin-button\" style=\"font-weight: bold;\" role=\"button\">Download</button>\n    </a>\n  </div>\n  <embed :type=\"state.mime_type\" id=\"printoutput\" v-show=\"state.url\"  style=\"border:0;width:100%;height:100%;\" :src=\"state.url\"></embed>\n  <h4 v-if=\"!state.layers\" v-t=\"'sdk.print.no_layers'\"></h4>\n</div>\n";

},{}],776:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var imageToDataURL = require('core/utils/utils').imageToDataURL;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./printpage.html'));

var InternalComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null,
      showdownloadbutton: false,
      jpegimageurl: null,
      downloadImageName: ''
    };
  },
  computed: {
    loading: function loading() {
      return this.state.loading && this.state.layers;
    }
  },
  watch: {
    'state.url': function stateUrl(url) {
      var _this = this;

      if (url) {
        $('#printoutput').load(url, function (response, status) {
          _this.$options.service.stopLoading();
          if (status === 'error') {
            _this.$options.service.showError();
          } else {
            if (_this.state.format === 'jpg' || _this.state.format === 'png') {
              _this.downloadImageName = 'download.' + _this.state.format;
              imageToDataURL({
                src: _this.state.url,
                type: 'image/' + _this.state.format,
                callback: function callback(url) {
                  _this.showdownloadbutton = true;
                  _this.jpegimageurl = url;
                }
              });
            }
          }
        });
      }
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.state.layers && _this2.$options.service.startLoading();
    });
  },
  beforeDestroy: function beforeDestroy() {
    if (this.state.url && this.state.method === 'POST') window.URL.revokeObjectURL(this.state.url);
  }
}));

var PrintPage = function PrintPage() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  var service = options.service;
  // istanzio il componente interno
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  this.internalComponent.state = service.state.output;
  this.unmount = function () {
    this.getService().setPrintAreaAfterCloseContent();
    return base(this, 'unmount');
  };
};

inherit(PrintPage, Component);

module.exports = PrintPage;

},{"./printpage.html":775,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/vue/component":806,"gui/vue/utils":812}],777:[function(require,module,exports){
var _toConsumableArray2 = require('babel-runtime/helpers/toConsumableArray');

var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

var _isInteger = require('babel-runtime/core-js/number/is-integer');

var _isInteger2 = _interopRequireDefault(_isInteger);

var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var getAlphanumericPropertiesFromFeature = require('core/utils/geo').getAlphanumericPropertiesFromFeature;
var base = require('core/utils/utils').base;
var t = require('core/i18n/i18n.service').t;
var ProjectsRegistry = require('core/project/projectsregistry');
var Layer = require('core/layers/layer');
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var VectorLayer = require('core/layers/vectorlayer');
var ComponentsRegistry = require('gui/componentsregistry');
var RelationsPage = require('gui/relations/vue/relationspage');

function QueryResultsService() {
  var _this = this;

  ProjectsRegistry.onafter('setCurrentProject', function (project) {
    _this._setRelations(project);
  });
  this._actions = {
    'zoomto': QueryResultsService.zoomToElement,
    'highlightgeometry': QueryResultsService.highlightGeometry,
    'clearHighlightGeometry': QueryResultsService.clearHighlightGeometry
  };
  this._relations = [];
  var project = this._project = ProjectsRegistry.getCurrentProject();
  // userful to set right order for query result based on toc order layers
  this._projectLayerIds = this._project.getConfigLayers().map(function (layer) {
    return layer.id;
  });
  this.state = {
    zoomToResult: true,
    components: []
  };
  this.init = function () {
    this.clearState();
  };

  this._vectorLayers = [];
  this.setters = {
    setQueryResponse: function setQueryResponse(queryResponse, coordinates, resolution) {
      this.clearState();
      this.state.query = queryResponse.query;
      var layers = this._digestFeaturesForLayers(queryResponse.data);
      this.setLayersData(layers);
    },
    setLayersData: function setLayersData(layers) {
      // here set the right order of result layers based on toc
      this._orderResponseByProjectLayers(layers);
      this.state.loading = false;
      this.state.layers = layers;
      this.setActionsForLayers(layers);
    },
    addComponent: function addComponent(component) {
      this._addComponent(component);
    },
    addActionsForLayers: function addActionsForLayers(actions) {},
    postRender: function postRender(element) {},
    closeComponent: function closeComponent() {}
  };
  base(this);
  this._setRelations(project);
  this._addVectorLayersDataToQueryResponse();
}

// Make the public service en Event Emitter
inherit(QueryResultsService, G3WObject);

var proto = QueryResultsService.prototype;

proto._orderResponseByProjectLayers = function (layers) {
  var _this2 = this;

  layers.sort(function (layerA, layerB) {
    var aIndex = _this2._projectLayerIds.indexOf(layerA.id);
    var bIndex = _this2._projectLayerIds.indexOf(layerB.id);
    return aIndex > bIndex ? 1 : -1;
  });
};

proto.setZoomToResults = function () {
  var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  this.state.zoomToResult = bool;
};

proto.zoomToLayerFeaturesExtent = function (layer) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var mapService = ComponentsRegistry.getComponent('map').getService();
  var features = layer.features;
  mapService.zoomToFeatures(features, options);
};

proto.clearState = function () {
  this.state.layers = [];
  this.state.query = {};
  this.state.querytitle = "";
  this.state.loading = true;
  this.state.layersactions = {};
};

proto.getState = function () {
  return this.state;
};

proto.setState = function (state) {
  this.state = state;
};

proto._setRelations = function (project) {
  var projectRelations = project.getRelations();
  this._relations = projectRelations ? _.groupBy(projectRelations, 'referencedLayer') : [];
};

proto.setTitle = function (querytitle) {
  this.state.querytitle = querytitle || "";
};

proto.reset = function () {
  this.clearState();
};

proto._digestFeaturesForLayers = function (featuresForLayers) {
  var _this3 = this;

  var id = 0;
  featuresForLayers = featuresForLayers || [];
  var layers = [];
  var layerAttributes = void 0,
      layerRelationsAttributes = void 0,
      layerTitle = void 0,
      layerId = void 0;
  var _handleFeatureFoLayer = function _handleFeatureFoLayer(featuresForLayer) {
    var formStructure = void 0;
    var extractRelations = false;
    var layer = featuresForLayer.layer;
    if (layer instanceof Layer) {
      extractRelations = true;
      layerAttributes = layer.getAttributes();
      layerRelationsAttributes = [];
      layerTitle = layer.getTitle();
      layerId = layer.getId();
      if (layer.hasFormStructure()) {
        var structure = layer.getEditorFormStructure({
          all: true
        });
        if (_this3._relations && _this3._relations.length) {
          var getRelationFieldsFromFormStructure = function getRelationFieldsFromFormStructure(node) {
            if (!node.nodes) {
              node.name ? node.relation = true : null;
            } else {
              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = (0, _getIterator3.default)(node.nodes), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  var _node = _step.value;

                  getRelationFieldsFromFormStructure(_node);
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }
            }
          };
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = (0, _getIterator3.default)(structure), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var node = _step2.value;

              getRelationFieldsFromFormStructure(node);
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
        var fields = layer.getFields();
        formStructure = {
          structure: structure,
          fields: fields
        };
      }
    } else if (layer instanceof ol.layer.Vector) {
      layerAttributes = layer.getProperties();
      layerRelationsAttributes = [];
      layerTitle = layer.get('name');
      layerId = layer.get('id');
    } else if (typeof layer === 'string' || layer instanceof String) {
      var feature = featuresForLayer.features[0];
      layerAttributes = feature ? feature.getProperties() : [];
      layerRelationsAttributes = [];
      var split_layer_name = layer.split('_');
      layerTitle = split_layer_name.length > 4 ? split_layer_name.slice(0, split_layer_name.length - 4).join(' ') : layer;
      layerId = layer;
    }

    var layerObj = {
      title: layerTitle,
      id: layerId,
      attributes: [],
      features: [],
      hasgeometry: false,
      show: true,
      expandable: true,
      hasImageField: false,
      relationsattributes: layerRelationsAttributes,
      formStructure: formStructure,
      error: ''
    };

    var relationNames = [];
    if (extractRelations) for (var _id in _this3._relations) {
      if (layerId === _id) {
        _this3._relations[_id].forEach(function (relation) {
          if (relation.type === 'ONE') {
            var name = relation.name.replace(/\s/g, "_");
            relationNames.push(name);
          }
        });
      }
    }
    if (featuresForLayer.features && featuresForLayer.features.length) {
      var layerSpecialAttributesName = layer instanceof Layer ? layerAttributes.filter(function (attribute) {
        try {
          return attribute.name[0] === '_' || (0, _isInteger2.default)(1 * attribute.name[0]);
        } catch (e) {
          return false;
        }
      }).map(function (attribute) {
        return {
          alias: attribute.name.replace(/_/, ''),
          name: attribute.name
        };
      }) : [];
      layerSpecialAttributesName.length && featuresForLayer.features.forEach(function (feature) {
        return _this3._setSpecialAttributesFetureProperty(layerSpecialAttributesName, feature);
      });
      layerObj.attributes = _this3._parseAttributes(layerAttributes, featuresForLayer.features[0], relationNames);
      layerObj.attributes.forEach(function (attribute) {
        if (formStructure) {
          var relationField = formStructure.fields.find(function (field) {
            return field.name === attribute.name;
          });
          !relationField && formStructure.fields.push(attribute);
        }
        if (attribute.type === 'image') {
          layerObj.hasImageField = true;
        }
      });
      featuresForLayer.features.forEach(function (feature) {
        var fid = feature.getId() ? feature.getId() : id;
        var geometry = feature.getGeometry();
        if (geometry) layerObj.hasgeometry = true;
        var featureObj = {
          id: fid,
          attributes: feature.getProperties(),
          geometry: feature.getGeometry(),
          show: true
        };
        layerObj.features.push(featureObj);
        id += 1;
      });
      layers.push(layerObj);
    } else if (featuresForLayer.error) layerObj.error = featuresForLayer.error;
  };
  featuresForLayers.forEach(function (featuresForLayer) {
    if (!Array.isArray(featuresForLayer)) _handleFeatureFoLayer(featuresForLayer);else featuresForLayer.forEach(function (featuresForLayer) {
      _handleFeatureFoLayer(featuresForLayer);
    });
  });
  return layers;
};

proto._setSpecialAttributesFetureProperty = function (layerSpecialAttributesName, feature) {
  var featureAttributes = feature.getProperties();
  var featureAttributesNames = (0, _keys2.default)(featureAttributes);
  if (layerSpecialAttributesName.length) {
    layerSpecialAttributesName.forEach(function (attributeObj) {
      featureAttributesNames.find(function (featureAttribute) {
        if (featureAttribute.match(attributeObj.alias)) {
          feature.set(attributeObj.name, feature.get(featureAttribute));
          return true;
        }
      });
    });
  }
};

proto._parseAttributes = function (layerAttributes, feature, relationNames) {
  var featureAttributes = feature.getProperties();
  var featureAttributesNames = (0, _keys2.default)(featureAttributes);
  featureAttributesNames = getAlphanumericPropertiesFromFeature(featureAttributesNames);
  if (layerAttributes && layerAttributes.length) {
    var attributes = layerAttributes.filter(function (attribute) {
      return featureAttributesNames.indexOf(attribute.name) > -1;
    });
    var relationAttributes = [];
    relationNames.forEach(function (relationName) {
      relationAttributes = featureAttributesNames.filter(function (attributeName) {
        return attributeName.indexOf(relationName) !== -1;
      }).map(function (name) {
        var suffix = name.split(relationName)[1];
        var fieldName = '' + relationName.replace(/_/g, ' ') + suffix;
        feature.set(fieldName, feature.get(name));
        feature.unset(name);
        return {
          name: fieldName
        };
      });
    });
    return [].concat((0, _toConsumableArray3.default)(attributes), (0, _toConsumableArray3.default)(relationAttributes));
  } else {
    return featureAttributesNames.map(function (featureAttributesName) {
      return {
        name: featureAttributesName,
        label: featureAttributesName
      };
    });
  }
};

proto.setActionsForLayers = function (layers) {
  var _this4 = this;

  layers.forEach(function (layer) {
    if (!_this4.state.layersactions[layer.id]) _this4.state.layersactions[layer.id] = [];
    //in case of geometry
    if (layer.hasgeometry) _this4.state.layersactions[layer.id].push({
      id: 'gotogeometry',
      class: GUI.getFontClass('marker'),
      hint: t('sdk.mapcontrols.query.actions.show_map.hint'),
      cbk: QueryResultsService.goToGeometry
    });
    // in case of relations
    if (_this4._relations) {
      var relations = _this4._relations[layer.id] && _this4._relations[layer.id].filter(function (relation) {
        return relation.type === 'MANY';
      });
      relations && relations.length && _this4.state.layersactions[layer.id].push({
        id: 'show-query-relations',
        class: GUI.getFontClass('relation'),
        hint: 'Visualizza Relazioni',
        cbk: QueryResultsService.showQueryRelations,
        relations: relations
      });
    }
  });
  this.addActionsForLayers(this.state.layersactions);
};

proto.trigger = function (actionId, layer, feature) {
  var actionMethod = this._actions[actionId];
  if (actionMethod) {
    actionMethod(layer, feature);
  }
  if (layer) {
    var layerActions = this.state.layersactions[layer.id];
    if (layerActions) {
      var action = void 0;
      layerActions.forEach(function (layerAction) {
        if (layerAction.id === actionId) {
          action = layerAction;
        }
      });
      if (action) {
        this.triggerLayerAction(action, layer, feature);
      }
    }
  }
};

proto.triggerLayerAction = function (action, layer, feature) {
  if (action.cbk) {
    action.cbk(layer, feature, action);
  }
  if (action.route) {
    var url = void 0;
    var urlTemplate = action.route;
    url = urlTemplate.replace(/{(\w*)}/g, function (m, key) {
      return feature.attributes.hasOwnProperty(key) ? feature.attributes[key] : "";
    });
    if (url && url !== '') {
      GUI.goto(url);
    }
  }
};

proto.registerVectorLayer = function (vectorLayer) {
  if (this._vectorLayers.indexOf(vectorLayer) === -1) {
    this._vectorLayers.push(vectorLayer);
  }
};

proto.unregisterVectorLayer = function (vectorLayer) {
  var index = this._vectorLayers.indexOf(vectorLayer);
  if (index !== -1) {
    this._vectorLayers.splice(index, 1);
  }
};

proto._addVectorLayersDataToQueryResponse = function () {
  var _this5 = this;

  this.onbefore('setQueryResponse', function (queryResponse, coordinates, resolution) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    var isVisible = false;
    _this5._vectorLayers.forEach(function (vectorLayer) {
      var features = [];
      var feature = void 0,
          intersectGeom = void 0;
      switch (vectorLayer.constructor) {
        case VectorLayer:
          isVisible = !vectorLayer.isVisible();
          break;
        case ol.layer.Vector:
          isVisible = !vectorLayer.getVisible();
          break;
      }
      if (queryResponse.data && queryResponse.data.length && queryResponse.data[0].layer == vectorLayer || !coordinates || isVisible) {
        return true;
      }
      if (_.isArray(coordinates)) {
        if (coordinates.length === 2) {
          var pixel = mapService.viewer.map.getPixelFromCoordinate(coordinates);
          mapService.viewer.map.forEachFeatureAtPixel(pixel, function (feature, layer) {
            features.push(feature);
          }, {
            layerFilter: function layerFilter(layer) {
              return layer === vectorLayer;
            }
          });
        } else if (coordinates.length === 4) {
          intersectGeom = ol.geom.Polygon.fromExtent(coordinates);
          switch (vectorLayer.constructor) {
            case VectorLayer:
              features = vectorLayer.getIntersectedFeatures(intersectGeom);
              break;
            case ol.layer.Vector:
              _.forEach(vectorLayer.getSource().getFeatures(), function (feature) {
                if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                  features.push(feature);
                }
              });
              break;
          }
        }
      } else if (coordinates instanceof ol.geom.Polygon || coordinates instanceof ol.geom.MultiPolygon) {
        intersectGeom = coordinates;
        switch (vectorLayer.constructor) {
          case VectorLayer:
            features = vectorLayer.getIntersectedFeatures(intersectGeom);
            break;
          case ol.layer.Vector:
            _.forEach(vectorLayer.getSource().getFeatures(), function (feature) {
              if (intersectGeom.intersectsExtent(feature.getGeometry().getExtent())) {
                features.push(feature);
              }
            });
            break;
        }
      }
      queryResponse.data = queryResponse.data ? queryResponse.data : [];
      queryResponse.data.push({
        features: features,
        layer: vectorLayer
      });
    });
  });
};

//function to add c custom componet in query result
proto._addComponent = function (component) {
  this.state.components.push(component);
};

//save layer result
proto.saveLayerResult = function (layer) {
  var alias = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  try {
    var convertToCSV = function convertToCSV(items) {
      var str = '';
      for (var i = 0; i < items.length; i++) {
        var line = '';
        for (var index in items[i]) {
          if (line !== '') line += ';';
          line += items[i][index];
        }
        str += line + '\r\n';
      }
      return str;
    };

    var exportCSVFile = function exportCSVFile(headers, items, fileTitle) {
      if (headers) {
        items.unshift(headers);
      }
      // Convert Object to JSON
      var csv = convertToCSV(items);
      var exportedFilenmae = layer.id + '.csv';
      var blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      if (navigator.msSaveBlob) {
        // IE 10+
        navigator.msSaveBlob(blob, exportedFilenmae);
      } else {
        var link = document.createElement("a");
        if (link.download !== undefined) {
          // feature detection
          // Browsers that support HTML5 download attribute
          var url = URL.createObjectURL(blob);
          link.setAttribute("href", url);
          link.setAttribute("download", exportedFilenmae);
          link.style.visibility = 'hidden';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
      }
    };

    //get headers
    var attributes = (0, _keys2.default)(layer.features[0].attributes);
    var properties = getAlphanumericPropertiesFromFeature(attributes);
    var headers = !alias && properties || layer.attributes.map(function (attribute) {
      var index = properties.indexOf(attribute.name);
      return layer.attributes[index].label;
    });

    var itemsFormatted = layer.features.map(function (feature) {
      var attributes = feature.attributes;
      var item = {};
      properties.forEach(function (property, index) {
        var key = !alias && property || headers[index];
        item[key] = attributes[property];
      });
      return item;
    });

    exportCSVFile(headers, itemsFormatted);
  } catch (e) {
    GUI.notify.error(t('info.server_error'));
  }
};

QueryResultsService.zoomToElement = function (layer, feature) {
  //TODO
};

QueryResultsService.goToGeometry = function (layer, feature) {
  //mobile
  isMobile.any && !GUI.isContentCollapsed() ? GUI.collapseContent() : null;
  //
  if (feature.geometry) {
    setTimeout(function () {
      var mapService = ComponentsRegistry.getComponent('map').getService();
      mapService.highlightGeometry(feature.geometry, {
        layerId: layer.id,
        duration: 1500
      });
    }, 0);
  }
};

QueryResultsService.highlightGeometry = function (layer, feature) {
  if (feature.geometry) {
    var mapService = ComponentsRegistry.getComponent('map').getService();
    mapService.highlightGeometry(feature.geometry, {
      layerId: layer.id,
      zoom: false,
      duration: Infinity
    });
  }
};

QueryResultsService.clearHighlightGeometry = function (layer, feature) {
  var mapService = ComponentsRegistry.getComponent('map').getService();
  mapService.clearHighlightGeometry();
};

QueryResultsService.showQueryRelations = function (layer, feature, action) {
  GUI.pushContent({
    content: new RelationsPage({
      relations: action.relations,
      feature: feature
    }),
    backonclose: true,
    closable: false
  });
};

module.exports = QueryResultsService;

},{"babel-runtime/core-js/get-iterator":4,"babel-runtime/core-js/number/is-integer":7,"babel-runtime/core-js/object/keys":14,"babel-runtime/helpers/toConsumableArray":24,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/layers/layer":588,"core/layers/vectorlayer":611,"core/project/projectsregistry":624,"core/utils/geo":629,"core/utils/utils":630,"gui/componentsregistry":691,"gui/gui":710,"gui/relations/vue/relationspage":784}],778:[function(require,module,exports){
module.exports = "<div id=\"search-results\" class=\"queryresults-wrapper \">\n  <bar-loader :loading=\"state.loading\"></bar-loader>\n  <div class=\"queryresults-container\">\n    <template v-if=\"!state.loading\">\n      <ul v-if=\"hasLayers\" class=\"queryresults\" id=\"queryresults\" style=\"position: relative\">\n        <li v-if=\"layerHasFeatures(layer) && layer.show\" v-for=\"layer in state.layers\">\n          <div class=\"box box-primary\">\n            <div class=\"box-header with-border\" data-widget=\"collapse\">\n              <div class=\"box-title query-layer-title\">{{ layer.title }}\n                <span class=\"query-layer-feature-count\">({{layer.features.length}})</span>\n                <span v-if=\"layer.hasgeometry && layer.features.length > 1\" @click.stop=\"zoomToLayerFeaturesExtent(layer)\" style=\"margin-left: 10px;\" class=\"action-button skin-tooltip-right\" data-placement=\"right\" data-toggle=\"tooltip\"\n                       title=\"zoomToExtent\">\n                  <span class=\"action-button-icon\" :class=\"g3wtemplate.getFontClass('marker')\"></span>\n                </span>\n                <span>\n                  <span title=\"CSV\" class=\"action-button-icon action-button skin-tooltip-right\"\n                    data-placement=\"right\" data-toggle=\"tooltip\"\n                    :class=\"g3wtemplate.getFontClass('csv')\" @click.stop=\"saveLayerResult(layer)\">\n                  </span>\n                </span>\n              </div>\n              <div class=\"box-tools pull-right\">\n                <button class=\"btn btn-box-tool\" data-widget=\"collapse\"><i class=\"btn-collapser skin-color\" :class=\"g3wtemplate.font['minus']\"></i></button>\n              </div>\n            </div>\n            <div class=\"box-body\">\n              <template v-if=\"hasFormStructure(layer)\">\n                <table class=\"table\">\n                  <thead>\n                    <tr>\n                      <th v-for=\"n in state.layersactions[layer.id]\" :style=\"{ width:headerExpandActionCellWidth + '%' }\"></th>\n                      <th v-for=\"(attribute, index) in attributesSubset(layer.attributes)\">{{attribute.label}}</th>\n                      <th v-show=\"!!hasLayerOneFeature(layer)\"></th>\n                    </tr>\n                  </thead>\n                  <tbody>\n                    <template v-if=\"feature.show\" v-for=\"feature in layer.features\">\n                      <tr @click=\"toggleFeatureBoxAndZoom(layer,feature)\" @mouseover=\"trigger('highlightgeometry',layer,feature)\" @mouseout=\"trigger('clearHighlightGeometry')\" class=\"featurebox-header\" :class=\"[collapsedFeatureBox(layer,feature) && layer.features.length > 1? '' : 'featurebox-header-open']\">\n                        <td v-if=\"showAction({action: action, layer:layer, feature:feature})\" @click.stop=\"trigger(action.id,layer,feature)\" v-for=\"action in state.layersactions[layer.id]\">\n                          <span class=\"action-button  skin-tooltip-right\" data-placement=\"right\" data-toggle=\"tooltip\" :title=\"action.hint\">\n                            <span :class=\"'action-button-icon ' + action.class\"></span>\n                          </span>\n                        </td>\n                        <td v-else></td>\n                        <td style=\"text-overflow: ellipsis;white-space: nowrap;overflow: hidden; vertical-align: middle\" v-for=\"attribute in attributesSubset(layer.attributes)\">\n                          <span>{{feature.attributes[attribute.name]}}</span>\n                        </td>\n                        <td class=\"action-cell right\">\n                          <span v-if=\"!hasLayerOneFeature(layer)\" class=\"fa link morelink skin-color\" :class=\"[collapsedFeatureBox(layer,feature) ? g3wtemplate.font['plus'] : g3wtemplate.font['minus']]\"></span>\n                          <span v-else></span>\n                        </td>\n                      </tr>\n                      <tr v-if=\"!collapsedFeatureBox(layer,feature) || hasOneLayerAndOneFeature(layer)\" class=\"featurebox-body\">\n                        <td :colspan=\"attributesSubsetLength(layer.attributes)+(state.layersactions[layer.id].length + 1)\">\n                          <template v-for=\"item in getItemsFromStructure(layer)\">\n                            <table v-if=\"item.type === 'field'\" class=\"fieldsoutofstructure\">\n                              <tbody>\n                              <tr>\n                                <td class=\"attr-label\">{{ item.item.label }}</td>\n                                <td class=\"attr-value\" :attribute=\"item.item.name\">\n                                  <span v-if=\"is('simple',layer,item.item.name,feature.attributes[item.item.name])\" v-html=\"feature.attributes[item.item.name]\"></span>\n                                  <g3w-image v-else-if=\"is('photo',layer,item.item.name,feature.attributes[item.item.name])\"  :value=\"feature.attributes[item.item.name]\"></g3w-image>\n                                  <g3w-image v-else-if=\"checkField('image', item.item.label, layer.attributes)\"  :value=\"item.item.value\"></g3w-image>\n                                  <g3w-link v-else-if=\"is('link',layer, item.item.name,feature.attributes[item.item.name])\" :state=\"{value: feature.attributes[item.item.name]}\"></g3w-link>\n                                </td>\n                              </tr>\n                              </tbody>\n                            </table>\n                            <tabs v-else-if=\"item.type === 'tab'\" :fields=\"getQueryFields(layer, feature)\" :tabs=\"item.item\"></tabs>\n                          </template>\n                        </td>\n                      </tr>\n                    </template>\n                  </tbody>\n                </table>\n              </template>\n              <table v-else class=\"table\">\n                <thead>\n                  <tr>\n                    <th v-for=\"n in state.layersactions[layer.id]\" :style=\"{ width:headerExpandActionCellWidth + '%' }\"></th>\n                    <th v-for=\"(attribute, index) in attributesSubset(layer.attributes)\">{{attribute.label}}</th>\n                    <th v-if=\"!hasLayerOneFeature(layer)\"></th>\n                  </tr>\n                </thead>\n                <tbody>\n                  <template v-if=\"feature.show\" v-for=\"feature in layer.features\">\n                  <tr @click=\"toggleFeatureBoxAndZoom(layer,feature)\" @mouseover=\"trigger('highlightgeometry',layer,feature)\" @mouseout=\"trigger('clearHighlightGeometry')\" class=\"featurebox-header\" :class=\"[collapsedFeatureBox(layer,feature) && layer.features.length > 1 ? '' : 'featurebox-header-open']\">\n                    <td v-if=\"showAction({action:action, layer:layer, feature:feature})\" @click.stop=\"trigger(action.id,layer,feature)\" v-for=\"action in state.layersactions[layer.id]\">\n                      <span class=\"action-button skin-tooltip-right\" data-placement=\"right\" data-toggle=\"tooltip\" :title=\"action.hint\">\n                        <span :class=\"'action-button-icon ' + action.class\"></span>\n                      </span>\n                    </td>\n                    <td v-else></td>\n                    <td style=\"text-overflow: ellipsis;white-space: nowrap;overflow: hidden; vertical-align: middle\" v-for=\"attribute in attributesSubset(layer.attributes)\">\n                      <span>{{feature.attributes[attribute.name]}}</span>\n                    </td>\n                    <td class=\"action-cell right\">\n                      <span v-if=\"!hasLayerOneFeature(layer)\"  class=\"fa link morelink skin-color\" :class=\"[collapsedFeatureBox(layer,feature) ? g3wtemplate.font['plus'] : g3wtemplate.font['minus']]\"></span>\n                      <span v-else></span>\n                    </td>\n                  </tr>\n                  <tr v-if=\"!collapsedFeatureBox(layer,feature) || hasOneLayerAndOneFeature(layer)\" class=\"featurebox-body\">\n                    <td :colspan=\"attributesSubsetLength(layer.attributes)+(state.layersactions[layer.id].length + 1)\">\n                      <table class=\"feature_attributes\">\n                        <tr v-for=\"attribute in layer.attributes\">\n                          <td class=\"attr-label\">{{ attribute.label }}</td>\n                          <td class=\"attr-value\" :attribute=\"attribute.name\">\n                            <span v-if=\"is('simple',layer,attribute.name,feature.attributes[attribute.name])\" v-html=\"feature.attributes[attribute.name]\"></span>\n                            <g3w-image v-else-if=\"is('photo',layer,attribute.name,feature.attributes[attribute.name])\"  :value=\"feature.attributes[attribute.name]\"></g3w-image>\n                            <g3w-image v-else-if=\"checkField('image', attribute.label, layer.attributes)\"  :value=\"attribute.value\"></g3w-image>\n                            <g3w-link v-else-if=\"is('link',layer,attribute.name,feature.attributes[attribute.name])\" :state=\"{value: feature.attributes[attribute.name]}\"></g3w-link>\n                          </td>\n                        </tr>\n                      </table>\n                    </td>\n                  </tr>\n                </template>\n                </tbody>\n              </table>\n            </div>\n          </div>\n        </li>\n        <li v-for=\"component in state.components\">\n          <component @showresults=\"showResults()\" :is=\"component\"></component>\n        </li>\n      </ul>\n      <h4 v-if=\"!hasResults\" style=\"font-weight: bold;\">{{ noresultmessage }}</h4>\n    </template>\n  </div>\n</div>\n\n";

},{}],779:[function(require,module,exports){
var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _tabs = require('../../tabs/tabs.vue');

var _tabs2 = _interopRequireDefault(_tabs);

var _link = require('../../fields/link.vue');

var _link2 = _interopRequireDefault(_link);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var QueryResultsService = require('gui/queryresults/queryresultsservice');
var GUI = require('gui/gui');
var t = require('core/i18n/i18n.service').t;
var fieldsMixin = require('gui/vue/vue.mixins').fieldsMixin;
var maxSubsetLength = 3;
var headerExpandActionCellWidth = 10;
var headerActionsCellWidth = 10;
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./queryresults.html'));

var vueComponentOptions = (0, _extends3.default)({}, compiledTemplate, {
  mixins: [fieldsMixin],
  data: function data() {
    return {
      state: this.$options.queryResultsService.state,
      layersFeaturesBoxes: {},
      hasResults: false,
      headerExpandActionCellWidth: headerExpandActionCellWidth,
      headerActionsCellWidth: headerActionsCellWidth,
      noresultmessage: t("info.no_results"),
      openlink: t("info.open_link")
    };
  },
  components: {
    Tabs: _tabs2.default,
    'g3w-link': _link2.default
  },
  computed: {
    hasLayers: function hasLayers() {
      return !!this.state.layers.length || !!this.state.components.length;
    }
  },
  methods: {
    saveLayerResult: function saveLayerResult(layer) {
      this.$options.queryResultsService.saveLayerResult(layer);
    },
    hasLayerOneFeature: function hasLayerOneFeature(layer) {
      return layer.features.length === 1;
    },
    hasOneLayerAndOneFeature: function hasOneLayerAndOneFeature(layer) {
      var _this = this;

      var one = this.hasLayerOneFeature(layer);
      if (one) {
        var feature = layer.features[0];
        var boxid = this.getBoxId(layer, feature);
        this.layersFeaturesBoxes[boxid].collapsed = false;
        this.$options.queryResultsService.onceafter('postRender', function () {
          _this.showFeatureInfo(layer, boxid);
        });
      }
      return one;
    },
    hasFormStructure: function hasFormStructure(layer) {
      return !!layer.formStructure;
    },
    hasFieldOutOfFormStructure: function hasFieldOutOfFormStructure(layer) {
      return this.hasFormStructure(layer) ? layer.getFieldsOutOfFormStructure() : [];
    },
    showResults: function showResults() {
      this.hasResults = true;
    },

    isArray: function isArray(value) {
      return _.isArray(value);
    },
    isSimple: function isSimple(layer, attributeName, attributeValue) {
      return !this.isArray(attributeValue) && this.fieldIs(Fields.SIMPLE, layer, attributeName, attributeValue);
    },
    isLink: function isLink(layer, attributeName, attributeValue) {
      return this.fieldIs(Fields.LINK, layer, attributeName, attributeValue);
    },
    is: function is(type, layer, attributeName, attributeValue) {
      return this.fieldIs(type, layer, attributeName, attributeValue);
    },
    checkField: function checkField(type, fieldname, attributes) {
      return attributes.find(function (attribute) {
        return attribute.name === fieldname && attribute.type === type;
      }) ? true : false;
    },
    layerHasFeatures: function layerHasFeatures(layer) {
      if (layer.features) {
        return layer.features.length > 0;
      }
      return false;
    },
    zoomToLayerFeaturesExtent: function zoomToLayerFeaturesExtent(layer) {
      this.$options.queryResultsService.zoomToLayerFeaturesExtent(layer, {
        highlight: true
      });
    },

    layerHasActions: function layerHasActions(layer) {
      return this.state.layersactions[layer.id].length > 0;
    },
    featureHasActions: function featureHasActions(layer, feature) {
      return this.geometryAvailable(feature);
    },
    /*getLayerActions: function(layer) {
     return this.$options.queryResultsService.getLayerActions(layer);
     },*/
    geometryAvailable: function geometryAvailable(feature) {
      return feature.geometry ? true : false;
    },
    attributesSubset: function attributesSubset(attributes) {
      // faccio un filtro sul campo immagine perch non ha senso far vedere
      // la stringa con il path dell'immagine
      var _attributes = _.filter(attributes, function (attribute) {
        return attribute.type != 'image';
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return _attributes.slice(0, end);
    },
    relationsAttributesSubset: function relationsAttributesSubset(relationAttributes) {
      var attributes = [];
      _.forEach(relationAttributes, function (value, attribute) {
        if (_.isArray(value)) return;
        attributes.push({ label: attribute, value: value });
      });
      var end = Math.min(maxSubsetLength, attributes.length);
      return attributes.slice(0, end);
    },
    relationsAttributes: function relationsAttributes(relationAttributes) {
      var attributes = [];
      _.forEach(relationAttributes, function (value, attribute) {
        attributes.push({ label: attribute, value: value });
      });
      return attributes;
    },
    attributesSubsetLength: function attributesSubsetLength(attributes) {
      return this.attributesSubset(attributes).length;
    },
    cellWidth: function cellWidth(index, layer) {
      var headerLength = maxSubsetLength + this.state.layersactions[layer.id].length;
      var subsetLength = this.attributesSubsetLength(layer.attributes);
      var diff = headerLength - subsetLength;
      var actionsCellWidth = layer.hasgeometry ? headerActionsCellWidth : 0;
      var headerAttributeCellTotalWidth = 100 - headerExpandActionCellWidth - actionsCellWidth;
      var baseCellWidth = headerAttributeCellTotalWidth / maxSubsetLength;
      if (index === subsetLength - 1 && diff > 0) {
        return baseCellWidth * (diff + 1);
      } else {
        return baseCellWidth;
      }
    },
    featureBoxColspan: function featureBoxColspan(layer) {
      var colspan = this.attributesSubsetLength(layer.attributes);
      if (layer.expandable) colspan += 1;
      if (layer.hasgeometry) colspan += 1;
      return colspan;
    },
    relationsAttributesSubsetLength: function relationsAttributesSubsetLength(elements) {
      return this.relationsAttributesSubset(elements).length;
    },
    getItemsFromStructure: function getItemsFromStructure(layer) {
      var _this2 = this;

      var prevtabitems = [];
      var newstructure = [];
      layer.formStructure.structure.forEach(function (item) {
        var _item = _this2.isAttributeOrTab(layer, item);
        if (_item.type === 'field') {
          newstructure.push(_item);
          prevtabitems = [];
        } else {
          if (!prevtabitems.length) {
            newstructure.push(_item);
            prevtabitems = _item.item;
          } else prevtabitems.push(_item.item[0]);
        }
      });
      return newstructure;
    },
    isAttributeOrTab: function isAttributeOrTab(layer, item) {
      var isField = item.field_name !== undefined;
      return {
        type: isField && 'field' || 'tab',
        item: isField && this.getLayerAttributeFromStructureItem(layer, item.field_name) || [item]
      };
    },
    getLayerAttributeFromStructureItem: function getLayerAttributeFromStructureItem(layer, field_name) {
      return layer.attributes.find(function (attribute) {
        return attribute.name === field_name;
      });
    },

    collapsedFeatureBox: function collapsedFeatureBox(layer, feature, relation_index) {
      var boxid = !_.isNil(relation_index) ? layer.id + '_' + feature.id + '_' + relation_index : layer.id + '_' + feature.id;
      var collapsed = this.layersFeaturesBoxes[boxid] ? this.layersFeaturesBoxes[boxid].collapsed : true;
      return collapsed;
    },
    showFeatureInfo: function showFeatureInfo(layer, boxid) {
      this.$options.queryResultsService.emit('show-query-feature-info', {
        layer: layer,
        tabs: this.hasFormStructure(layer),
        show: !this.layersFeaturesBoxes[boxid].collapsed
      });
    },
    getBoxId: function getBoxId(layer, feature, relation_index) {
      var boxid = void 0;
      if (!_.isNil(relation_index)) {
        boxid = layer.id + '_' + feature.id + '_' + relation_index;
      } else {
        boxid = layer.id + '_' + feature.id;
      }
      return boxid;
    },

    toggleFeatureBox: function toggleFeatureBox(layer, feature, relation_index) {
      var _this3 = this;

      var boxid = this.getBoxId(layer, feature, relation_index);
      this.layersFeaturesBoxes[boxid].collapsed = !this.layersFeaturesBoxes[boxid].collapsed;
      requestAnimationFrame(function () {
        _this3.showFeatureInfo(layer, boxid);
      });
    },
    toggleFeatureBoxAndZoom: function toggleFeatureBoxAndZoom(layer, feature, relation_index) {
      this.toggleFeatureBox(layer, feature, relation_index);
    },
    trigger: function trigger(action, layer, feature) {
      this.$options.queryResultsService.trigger(action, layer, feature);
    },
    showFullPhoto: function showFullPhoto(url) {
      this.$options.queryResultsService.showFullPhoto(url);
    },
    openLink: function openLink(link_url) {
      window.open(link_url, '_blank');
    },
    fieldIs: function fieldIs(TYPE, layer, attributeName, attributeValue) {
      var fieldType = this.getFieldType(attributeValue);
      return fieldType === TYPE;
    },
    getQueryFields: function getQueryFields(layer, feature) {
      var fields = [];
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = (0, _getIterator3.default)(layer.formStructure.fields), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var field = _step.value;

          var _field = (0, _extends3.default)({}, field);
          _field.query = true;
          _field.value = feature.attributes[field.name];
          _field.input = {
            type: this.getFieldType(_field.value) + '_field'
          };
          fields.push(_field);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return fields;
    },
    showAction: function showAction() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          action = _ref.action,
          layer = _ref.layer,
          feature = _ref.feature;

      return typeof action.condition === 'function' ? action.condition({ layer: layer, feature: feature }) : true;
    }
  },
  watch: {
    'state.layers': function stateLayers(layers) {
      var _this4 = this;

      if (layers.length) {
        if (layers.length === 1 && layers[0].features.length && this.state.zoomToResult) this.zoomToLayerFeaturesExtent(layers[0], {
          maxZoom: 8
        });
        this.hasResults = true;
      }
      requestAnimationFrame(function () {
        _this4.$options.queryResultsService.postRender(_this4.$el);
      });
    }
  },
  beforeMount: function beforeMount() {
    if (this.isMobile()) {
      GUI.hideSidebar();
    }
  },
  beforeDestroy: function beforeDestroy() {
    this.state.zoomToResult = true;
  }
});

var InternalComponent = Vue.extend(vueComponentOptions);

function QueryResultsComponent() {
  var _this5 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.id = "queryresults";
  this.title = "Query Results";
  this._service = new QueryResultsService();
  this.setInternalComponent = function () {
    this.internalComponent = new InternalComponent({
      queryResultsService: this._service
    });
    this.createLayersFeaturesBoxes();
    this.internalComponent.querytitle = this._service.state.querytitle;
  };

  this.getElement = function () {
    if (this.internalComponent) {
      return this.internalComponent.$el;
    }
  };

  this._service.onafter('setLayersData', function () {
    if (!_this5.internalComponent) {
      _this5.setInternalComponent();
    }
    _this5.createLayersFeaturesBoxes();
    requestAnimationFrame(function () {
      $('.action-button[data-toggle="tooltip"]').tooltip();
    });
  });

  this.createLayersFeaturesBoxes = function () {
    var layersFeaturesBoxes = {};
    var layers = this._service.state.layers;
    layers.forEach(function (layer) {
      if (layer.attributes.length <= maxSubsetLength && !layer.hasImageField) {
        layer.expandable = false;
      }
      layer.features.forEach(function (feature, index) {
        var collapsed = true;
        var boxid = layer.id + '_' + feature.id;
        layersFeaturesBoxes[boxid] = {
          collapsed: collapsed
        };
        if (feature.attributes.relations) {
          boxid = '';
          var relations = feature.attributes.relations;
          relations.forEach(function (relation) {
            boxid = layer.id + '_' + feature.id + '_' + relation.name;
            var elements = relation.elements;
            elements.forEach(function (element, index) {
              layersFeaturesBoxes[boxid + index] = {
                collapsed: true
              };
            });
          });
        }
      });
    });
    this.internalComponent.layersFeaturesBoxes = layersFeaturesBoxes;
  };

  this.layout = function (width, height) {};
  this.unmount = function () {
    this.getService().closeComponent();
    return base(this, 'unmount');
  };
}
inherit(QueryResultsComponent, Component);

module.exports = QueryResultsComponent;

},{"../../fields/link.vue":698,"../../tabs/tabs.vue":800,"./queryresults.html":778,"babel-runtime/core-js/get-iterator":4,"babel-runtime/helpers/extends":22,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/gui":710,"gui/queryresults/queryresultsservice":777,"gui/vue/component":806,"gui/vue/utils":812,"gui/vue/vue.mixins":815}],780:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var RealtionsService = require('core/relations/relationsservice');

function RelationsComponentService() {
  this.state = {};
  this._service = new RealtionsService();
  base(this);

  this.getRelations = function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return this._service.getRelations(options);
  };

  this.buildRelationTable = function (relations) {
    var columns = _.keys(relations[0]);
    var rows = [];
    relations.forEach(function (relation) {
      rows.push(_.values(relation));
    });
    return {
      columns: columns,
      rows: rows
    };
  };
}

inherit(RelationsComponentService, G3WObject);

module.exports = RelationsComponentService;

},{"core/g3wobject":569,"core/relations/relationsservice":627,"core/utils/utils":630}],781:[function(require,module,exports){
module.exports = "<div class=\"query-relation\">\n  <div v-if=\"showrelationslist\" class=\"back-btn\" @click=\"back\">\n    <span class=\"back-link\">\n      <span  v-t=\"'sdk.relations.back_to_relations'\"><i :class=\"g3wtemplate.getFontClass('arrow-left')\" style=\"margin-right: 5px;\"></i></span>\n    </span>\n  </div>\n  <div class=\"header\">\n    <div style=\"font-size: 1.5em\">\n      <span v-t:pre=\"'sdk.relations.relation_data'\">:</span> <b> {{ relation.name }}</b>\n    </div>\n  </div>\n  <div class=\"nano\" v-if=\"table.rows.length\">\n    <div class=\"nano-content\">\n      <table id=\"relationtable\" class=\"table table-striped\" width=\"100%\">\n        <thead>\n          <tr>\n            <th v-for=\"column in table.columns\">{{ column }}</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for=\"row in table.rows\">\n            <td v-for=\"value in row\">\n              <field :state=\"{value:value}\"></field>\n            </td>\n          </tr>\n        </tbody>\n        </table>\n    </div>\n  </div>\n  <div v-else v-t=\"'sdk.relations.no_relations_found'\"></div>\n</div>\n";

},{}],782:[function(require,module,exports){
module.exports = "<div class=\"query-relations\" style=\"overflow-y:auto\">\n  <div class=\"header\">\n    <div>\n      <span style=\"font-size: 1.2em;\" v-t:pre=\"'sdk.relations.list_of_relations_feature'\"> </span>\n      <span v-for=\"info in featureInfo()\"><b>{{ info.key }}</b>: {{ info.value }} </span>\n    </div>\n  </div>\n  <table class=\"table table-bordered table-hover\">\n    <thead>\n    </thead>\n    <tbody>\n    <tr @click=\"showRelation(relation)\" v-for=\"relation in relations\" style=\"cursor:pointer\">\n      <td>\n        <span >{{ relation.name }}</span>\n        <span :class=\"g3wtemplate.getFontClass('arrow-right')\" class=\"pull-right\" aria-hidden=\"true\"></span>\n      </td>\n    </tr>\n    </tbody>\n  </table>\n</div>\n";

},{}],783:[function(require,module,exports){
module.exports = "<div class=\"query-relations-page\">\n    <component\n        :ref=\"currentview\"\n        :previousview=\"previousview\"\n        :is=\"currentview\"\n        :relations=\"relations\"\n        :relation=\"relation\"\n        :feature=\"feature\"\n        :table=\"table\">\n    </component>\n</div>\n";

},{}],784:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var t = require('core/i18n/i18n.service').t;
var Service = require('../relationsservice');
var Field = require('gui/fields/g3w-field.vue');
var RelationPageEventBus = new Vue();
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./relations.html'));

/* List of relations */
var relationsComponent = (0, _extends3.default)({}, compiledTemplate, {
  props: ['relations', 'feature'],
  methods: {
    showRelation: function showRelation(relation) {
      this.$parent.showRelation(relation);
    },
    featureInfo: function featureInfo() {
      var infoFeatures = [];
      var index = 0;
      _.forEach(this.feature.attributes, function (value, key) {
        if (index > 2) return false;
        if (value && _.isString(value) && value.indexOf('/') === -1) {
          infoFeatures.push({
            key: key,
            value: value
          });
          index += 1;
        }
      });
      return infoFeatures;
    }
  },
  mounted: function mounted() {
    if (this.relations.length === 1) {
      var relation = this.relations[0];
      relation.noback = true;
      this.showRelation(relation);
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.relations.length === 1) {
      delete this.relations[0].noback;
    }
  }
});
/*-----------------------------------*/
var relationDataTable = void 0;
/* Relation Table */
var relationComponent = {
  template: require('./relation.html'),
  props: ['table', 'relation', 'previousview'],
  inject: ['relationnoback'],
  components: {
    Field: Field
  },
  computed: {
    showrelationslist: function showrelationslist() {
      return this.previousview === 'relations' && !this.relationnoback;
    },
    one: function one() {
      return this.relation.type === 'ONE';
    }
  },
  methods: {
    reloadLayout: function reloadLayout() {
      relationDataTable.columns.adjust();
    },

    back: function back() {
      this.$parent.setRelationsList();
    },
    getFieldType: function getFieldType(value) {
      var Fields = {};
      Fields.SIMPLE = 'simple';
      Fields.LINK = 'link';

      var URLPattern = /^(https?:\/\/[^\s]+)/g;
      if (_.isNil(value)) {
        return Fields.SIMPLE;
      }
      value = value.toString();

      if (value.match(URLPattern)) {
        return Fields.LINK;
      }

      return Fields.SIMPLE;
    },
    fieldIs: function fieldIs(type, value) {
      var fieldType = this.getFieldType(value);
      return fieldType === type;
    },
    is: function is(type, value) {
      return this.fieldIs(type, value);
    }
  },
  created: function created() {
    var _this = this;

    RelationPageEventBus.$on('reload', function () {
      _this.reloadLayout();
    });
  },
  mounted: function mounted() {
    var _this2 = this;

    this.relation.title = this.relation.name;
    this.$nextTick(function () {
      if (!_this2.one) {
        var tableHeight = $(".content").height();
        relationDataTable = $('#relationtable').DataTable({
          "pageLength": 10,
          "bLengthChange": false,
          "scrollY": tableHeight / 2 + "px",
          "scrollCollapse": true,
          "scrollX": true,
          "order": [0, 'asc']
        });
      }
    });
  }
};
/*-----------------------------------*/

var InternalComponent = Vue.extend({
  template: require('./relationspage.html'),
  data: function data() {
    return {
      state: null,
      error: false,
      table: this.$options.table ? this.$options.service.buildRelationTable(this.$options.table) : null,
      relation: this.$options.relation || null,
      relations: this.$options.relations,
      feature: this.$options.feature,
      currentview: this.$options.currentview,
      previousview: this.$options.currentview
    };
  },
  provide: function provide() {
    return {
      relationnoback: this.$options.relations.length === 1
    };
  },

  components: {
    'relations': relationsComponent,
    'relation': relationComponent
  },
  methods: {
    reloadLayout: function reloadLayout() {
      RelationPageEventBus.$emit('reload');
    },
    isOneRelation: function isOneRelation() {
      return this.relations.length === 1 && this.relations[0].type === 'ONE';
    },

    showRelation: function showRelation(relation) {
      var _this3 = this;

      this.relation = relation;
      var field = relation.fieldRef.referencedField;
      var value = this.feature.attributes[field];
      if (value === null || value === undefined) {
        try {
          var splitFieldPk = this.feature[field].split('.');
          value = splitFieldPk[splitFieldPk.length - 1];
        } catch (err) {} finally {
          if (value === null || value === undefined) {
            GUI.notify.error(t('sdk.relations.error_missing_father_field'));
            this.error = true;
            return;
          }
        }
      }
      GUI.setLoadingContent(true);
      this.$options.service.getRelations({
        id: relation.id,
        value: value
      }).then(function (relations) {
        _this3.table = _this3.$options.service.buildRelationTable(relations);
        _this3.currentview = 'relation';
        _this3.previousview = 'relations';
      }).catch(function (err) {}).finally(function () {
        GUI.setLoadingContent(false);
      });
    },
    setRelationsList: function setRelationsList() {
      this.previousview = 'relation';
      this.currentview = 'relations';
    }
  },
  beforeMount: function beforeMount() {
    this.isOneRelation() && this.showRelation(this.relations[0]);
  },
  mounted: function mounted() {
    var _this4 = this;

    this.$nextTick(function () {
      if (_this4.error) requestAnimationFrame(function () {
        GUI.popContent();
      });
      _this4.error = false;
    });
  }
});

var RelationsPage = function RelationsPage() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  var service = options.service || new Service({});
  var relations = options.relations || [];
  var relation = options.relation || null;
  var feature = options.feature || null;
  var table = options.table || null;
  var currentview = options.currentview || 'relations';
  this.setService(service);
  var internalComponent = new InternalComponent({
    previousview: currentview,
    service: service,
    relations: relations,
    relation: relation,
    feature: feature,
    currentview: currentview,
    table: table
  });
  this.setInternalComponent(internalComponent);
  internalComponent.state = service.state;
  this.layout = function () {
    internalComponent.reloadLayout();
  };
};

inherit(RelationsPage, Component);

module.exports = RelationsPage;

},{"../relationsservice":780,"./relation.html":781,"./relations.html":782,"./relationspage.html":783,"babel-runtime/helpers/extends":22,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/fields/g3w-field.vue":694,"gui/gui":710,"gui/vue/component":806,"gui/vue/utils":812}],785:[function(require,module,exports){
var _getIterator2 = require('babel-runtime/core-js/get-iterator');

var _getIterator3 = _interopRequireDefault(_getIterator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var ProjectsRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');
var SearchPanel = require('gui/search/vue/panel/searchpanel');

function Service() {
  var currentProjectState = ProjectsRegistry.getCurrentProject().state;
  this.title = currentProjectState.search_title || "search";
  this.init = function (searchesObject) {
    this.state.searches = searchesObject || currentProjectState.search;
  };
  this.state = {
    searches: [],
    searchtools: []
  };
}

inherit(Service, G3WObject);

var proto = Service.prototype;

proto.getTitle = function () {
  return this.title;
};

proto.showPanel = function () {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var panel = new SearchPanel(config);
  panel.show();
  return panel;
};

proto.cleanSearchPanels = function () {
  this.state.panels = {};
};

proto.stop = function () {
  var d = $.Deferred();
  d.resolve();
  return d.promise();
};

proto.addTool = function (searchTool) {
  this.state.searchtools.push(searchTool);
};

proto.addTools = function (searchTools) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = (0, _getIterator3.default)(searchTools), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var searchTool = _step.value;

      this.addTool(searchTool);
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
};

proto.removeTool = function (searchTool) {
  //TODO
};

proto.removeTools = function () {
  this.state.searchtools.splice(0);
};

proto.reload = function () {
  this.state.searches = ProjectsRegistry.getCurrentProject().state.search;
};

module.exports = Service;

},{"babel-runtime/core-js/get-iterator":4,"core/g3wobject":569,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/search/vue/panel/searchpanel":787}],786:[function(require,module,exports){
module.exports = "<div class=\"g3w-search-panel form-group\">\n  <h4><b>{{ state.title }}</b></h4>\n  <slot name=\"tools\"></slot>\n  <slot name=\"form\">\n    <form id=\"g3w-search-form\">\n      <template v-for=\"forminput in state.forminputs\" :key=\"forminput.id\">\n        <div v-if=\"forminput.type === 'numberfield'\" class=\"form-group numeric\">\n          <label :for=\"forminput.id + ' '\">{{ forminput.label }}</label>\n          <input\n            type=\"number\"\n            min=\"0\"\n            @change=\"changeNumericInput(forminput)\"\n            @keyup=\"changeNumericInput(forminput)\"\n            v-model=\"forminput.value\" class=\"form-control\"\n            :id=\"forminput.id\">\n        </div>\n        <div v-if=\"forminput.type === 'textfield' || forminput.type === 'textField'\" class=\"form-group form-item-search  text\">\n          <label :for=\"forminput.id\">{{ forminput.label }}</label>\n          <input @focus=\"onFocus\" type=\"text\" v-model=\"forminput.value\" class=\"form-control\" :id=\"forminput.id\" >\n        </div>\n        <div v-if=\"forminput.type === 'selectfield'\" class=\"form-group text\">\n          <label :for=\"forminput.id\">{{ forminput.label }}</label>\n          <bar-loader v-if =\"forminput.options.dependance\" :loading=\"state.loading[forminput.options.dependance]\"></bar-loader>\n          <select2 :forminput=\"forminput\" @select-change=\"changeInput\"></select2>\n        </div>\n      </template>\n      <div class=\"form-group\">\n        <button id=\"dosearch\" class=\"btn btn-block pull-right\" @click.stop=\"doSearch\" data-i18n=\"dosearch\" :disabled=\"state.searching\">Search</button>\n      </div>\n    </form>\n  </slot>\n  <slot name=\"footer\"></slot>\n</div>\n";

},{}],787:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _select = require('./select2.vue');

var _select2 = _interopRequireDefault(_select);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Panel = require('gui/panel');
var Service = require('./searchservice');
var compiledTemplate = Vue.compile(require('./searchpanel.html'));

var SearchPanelComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  components: {
    Select2: _select2.default
  },
  data: function data() {
    this.select2 = null;
    return {
      state: this.$options.service.state
    };
  },
  methods: {
    onFocus: function onFocus(event) {
      if (this.isMobile()) {
        var top = $(event.target).position().top - 10;
        this.$nextTick(function () {
          setTimeout(function () {
            $('.sidebar').scrollTop(top);
          }, 500);
        });
      }
    },
    changeDependencyFields: function changeDependencyFields(_ref) {
      var _this = this;

      var field = _ref.attribute,
          value = _ref.value,
          _ref$fillfieldspromis = _ref.fillfieldspromises,
          fillfieldspromises = _ref$fillfieldspromis === undefined ? [] : _ref$fillfieldspromis;

      var dependency = this.state.dependencies.find(function (_dependency) {
        return field === _dependency.observer;
      });
      if (dependency) {
        (function () {
          var subscribers = dependency.subscribers || [];

          var _loop = function _loop(i) {
            var forminputvalue = _this.state.forminputs.find(function (input) {
              return input.attribute === subscribers[i].attribute;
            });
            var dependance = subscribers[i].options.dependance;
            fillfieldspromises.push(_this.$options.service.fillDependencyInputs({
              field: field,
              dependance: dependance,
              subscribers: subscribers,
              value: value
            }));
            forminputvalue.value = '';
            _this.changeDependencyFields({
              attribute: forminputvalue.attribute,
              value: forminputvalue.value,
              fillfieldspromises: fillfieldspromises
            });
          };

          for (var i = subscribers.length; i--;) {
            _loop(i);
          }
        })();
      }
      return fillfieldspromises;
    },
    changeNumericInput: function changeNumericInput(input) {
      input.value = input.value || input.value === 0 ? input.value : null;
    },
    changeInput: function changeInput() {
      var _this2 = this;

      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          attribute = _ref2.attribute,
          value = _ref2.value;

      this.$options.service.changeInput({ attribute: attribute, value: value });
      //check id there are dependencies
      var fillDependencyPromises = this.changeDependencyFields({
        attribute: attribute,
        value: value
      });
      if (fillDependencyPromises.length) {
        this.state.searching = true;
        _promise2.default.all(fillDependencyPromises).then(function () {
          _this2.state.searching = false;
        });
      }
    },

    doSearch: function doSearch(event) {
      event.preventDefault();
      this.$options.service.run();
    }
  }
}));

function SearchPanel() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var service = options.service || new Service(options);
  var SearchPanel = options.component || SearchPanelComponent;
  var internalPanel = new SearchPanel({
    service: service
  });
  this.setInternalPanel(internalPanel);
  this.unmount = function () {
    return base(this, 'unmount').then(function () {
      service.clear();
    });
  };
}

inherit(SearchPanel, Panel);

module.exports = SearchPanel;

},{"./searchpanel.html":786,"./searchservice":788,"./select2.vue":789,"babel-runtime/core-js/promise":16,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/panel":770}],788:[function(require,module,exports){
var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

var _set = require('babel-runtime/core-js/set');

var _set2 = _interopRequireDefault(_set);

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var t = require('core/i18n/i18n.service').t;
var GUI = require('gui/gui');
var G3WObject = require('core/g3wobject');
var CatalogLayersStorRegistry = require('core/catalog/cataloglayersstoresregistry');
var ProjectsRegistry = require('core/project/projectsregistry');
var Filter = require('core/layers/filter/filter');
var Expression = require('core/layers/filter/expression');

function SearchService() {
  var _this = this;

  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.debounces = {
    run: {
      fnc: function fnc() {
        _this._run.apply(_this, arguments);
      }
    }
  };
  base(this);
  // reactivity data
  this.state = {
    title: null,
    dependencies: [],
    cachedependencies: {},
    forminputs: [],
    loading: {},
    searching: false
  };
  this.depedencies = {};
  this.project = ProjectsRegistry.getCurrentProject();
  this.searchLayer = null;
  this.filter = null;
  this.currentFilter = {};
  this._rootFilterOperator = 'AND';
  this.init = function (config) {
    this.state.title = config.name;
    var options = config.options || {};
    this.url = options.queryurl;
    this.filter = options.filter;
    var layerid = options.querylayerid || options.layerid || null;
    this.searchLayer = CatalogLayersStorRegistry.getLayerById(layerid);
    var filter = options.filter || { AND: [] };
    this._rootFilterOperator = (0, _keys2.default)(filter)[0];
    this.fillInputsFormFromFilter({ filter: filter });
  };
  // set run function
  return this.init(config);
}

inherit(SearchService, G3WObject);

var proto = SearchService.prototype;

proto._run = function () {
  var _this2 = this;

  this.state.searching = true;
  var filter = this.fillFilterInputsWithValues();
  GUI.closeContent();
  var showQueryResults = GUI.showContentFactory('query');
  var queryResultsPanel = showQueryResults(this.state.title);
  var expression = new Expression();
  var layerName = this.searchLayer.getWMSLayerName();
  expression.createExpressionFromFilter(filter, layerName);
  var _filter = new Filter();
  _filter.setExpression(expression.get());
  this.searchLayer.search({
    filter: _filter,
    queryUrl: this.url,
    feature_count: 10000
  }).then(function (results) {
    results = {
      data: results
    };
    queryResultsPanel.onceafter('postRender', function () {
      _this2.state.searching = false;
    });
    queryResultsPanel.setQueryResponse(results);
  }).fail(function (err) {
    GUI.notify.error(t('server_error'));
    GUI.closeContent();
    _this2.state.searching = false;
  });
};

proto.changeInput = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      attribute = _ref.attribute,
      value = _ref.value;

  var input = this.state.forminputs.find(function (input) {
    return attribute === input.attribute;
  });
  input.value = value;
};

proto.createQueryFilterFromConfig = function (_ref2) {
  var filter = _ref2.filter;

  var queryFilter = void 0;
  function createOperatorObject(inputObj) {
    for (var _operator2 in inputObj) {
      var input = inputObj[_operator2];
      if (Array.isArray(input)) {
        createBooleanObject(_operator2, input);
        break;
      }
    }
    var field = inputObj.attribute;
    var operator = inputObj.op;
    var evalObject = {};
    evalObject[operator] = {};
    evalObject[operator][field] = null;
    return evalObject;
  }

  function createBooleanObject(booleanOperator) {
    var inputs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    var booleanObject = {};
    booleanObject[booleanOperator] = [];
    inputs.forEach(function (input) {
      booleanObject[booleanOperator].push(createOperatorObject(input));
    });
    return booleanObject;
  }
  for (var operator in filter) {
    var inputs = filter[operator];
    queryFilter = createBooleanObject(operator, inputs);
  }
  return queryFilter;
};

proto._getExpressionOperatorFromInput = function (field) {
  var dependanceCascadeField = this.filter[this._rootFilterOperator].find(function (input) {
    return input.attribute === field;
  });
  return dependanceCascadeField ? dependanceCascadeField.op : null;
};

proto._getCascadeDependanciesFilter = function (field) {
  var dependencies = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

  var dependanceCascadeField = this.filter[this._rootFilterOperator].find(function (input) {
    return input.attribute === field;
  });
  var dependance = dependanceCascadeField.input.options.dependance;
  if (dependance) {
    dependencies.unshift(dependance);
    this._getCascadeDependanciesFilter(dependance, dependencies);
  }
  return dependencies;
};

proto._getDependanceCurrentValue = function (field) {
  var dependance = this.depedencies[field];
  return this.state.cachedependencies[dependance]._currentValue;
};

proto.fillDependencyInputs = function () {
  var _this3 = this;

  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      field = _ref3.field,
      _ref3$subscribers = _ref3.subscribers,
      subscribers = _ref3$subscribers === undefined ? [] : _ref3$subscribers,
      _ref3$value = _ref3.value,
      value = _ref3$value === undefined ? '' : _ref3$value;

  var isRoot = this.depedencies.root === field;
  return new _promise2.default(function (resolve, reject) {
    subscribers.forEach(function (subscribe) {
      subscribe.options.disabled = true;
      subscribe.value = '';
      subscribe.options.values.splice(1);
    });
    if (value) {
      var isCached = false;
      var rootValues = void 0;
      if (isRoot) {
        isCached = _this3.state.cachedependencies[field] && _this3.state.cachedependencies[field][value];
        rootValues = isCached && _this3.state.cachedependencies[field][value];
      } else {
        var dependenceValue = _this3._getDependanceCurrentValue(field);
        isCached = _this3.state.cachedependencies[field] && _this3.state.cachedependencies[field][dependenceValue] && _this3.state.cachedependencies[field] && _this3.state.cachedependencies[field][dependenceValue][value];
        rootValues = isCached && _this3.state.cachedependencies[field][dependenceValue][value];
      }
      if (isCached) {
        for (var i = 0; i < subscribers.length; i++) {
          var subscribe = subscribers[i];
          var values = rootValues[subscribe.attribute];
          if (values && values.length) {
            for (var _i = 0; _i < values.length; _i++) {
              subscribe.options.values.push(values[_i]);
            }
            subscribe.options.disabled = false;
          }
          resolve();
        }
      } else {
        _this3.queryService = GUI.getComponent('queryresults').getService();
        _this3.state.loading[field] = true;
        _this3.state.cachedependencies[field] = _this3.state.cachedependencies[field] || {};
        _this3.state.cachedependencies[field]._currentValue = value;
        if (isRoot) _this3.state.cachedependencies[field][value] = _this3.state.cachedependencies[field][value] || {};else {
          var _dependenceValue = _this3._getDependanceCurrentValue(field);
          _this3.state.cachedependencies[field][_dependenceValue] = _this3.state.cachedependencies[field][_dependenceValue] || {};
          _this3.state.cachedependencies[field][_dependenceValue][value] = _this3.state.cachedependencies[field][_dependenceValue][value] || {};
        }
        var equality = {};
        var inputFilterObject = {};
        equality[field] = value;
        var operator = _this3._getExpressionOperatorFromInput(field);
        inputFilterObject[operator] = equality;
        var filter = {};
        filter[_this3._rootFilterOperator] = [inputFilterObject];
        _this3._getCascadeDependanciesFilter(field).forEach(function (dependanceField) {
          filter[_this3._rootFilterOperator].splice(filter[_this3._rootFilterOperator].length - 1, 0, _this3.currentFilter[dependanceField]);
        });
        var expression = new Expression();
        var layerName = _this3.searchLayer.getWMSLayerName();
        expression.createExpressionFromFilter(filter, layerName);
        var _filter = new Filter();
        _filter.setExpression(expression.get());
        _this3.currentFilter[field] = inputFilterObject;
        _this3.searchLayer.search({
          filter: _filter,
          feature_count: 10000 //SET HIGHT LEVEL OF FEATURE COUNT TO GET MAXIMUM RESPONSES
        }).then(function (response) {
          var digestResults = _this3.queryService._digestFeaturesForLayers(response);
          if (digestResults.length) {
            var features = digestResults[0].features;

            var _loop = function _loop(_i2) {
              var subscribe = subscribers[_i2];
              var uniqueValue = new _set2.default();
              features.forEach(function (feature) {
                var value = feature.attributes[subscribe.attribute];
                if (value && !uniqueValue.has(value)) {
                  subscribe.options.values.push(value);
                  uniqueValue.add(value);
                }
              });
              subscribe.options.values.sort();
              if (isRoot) _this3.state.cachedependencies[field][value][subscribe.attribute] = subscribe.options.values.slice(1);else {
                var _dependenceValue2 = _this3._getDependanceCurrentValue(field);
                _this3.state.cachedependencies[field][_dependenceValue2][value][subscribe.attribute] = subscribe.options.values.slice(1);
              }
              subscribe.options.disabled = false;
            };

            for (var _i2 = 0; _i2 < subscribers.length; _i2++) {
              _loop(_i2);
            }
          }
        }).fail(function (err) {
          reject(err);
        }).always(function () {
          _this3.state.loading[field] = false;
          resolve();
        });
      }
    } else {
      resolve();
    }
  });
};

proto._checkInputDependencies = function (forminput) {
  var dependance = forminput.options.dependance;

  var dependency = this.state.dependencies.find(function (_dependency) {
    return _dependency.observer === dependance;
  });
  !dependency && this.state.dependencies.push({
    observer: dependance,
    subscribers: [forminput]
  }) || dependency.subscribers.push(forminput);
};

proto.fillInputsFormFromFilter = function (_ref4) {
  var _this4 = this;

  var filter = _ref4.filter;

  var id = 0;
  for (var operator in filter) {
    var inputs = filter[operator];
    inputs.forEach(function (input) {
      var forminput = {
        label: input.label,
        attribute: input.attribute,
        type: input.input.type || 'textfield',
        options: (0, _assign2.default)({}, input.input.options),
        value: '',
        id: input.id || id
      };
      if (forminput.type === 'selectfield') {
        var dependance = forminput.options.dependance;
        if (dependance) {
          _this4.depedencies[forminput.attribute] = dependance;
          _this4.state.loading[dependance] = false;
          forminput.options.disabled = true;
          _this4._checkInputDependencies(forminput);
        } else {
          _this4.depedencies.root = forminput.attribute;
        }
        if (forminput.options.values[0] !== '') forminput.options.values.unshift('');
        forminput.value = '';
      } else forminput.value = null;
      _this4.state.forminputs.push(forminput);
      id += 1;
    });
  }
};

proto.createQueryFilterObject = function () {
  var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref5$ogcService = _ref5.ogcService,
      ogcService = _ref5$ogcService === undefined ? 'wms' : _ref5$ogcService,
      _ref5$filter = _ref5.filter,
      filter = _ref5$filter === undefined ? {} : _ref5$filter;

  var info = this.getInfoFromLayer(ogcService);
  (0, _assign2.default)(info, {
    ogcService: ogcService,
    filter: filter
  });
  return info;
};

proto.getInfoFromLayer = function (ogcService) {
  var queryUrl = ogcService === 'wfs' ? this.searchLayer.getProject().getWmsUrl() : this.searchLayer.getQueryUrl();
  return {
    url: queryUrl,
    layers: [],
    infoFormat: this.searchLayer.getInfoFormat(ogcService),
    crs: this.searchLayer.getCrs(),
    serverType: this.searchLayer.getServerType()
  };
};

proto.fillFilterInputsWithValues = function () {
  var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.filter;

  var _this5 = this;

  var filterWithValues = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var exclude = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

  var forminputs = this.state.forminputs;
  var getvaluefromforminputid = [];

  var _loop2 = function _loop2(operator) {
    filterWithValues[operator] = [];
    var inputs = filter[operator];
    inputs.forEach(function (input) {
      var _input = input.input;
      if (exclude.indexOf(_input.attribute) === -1) if (Array.isArray(_input)) {
        _this5.fillFilterInputsWithValues(_input);
      } else {
        var _operator = input.op;
        var fieldName = input.attribute;
        var filterInput = {};
        filterInput[_operator] = {};
        var forminputwithvalue = forminputs.find(function (forminput) {
          return forminput.attribute === fieldName && getvaluefromforminputid.indexOf(forminput.id) === -1;
        });
        getvaluefromforminputid.push(forminputwithvalue.id);
        var value = forminputwithvalue.value;
        filterInput[_operator][fieldName] = value;
        filterWithValues[operator].push(filterInput);
      }
    });
  };

  for (var operator in filter) {
    _loop2(operator);
  }
  return filterWithValues;
};

proto.setSearchLayer = function (layer) {
  this.searchLayer = layer;
};

proto.getSearchLayer = function () {
  return this.searchLayer;
};

proto.clear = function () {
  this.state = null;
};

module.exports = SearchService;

},{"babel-runtime/core-js/object/assign":10,"babel-runtime/core-js/object/keys":14,"babel-runtime/core-js/promise":16,"babel-runtime/core-js/set":17,"core/catalog/cataloglayersstoresregistry":561,"core/g3wobject":569,"core/i18n/i18n.service":572,"core/layers/filter/expression":583,"core/layers/filter/filter":584,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/gui":710}],789:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var t = require('core/i18n/i18n.service').t;
exports.default = {
  name: "select2",
  props: ['forminput'],
  methods: {
    _initSelect2Element: function _initSelect2Element() {
      var _this = this;

      this.select2 = $(this.$el).select2({
        width: '100%',
        matcher: function matcher(params, data) {
          var searchItem = params.term ? params.term.toLowerCase() : params.term;

          if ($.trim(searchItem) === '') {
            return data;
          }

          if (typeof data.text === 'undefined') {
            return null;
          }

          if (data.text.toLowerCase().indexOf(searchItem) > -1) {
            var modifiedData = $.extend({}, data, true);

            return modifiedData;
          }

          return null;
        },
        "language": {
          "noResults": function noResults() {
            return t("no_results");
          }
        }
      });
      this.select2.on('select2:select', function (evt) {
        var attribute = $(evt.target).attr('name');
        var value = evt.params.data.id;
        _this.$emit('select-change', {
          attribute: attribute,
          value: value
        });
      });
    }
  },
  watch: {
    'forminput.value': function forminputValue(value) {
      if (!value) this.select2.val('');
    }
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2._initSelect2Element();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.select2.select2('destroy');
    this.select2 = null;
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('select',{staticClass:"form-control",attrs:{"name":_vm.forminput.attribute,"id":_vm.forminput.id,"disabled":_vm.forminput.options.disabled}},_vm._l((_vm.forminput.options.values),function(value){return _c('option',{key:value,domProps:{"value":value}},[(value === '')?_c('span',{directives:[{name:"t",rawName:"v-t",value:('sdk.search.all'),expression:"'sdk.search.all'"}]}):_c('span',[_vm._v(_vm._s(value))])])}),0)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-56e33878"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-56e33878", __vue__options__)
  } else {
    hotAPI.reload("data-v-56e33878", __vue__options__)
  }
})()}

},{"core/i18n/i18n.service":572,"vue":515,"vue-hot-reload-api":513}],790:[function(require,module,exports){
module.exports = "<ul id=\"g3w-search\" class=\"treeview-menu g3w-search g3w-tools menu-items\">\n  <li v-for=\"search in state.searches\" class=\"menu-item\" @click=\"showPanel(search)\">\n    <i :class=\"g3wtemplate.getFontClass('empty-circle')\"></i>\n    <span>{{ search.name }}</span>\n  </li>\n  <li v-for=\"searchtool in state.searchtools\">\n    <g3w-tool :tool=\"searchtool\"></g3w-tool>\n  </li>\n</ul>\n";

},{}],791:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _tool = require('gui/tools/vue/tool.vue');

var _tool2 = _interopRequireDefault(_tool);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var ProjectsRegistry = require('core/project/projectsregistry');
var Service = require('gui/search/service');
var templateCompiled = (0, _utils.createCompiledTemplate)(require('./search.html'));

var vueComponentOptions = (0, _extends3.default)({}, templateCompiled, {
  data: function data() {
    return {
      state: null
    };
  },
  components: {
    G3wTool: _tool2.default
  },
  methods: {
    showPanel: function showPanel() {
      var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      this.$options.service.showPanel(config);
    }
  }
});

var InternalComponent = Vue.extend(vueComponentOptions);

function SearchComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this.id = "search";
  this._service = options.service || new Service();
  this._service.init();
  this.title = this._service.getTitle();
  this.internalComponent = new InternalComponent({
    service: this._service
  });
  this.internalComponent.state = this._service.state;
  this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;

  this._reload = function () {
    this.state.visible = ProjectsRegistry.getCurrentProject().state.search.length > 0;
    this._service.reload();
  };
}

inherit(SearchComponent, Component);

module.exports = SearchComponent;

},{"./search.html":790,"babel-runtime/helpers/extends":22,"core/project/projectsregistry":624,"core/utils/utils":630,"gui/search/service":785,"gui/tools/vue/tool.vue":803,"gui/vue/component":806,"gui/vue/utils":812}],792:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var StreetViewComponent = require('gui/streetview/vue/streetview');

function StreetViewService() {
  this._position = null;
  this.setters = {
    postRender: function postRender(position) {}
  };

  this.getPosition = function () {
    return this._position;
  };

  this.showStreetView = function (position) {
    this._position = position;
    GUI.setContent({
      content: new StreetViewComponent({
        service: this
      }),
      title: 'StreetView'
    });
  };
  base(this);
}

inherit(StreetViewService, G3WObject);

module.exports = StreetViewService;

},{"core/g3wobject":569,"core/utils/utils":630,"gui/gui":710,"gui/streetview/vue/streetview":794}],793:[function(require,module,exports){
module.exports = "<div id=\"streetview\"></div>";

},{}],794:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Component = require('gui/vue/component');
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./streetview.html'));

var InternalComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null
    };
  },
  mounted: function mounted() {
    var _this = this;

    this.$nextTick(function () {
      var position = _this.$options.service.getPosition();
      _this.$options.service.postRender(position);
    });
  }
}));

var StreetViewComponent = function StreetViewComponent(options) {
  base(this);
  options = options || {};
  var service = options.service;
  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  this.unmount = function () {
    return base(this, 'unmount');
  };
};

inherit(StreetViewComponent, Component);

module.exports = StreetViewComponent;

},{"./streetview.html":793,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/vue/component":806,"gui/vue/utils":812}],795:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GUI = require('gui/gui');
var t = require('core/i18n/i18n.service').t;
var coordinatesToGeometry = require('core/utils/geo').coordinatesToGeometry;

var TableService = function TableService() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.currentPage = 0; // number of pages
  this.layer = options.layer;
  var headers = this.getHeaders(this.layer.getTableFields());
  this.projection = this.layer.state.geolayer ? this.layer.getProjection() : null;
  this.state = {
    pageLengths: [10, 25, 50],
    features: [],
    title: this.layer.getTitle(),
    headers: headers,
    geometry: true,
    loading: false,
    allfeatures: 0,
    featurescount: 0,
    pagination: true,
    hasGeometry: false
  };
};

var proto = TableService.prototype;

proto.getHeaders = function (fields) {
  var headers = fields.filter(function (field) {
    return ['boundedBy', 'geom', 'the_geom', 'geometry', 'bbox', 'GEOMETRY', 'geometria'].indexOf(field.name) === -1;
  });
  return headers;
};

// function need to work with pagination
proto.setDataForDataTable = function () {
  var _this = this;

  var data = [];
  this.state.features.forEach(function (feature) {
    var attributes = feature.attributes ? feature.attributes : feature.properties;
    var values = [];
    _this.state.headers.forEach(function (header) {
      values.push(attributes[header.name]);
    });
    data.push(values);
  });
  return data;
};

proto.getData = function () {
  var _this2 = this;

  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$start = _ref.start,
      start = _ref$start === undefined ? 0 : _ref$start,
      _ref$order = _ref.order,
      order = _ref$order === undefined ? [] : _ref$order,
      _ref$length = _ref.length,
      length = _ref$length === undefined ? this.state.pageLengths[0] : _ref$length,
      _ref$search = _ref.search,
      search = _ref$search === undefined ? { value: null } : _ref$search;

  // reset features before load
  return new _promise2.default(function (resolve, reject) {
    if (!_this2.state.headers.length) resolve({
      data: [],
      recordsTotal: 0,
      recordsFiltered: 0
    });else {
      var searchText = search.value && search.value.length > 0 ? search.value : null;
      _this2.state.features.splice(0);
      if (!order.length) {
        order.push({
          column: 0,
          dir: 'asc'
        });
      }
      var ordering = order[0].dir === 'asc' ? _this2.state.headers[order[0].column].name : '-' + _this2.state.headers[order[0].column].name;
      _this2.currentPage = start === 0 ? 1 : start / length + 1;
      _this2.layer.getDataTable({
        page: _this2.currentPage,
        page_size: length,
        search: searchText,
        ordering: ordering
      }).then(function (data) {
        var features = data.features;
        _this2.addFeatures(features, data.pk, data.pkField);
        _this2.state.pagination = !!data.count;
        _this2.state.allfeatures = data.count || _this2.state.features.length;
        _this2.state.featurescount += features.length;
        resolve({
          data: _this2.setDataForDataTable(),
          recordsFiltered: _this2.state.allfeatures,
          recordsTotal: _this2.state.allfeatures
        });
      }).fail(function (err) {
        GUI.notify.error(t("info.server_error"));
        reject(err);
      });
    }
  });
};

proto.addFeature = function (feature) {
  var tableFeature = {
    attributes: feature.attributes ? feature.attributes : feature.properties,
    geometry: this._returnGeometry(feature)
  };
  this.state.features.push(tableFeature);
};

proto.addFeatures = function (features, pk, pkField) {
  var _this3 = this;

  this.state.hasGeometry = this.hasGeometry(features);
  pk && this._addPkProperties(features, pkField);
  features.forEach(function (feature) {
    _this3.addFeature(feature);
  });
};

proto._setLayout = function () {
  //TODO
};

proto._returnGeometry = function (feature) {
  var geometry = void 0;
  if (feature.attributes) {
    geometry = feature.geometry;
  } else if (feature.geometry) {
    geometry = coordinatesToGeometry(feature.geometry.type, feature.geometry.coordinates);
  }
  return geometry;
};

proto.hasGeometry = function (features) {
  if (features.length) {
    return !!features[0].geometry;
  }
  return false;
};

proto._addPkProperties = function (features, pkField) {
  var _this4 = this;

  features.forEach(function (feature) {
    var _pkField = _this4.state.headers.find(function (header) {
      return header.name === pkField;
    });
    if (_pkField) feature.properties[_pkField.name] = feature.id;
  });
};

proto.zoomAndHighLightSelectedFeature = function (feature) {
  var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var geometry = feature.geometry;
  if (geometry) {
    var mapService = GUI.getComponent('map').getService();
    mapService.highlightGeometry(geometry, {
      zoom: zoom
    });
  }
};

module.exports = TableService;

},{"babel-runtime/core-js/promise":16,"core/i18n/i18n.service":572,"core/utils/geo":629,"gui/gui":710}],796:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".geometry[data-v-28f7782a] {\n  cursor: pointer\n}\n#noheaders[data-v-28f7782a] {\n  background-color: #ffffff;\n  font-weight: bold;\n  margin-top: 10px;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _tablebody = require('./components/tablebody.vue');

var _tablebody2 = _interopRequireDefault(_tablebody);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Field = require('gui/fields/g3w-field.vue');
var debounce = require('core/utils/utils').debounce;
var dataTable = void 0;
var fieldsComponents = [];
exports.default = {
  name: "G3WTable",
  data: function data() {
    return {
      tableBodyComponent: null,
      state: null,
      table: null,
      selectedRow: null
    };
  },
  components: {
    TableBody: _tablebody2.default
  },
  methods: {
    _setLayout: function _setLayout() {
      this.$options.service._setLayout();
    },
    zoomAndHighLightSelectedFeature: function zoomAndHighLightSelectedFeature(feature) {
      var zoom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

      if (this.state.geometry) this.$options.service.zoomAndHighLightSelectedFeature(feature, zoom);
    },
    reloadLayout: function reloadLayout() {
      this.$nextTick(function () {
        dataTable.responsive.recalc();
        dataTable.columns.adjust();
      });
    },
    hasHeaders: function hasHeaders() {
      return !!this.state.headers.length;
    },
    createTdContentBody: function createTdContentBody() {
      var _this = this;

      var self = this;
      fieldsComponents = fieldsComponents.filter(function (fieldComponent) {
        fieldComponent.$destroy();
        return false;
      });
      $('#layer_attribute_table tbody tr').each(function (index, element) {
        var feature = _this.state.features[index];
        if (feature) {
          if (_this.state.hasGeometry) $(element).on('click', function () {
            if ($(this).hasClass("selected")) $(this).removeClass("selected");else {
              $('#layer_attribute_table tbody tr').removeClass('selected');
              $(this).addClass("selected");
            }
            self.zoomAndHighLightSelectedFeature(feature);
          });
          $(element).children().each(function (index, element) {
            var header = _this.state.headers[index];
            var fieldClass = Vue.extend(Field);
            var fieldInstance = new fieldClass({
              propsData: {
                state: {
                  value: feature.attributes[header.name]
                }
              }
            });
            fieldInstance.$mount();
            fieldsComponents.push(fieldInstance);
            $(element).html(fieldInstance.$el);
          });
        }
      });
      setTimeout(function () {
        _this.reloadLayout();
      }, 0);
    }
  },
  created: function created() {},

  mounted: function mounted() {
    var _this2 = this;

    var hideElements = function hideElements() {
      $('.dataTables_info, .dataTables_length').hide();
      $('#layer_attribute_table_previous, #layer_attribute_table_next').hide();
      $('.dataTables_filter').css('float', 'right');
      $('.dataTables_paginate').css('margin', '0');
    };
    this.$nextTick(function () {
      _this2.first = false;
      if (_this2.state.pagination) {
        dataTable = $('#open_attribute_table table').DataTable({
          "lengthMenu": _this2.state.pageLengths,
          "scrollX": true,
          "scrollCollapse": true,
          "order": [0, 'asc'],
          "columns": _this2.state.headers,
          "ajax": debounce(function (data, callback) {
            _this2.$options.service.getData(data).then(function (serverData) {
              callback(serverData);
              _this2.$nextTick(function () {
                _this2.createTdContentBody();
                if (_this2.isMobile()) {
                  hideElements();
                }
              });
            }).catch(function (error) {
              console.log(error);
            });
          }, 800),
          "serverSide": true,
          "processing": true,

          "deferLoading": _this2.state.allfeatures
        });
      } else {
        dataTable = $('#open_attribute_table table').DataTable({
          "lengthMenu": _this2.state.pageLengths,
          "scrollX": true,
          "scrollCollapse": true,
          "order": [0, 'asc']
        });
      }
      if (_this2.isMobile()) {
        hideElements();
      }
      var tableHeight = $(".content").height();
      var tableHeaderHeight = $('#open_attribute_table  div.dataTables_scrollHeadInner').height();
      $('#open_attribute_table  div.dataTables_scrollBody').height(tableHeight - tableHeaderHeight - 130);
    });
  },
  beforeDestroy: function beforeDestroy() {
    dataTable.destroy();
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{"id":"open_attribute_table"}},[(_vm.hasHeaders())?_c('table',{staticClass:"table table-striped display compact nowrap",staticStyle:{"width":"100%"},attrs:{"id":"layer_attribute_table"}},[_c('thead',[_c('tr',_vm._l((_vm.state.headers),function(header){return _c('th',[_vm._v(_vm._s(header.label))])}),0)]),_vm._v(" "),_c('table-body',{attrs:{"headers":_vm.state.headers,"features":_vm.state.features,"hasGeometry":_vm.state.hasGeometry,"zoomAndHighLightSelectedFeature":_vm.zoomAndHighLightSelectedFeature}})],1):_c('div',{directives:[{name:"t",rawName:"v-t",value:('dataTable.no_data'),expression:"'dataTable.no_data'"}],attrs:{"id":"noheaders"}})])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-28f7782a"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-28f7782a", __vue__options__)
  } else {
    hotAPI.reload("data-v-28f7782a", __vue__options__)
  }
})()}

},{"./components/tablebody.vue":797,"core/utils/utils":630,"gui/fields/g3w-field.vue":694,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],797:[function(require,module,exports){
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var Field = require('gui/fields/g3w-field.vue');
exports.default = {
  name: "table-body",
  props: {
    headers: {
      required: true,
      type: Array
    },
    features: {
      required: true,
      type: Array
    },
    zoomAndHighLightSelectedFeature: {
      type: Function
    },
    hasGeometry: {
      type: Boolean
    }
  },
  data: function data() {
    return {
      selectedRow: null
    };
  },

  methods: {
    toggleRow: function toggleRow(index) {
      this.selectedRow = this.selectedRow === index ? null : index;
    }
  },
  components: {
    Field: Field
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('tbody',{attrs:{"id":"table_body_attributes"}},_vm._l((_vm.features),function(feature,index){return _c('tr',{key:index,staticClass:"feature_attribute",class:[index %2 == 1 ? 'odd' : 'pair', {geometry: _vm.hasGeometry}],attrs:{"role":"row","id":'open_table_row_' + index,"selected":_vm.selectedRow === index},on:{"mouseover":function($event){return _vm.zoomAndHighLightSelectedFeature(feature, false)},"click":function($event){_vm.zoomAndHighLightSelectedFeature(feature); _vm.toggleRow(index)}}},_vm._l((_vm.headers),function(header){return _c('td',{attrs:{"tab-index":1}},[_c('field',{attrs:{"state":{value: feature.attributes[header.name]}}})],1)}),0)}),0)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-58f0f68a"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-58f0f68a", __vue__options__)
  } else {
    hotAPI.reload("data-v-58f0f68a", __vue__options__)
  }
})()}

},{"gui/fields/g3w-field.vue":694,"vue":515,"vue-hot-reload-api":513}],798:[function(require,module,exports){
var _Table = require('./Table.vue');

var _Table2 = _interopRequireDefault(_Table);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var t = require('core/i18n/i18n.service').t;
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var TableService = require('../tableservice');


var InternalComponent = Vue.extend(_Table2.default);

var TableComponent = function TableComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this);
  this.id = "openattributetable";
  var layer = options.layer;
  var service = options.service || new TableService({
    layer: layer
  });

  this.setService(service);
  var internalComponent = new InternalComponent({
    service: service
  });
  this.setInternalComponent(internalComponent);
  internalComponent.state = service.state;

  this.unmount = function () {
    return base(this, 'unmount');
  };

  this.layout = function () {
    internalComponent.reloadLayout();
  };
};

inherit(TableComponent, Component);

var proto = TableComponent.prototype;

// overwrite show method
proto.show = function () {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var service = this.getService();
  service.getData().then(function () {
    GUI.showContent({
      content: _this,
      perc: 50,
      split: GUI.isMobile() ? 'h' : 'v',
      push: false,
      title: options.title
    });
  }).catch(function (err) {
    GUI.notify.error(t("info.server_error"));
  }).finally(function () {
    _this.emit('show');
  });
};

proto.unmount = function () {
  return base(this, 'unmount').then(function () {});
};

module.exports = TableComponent;

},{"../tableservice":795,"./Table.vue":796,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/gui":710,"gui/vue/component":806}],799:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".group[data-v-574578ba] {\n  padding: 5px;\n  margin-bottom: 10px;\n}\n.sub-group[data-v-574578ba] {\n  border-radius: 5px;\n}\n.title[data-v-574578ba] {\n  font-weight: bold;\n  font-size: 1.1em;\n  width: 100%;\n  color: #ffffff;\n  padding: 5px;\n  border-radius: 2px;\n}\n.row[data-v-574578ba] {\n  margin-bottom: 5px;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _g3wInput = require('../inputs/g3w-input.vue');

var _g3wInput2 = _interopRequireDefault(_g3wInput);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Fields = require('gui/fields/fields');
var ProjectRegistry = require('core/project/projectsregistry');
var RelationsService = require('core/relations/relationsservice');
var RelationPage = require('gui/relations/vue/relationspage');
var GUI = require('gui/gui');
var COLUMNCLASSES = {
  1: 'col-md-12',
  2: 'col-md-6',
  3: 'col-md-4',
  4: 'col-md-3',
  5: 'col-md-2',
  6: 'col-md-2',
  7: 'col-md-1',
  8: 'col-md-1',
  9: 'col-md-1',
  10: 'col-md-1',
  11: 'col-md-1',
  12: 'col-md-1'
};
exports.default = {
  name: "node",
  props: ['contenttype', 'node', 'fields', 'showTitle', 'addToValidate', 'changeInput'],
  components: (0, _extends3.default)({
    G3wInput: _g3wInput2.default
  }, Fields),
  data: function data() {
    return {
      context: this.contenttype
    };
  },

  computed: {
    filterNodes: function filterNodes() {
      var _this = this;

      var filterNodes = this.node.nodes && this.node.nodes.filter(function (node) {
        if (_this.getNodeType(node) === 'group') {
          return true;
        } else if (!node.nodes && node.name && _this.getNodeType(node) != 'group') {
          node.relation = true;
          return true;
        } else {
          return !!_this.fields.find(function (field) {
            return field.name === node.field_name || node.relation;
          });
        }
      });
      return filterNodes || [];
    },
    nodesLength: function nodesLength() {
      return this.filterNodes.length;
    },
    rows: function rows() {
      var rowCount = 1;
      if (this.nodesLength === 0) rowCount = 0;else if (this.columnNumber <= this.nodesLength) {
        var rest = this.nodesLength % this.columnNumber;
        rowCount = Math.floor(this.nodesLength / this.columnNumber) + rest;
      }
      return rowCount;
    },
    columnClass: function columnClass() {
      return COLUMNCLASSES[this.columnNumber];
    },
    columnNumber: function columnNumber() {
      var columnCount = parseInt(this.node.columncount) ? parseInt(this.node.columncount) : 1;
      return columnCount > this.nodesLength ? this.nodesLength : columnCount;
    },
    showGroupTile: function showGroupTile() {
      return this.showTitle && this.node.showlabel && this.node.groupbox;
    }
  },
  methods: {
    getRelationName: function getRelationName(relationId) {
      var relation = ProjectRegistry.getCurrentProject().getRelationById(relationId);
      return relation.name;
    },
    showRelation: function showRelation(relationId) {
      var relationService = new RelationsService();
      var relation = ProjectRegistry.getCurrentProject().getRelationById(relationId);
      var field = this.fields.find(function (field) {
        return field.name === relation.fieldRef.referencedField;
      });
      var value = field.value;
      relationService.getRelations({
        value: value,
        id: relationId
      }).then(function (response) {
        var content = new RelationPage({
          currentview: 'relation',
          relations: [relation],
          relation: relation,
          table: response
        });
        GUI.pushContent({
          content: content,
          perc: 100
        });
      });
    },
    getNodes: function getNodes(row) {
      var startIndex = (row - 1) * this.columnNumber;
      return this.filterNodes.slice(startIndex, this.columnNumber + startIndex);
    },
    getNode: function getNode(row, column) {
      return this.getNodes(row)[column - 1];
    },
    getField: function getField(node) {
      if (node.relation) return node;
      var field = this.fields.find(function (field) {
        return field.name === node.field_name;
      });
      field.label = field.label || node.alias;
      return field;
    },
    getNodeType: function getNodeType(node) {
      var type = node.groupbox || node.nodes ? 'group' : node.relation ? 'relation' : 'field';
      if (type === 'field' && (node.alias === undefined || node.alias === '')) {
        node.alias = node.field_name;
      }
      return type;
    },
    getComponent: function getComponent(field) {
      if (field.relation) return;else if (field.query) return field.input.type;else return 'g3w-input';
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"tab-node group"},[(_vm.showGroupTile)?_c('h5',{staticClass:"title group-title"},[_vm._v(_vm._s(_vm.node.name))]):_vm._e(),_vm._v(" "),_vm._l((_vm.rows),function(row){return _c('div',{staticClass:"row"},_vm._l((_vm.columnNumber),function(column){return _c('div',{class:_vm.columnClass},[(_vm.getNode(row, column))?[(_vm.getNodeType(_vm.getNode(row, column)) === 'field')?_c(_vm.getComponent(_vm.getField(_vm.getNode(row, column))),{tag:"component",attrs:{"state":_vm.getField(_vm.getNode(row, column)),"changeInput":_vm.changeInput,"addToValidate":_vm.addToValidate},on:{"changeinput":_vm.changeInput,"addinput":_vm.addToValidate}}):[(_vm.getNodeType(_vm.getNode(row, column)) === 'group')?_c('div',{staticClass:"sub-group"},[_c('node',{attrs:{"contenttype":_vm.contenttype,"fields":_vm.fields,"showTitle":true,"changeInput":_vm.changeInput,"addToValidate":_vm.addToValidate,"node":_vm.getNode(row, column)},on:{"changeinput":_vm.changeInput,"addinput":_vm.addToValidate}})],1):[(_vm.context === 'query')?_c('div',{staticStyle:{"cursor":"pointer"},on:{"click":function($event){_vm.showRelation(_vm.getNode(row, column).name)}}},[_c('div',{staticClass:"query_relation_field"},[_c('i',{class:_vm.g3wtemplate.font['relation']})]),_vm._v(" "),_c('span',[_c('span',{staticClass:"query_relation_field_message"},[_c('span',{directives:[{name:"t",rawName:"v-t",value:('mapcontrols.query.input_relation'),expression:"'mapcontrols.query.input_relation'"}]}),_c('span',{staticStyle:{"text-transform":"uppercase"}},[_vm._v(" "+_vm._s(_vm.getRelationName(_vm.getNode(row, column).name)))])])])]):[_c('div',{directives:[{name:"t",rawName:"v-t",value:('sdk.form.messages.qgis_input_widget_relation'),expression:"'sdk.form.messages.qgis_input_widget_relation'"}],staticClass:"form_editing_relation_input"},[_c('span',{staticClass:"info_helptext_button"},[_vm._v("i")])])]]]]:_vm._e()],2)}),0)})],2)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-574578ba"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-574578ba", __vue__options__)
  } else {
    hotAPI.reload("data-v-574578ba", __vue__options__)
  }
})()}

},{"../inputs/g3w-input.vue":723,"babel-runtime/helpers/extends":22,"core/project/projectsregistry":624,"core/relations/relationsservice":627,"gui/fields/fields":693,"gui/gui":710,"gui/relations/vue/relationspage":784,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],800:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".formquerytabs[data-v-415e3f94] {\n  overflow: hidden !important;\n  display: flex;\n  flex-wrap: wrap;\n}\n.formquerytabs > li[data-v-415e3f94] {\n  flex: 1;\n  display: flex;\n}\n.formquerytabs > li > a[data-v-415e3f94] {\n  font-size: 1.2em;\n  font-weight: bold;\n  flex: 1;\n}\n.tab-content[data-v-415e3f94] {\n  margin-top: 10px;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _getIterator2 = require("babel-runtime/core-js/get-iterator");

var _getIterator3 = _interopRequireDefault(_getIterator2);

var _node = require("./node.vue");

var _node2 = _interopRequireDefault(_node);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getUniqueDomId = require('core/utils/utils').getUniqueDomId;
exports.default = {
  name: "tabs",
  props: {
    contenttype: {
      default: 'query'
    },
    tabs: {
      required: true
    },
    fields: {
      required: true
    },
    addToValidate: Function,
    changeInput: Function
  },
  data: function data() {
    return {
      ids: []
    };
  },

  methods: {
    getField: function getField(fieldName) {
      var tabfields = this.fields.find(function (field) {
        return field.name === fieldName;
      });
      return tabfields;
    }
  },
  components: {
    Node: _node2.default
  },
  created: function created() {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = (0, _getIterator3.default)(this.tabs), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var tab = _step.value;

        this.ids.push("tab_" + getUniqueDomId());
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[_c('ul',{staticClass:"formquerytabs nav nav-tabs"},_vm._l((_vm.tabs),function(tab,index){return _c('li',{class:{active: index === 0}},[_c('a',{attrs:{"data-toggle":"tab","href":'#'+ _vm.ids[index]}},[_vm._v(_vm._s(tab.name))])])}),0),_vm._v(" "),_c('div',{staticClass:"tab-content"},_vm._l((_vm.tabs),function(tab,index){return _c('div',{key:_vm.ids[index],staticClass:"tab-pane fade",class:{'in active': index === 0},attrs:{"id":_vm.ids[index]}},[_c('node',{attrs:{"contenttype":_vm.contenttype,"addToValidate":_vm.addToValidate,"changeInput":_vm.changeInput,"fields":_vm.fields,"showTitle":false,"node":tab}})],1)}),0)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-415e3f94"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-415e3f94", __vue__options__)
  } else {
    hotAPI.reload("data-v-415e3f94", __vue__options__)
  }
})()}

},{"./node.vue":799,"babel-runtime/core-js/get-iterator":4,"core/utils/utils":630,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],801:[function(require,module,exports){
var WPSPPanel = require('gui/wps/vue/panel/wpspanel');

module.exports = function () {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var panel = new WPSPPanel(options);
  panel.show();
  return panel;
};

},{"gui/wps/vue/panel/wpspanel":819}],802:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var ProjectRegistry = require('core/project/projectsregistry');
var G3WObject = require('core/g3wobject');

function Service() {
  var _this2 = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this.config = null;
  this.state = (0, _extends3.default)({}, options, {
    toolsGroups: [],
    visible: false,
    loading: false
  });
  this.setters = {
    addTool: function addTool(tool, groupName) {
      tool.state = tool.state ? tool.state : {
        type: null,
        message: null
      };
      return this._addTool(tool, groupName);
    },
    addTools: function addTools(tools, groupName) {
      return this._addTools(tools, groupName);
    },
    addToolGroup: function addToolGroup(order, name) {
      return this._addToolGroup(order, name);
    },
    removeToolGroup: function removeToolGroup(name) {
      return this._removeToolGroup(name);
    },
    removeTools: function removeTools() {
      return this._removeTools();
    }
  };

  this.reload = function () {
    this.removeTools();
  };

  this._addTool = function (tool, _ref) {
    var order = _ref.position,
        name = _ref.title;

    var group = this._addToolGroup(order, name);
    if (tool.action === undefined && tool.type) tool.action = Service.ACTIONS[tool.type].bind(null, tool.options);
    group.tools.push(tool);
  };

  this._addTools = function (tools, groupName) {
    var _this = this;

    tools.forEach(function (tool) {
      _this.addTool(tool, groupName);
    });
  };

  this.setLoading = function () {
    var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.state.loading = bool;
  };

  this._removeTool = function (toolIdx) {
    this.state.toolsGroups = this.state.toolsGroups.splice(toolIdx, 1);
  };

  this._removeTools = function () {
    this.state.toolsGroups.splice(0);
  };

  this.updateToolsGroup = function (order, groupConfig) {
    Vue.set(this.state.toolsGroups, order, groupConfig);
  };

  this.getState = function () {
    return this.state;
  };

  this._removeToolGroup = function (name) {
    this.state.toolsGroups = this.state.toolsGroups.filter(function (group) {
      return group.name !== name;
    });
  };

  this._addToolGroup = function (order, name) {
    var group = this.state.toolsGroups.find(function (_group) {
      return _group.name === name;
    });
    if (!group) {
      group = {
        name: name,
        tools: []
      };
      this.state.toolsGroups.splice(order, 0, group);
    }
    return group;
  };

  this.setToolState = function () {
    var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref2.id,
        _ref2$state = _ref2.state,
        state = _ref2$state === undefined ? { type: null, message: null } : _ref2$state;

    this.state.toolsGroups.find(function (toolGroup) {
      var tool = toolGroup.tools.find(function (tool) {
        return tool.name === id;
      });
      if (tool) {
        tool.state.type = state.type;
        tool.state.message = state.message;
        return true;
      }
    });
  };

  base(this);

  var project = ProjectRegistry.getCurrentProject();

  var _project$getState = project.getState(),
      _project$getState$too = _project$getState.tools,
      tools = _project$getState$too === undefined ? {} : _project$getState$too;

  var _loop = function _loop(toolName) {
    var groupName = toolName.toUpperCase();
    _this2.addToolGroup(0, groupName);
    var _tools = tools[toolName].map(function (tool) {
      return {
        name: tool.name,
        action: ToolsService.ACTIONS[toolName].bind(null, tool)
      };
    });
    _this2.addTools(_tools, { position: 0, title: groupName });
  };

  for (var toolName in tools) {
    _loop(toolName);
  }
}

inherit(Service, G3WObject);

Service.ACTIONS = {
  wps: require('./actions/wps')
};

module.exports = Service;

},{"./actions/wps":801,"babel-runtime/helpers/extends":22,"core/g3wobject":569,"core/project/projectsregistry":624,"core/utils/utils":630}],803:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".tool_disabled[data-v-492cec04] {\n  cursor: not-allowed;\n}\n\n.tool_disabled > span[data-v-492cec04] {\n  color: #777;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var GUI = require('gui/gui');
var TOOLSTATE = {
  alert: {
    color: 'red'
  },
  info: {
    color: 'blue'
  },
  warning: {
    color: 'orange'
  }
};
exports.default = {
  name: "g3w-tool",
  props: {
    tool: {
      required: true
    }
  },
  data: function data() {
    return {};
  },

  methods: {
    fireAction: function fireAction(tool) {
      this.tool.action(tool);
    },
    showToolStateMessage: function showToolStateMessage() {
      GUI.showModalDialog({
        title: this.tool.state.type.toUpperCase(),
        message: this.tool.state.message
      });
    }
  },
  computed: {
    disabled: function disabled() {
      return this.tool.loading || this.tool.disabled;
    },
    icon: function icon() {
      return this.tool.icon || 'caret-right';
    },
    toolstatecolor: function toolstatecolor() {
      return TOOLSTATE[this.tool.state.type].color;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',[(_vm.tool.type === 'checkbox' )?_c('div',{staticClass:"checkbox"},[_c('label',[_c('input',{directives:[{name:"model",rawName:"v-model",value:(_vm.tool.isCheck),expression:"tool.isCheck"}],staticStyle:{"cursor":"pointer"},attrs:{"id":_vm.tool.layerName,"type":"checkbox"},domProps:{"value":_vm.tool.layerName,"checked":Array.isArray(_vm.tool.isCheck)?_vm._i(_vm.tool.isCheck,_vm.tool.layerName)>-1:(_vm.tool.isCheck)},on:{"click":function($event){return _vm.fireAction(_vm.tool)},"change":function($event){var $$a=_vm.tool.isCheck,$$el=$event.target,$$c=$$el.checked?(true):(false);if(Array.isArray($$a)){var $$v=_vm.tool.layerName,$$i=_vm._i($$a,$$v);if($$el.checked){$$i<0&&(_vm.$set(_vm.tool, "isCheck", $$a.concat([$$v])))}else{$$i>-1&&(_vm.$set(_vm.tool, "isCheck", $$a.slice(0,$$i).concat($$a.slice($$i+1))))}}else{_vm.$set(_vm.tool, "isCheck", $$c)}}}}),_vm._v("\n      "+_vm._s(_vm.tool.name)+"\n    ")])]):_c('div',{staticClass:"tool",class:{tool_disabled: _vm.disabled},staticStyle:{"position":"relative"},on:{"click":function($event){!_vm.disabled ? _vm.fireAction(_vm.tool) : null}}},[_c('bar-loader',{attrs:{"loading":_vm.tool.loading}}),_vm._v(" "),_c('i',{class:_vm.g3wtemplate.getFontClass(_vm.icon)}),_vm._v(" "),(_vm.tool.html)?_c('span',[_c('i',{class:_vm.tool.html.icon}),_vm._v("\n      "+_vm._s(_vm.tool.html.text || _vm.tool.name)+"\n    ")]):_c('span',[_vm._v(_vm._s(_vm.tool.name))]),_vm._v(" "),(_vm.tool.state.type)?_c('span',{staticStyle:{"cursor":"pointer","vertical-align":"center","position":"absolute","right":"0","top":"0","padding":"5px"},style:({color: _vm.toolstatecolor}),on:{"click":function($event){$event.stopPropagation();return _vm.showToolStateMessage($event)}}},[_c('i',{class:_vm.g3wtemplate.getFontClass(_vm.tool.state.type)})]):_vm._e()],1)])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-492cec04"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-492cec04", __vue__options__)
  } else {
    hotAPI.reload("data-v-492cec04", __vue__options__)
  }
})()}

},{"gui/gui":710,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],804:[function(require,module,exports){
module.exports = "<ul class=\"g3w-tools treeview-menu\">\n  <bar-loader :loading=\"state.loading\"></bar-loader>\n  <li v-for=\"group in state.toolsGroups\" :key=\"group.name\">\n    <div class=\"tool-header\">\n      <i :class=\"g3wtemplate.getFontClass('tool')\"></i>\n      <span style=\"\">{{ group.name }}</span>\n    </div>\n    <div :id=\"group.name + '-tools'\" class=\"tool-box\">\n      <g3w-tool v-for=\"tool in group.tools\" :key=\"tool.name\" :tool=\"tool\"></g3w-tool>\n    </div>\n  </li>\n</ul>\n";

},{}],805:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

var _tool = require('./tool.vue');

var _tool2 = _interopRequireDefault(_tool);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var GUI = require('gui/gui');
var Component = require('gui/vue/component');
var ToolsService = require('gui/tools/service');
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./tools.html'));
var InternalComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  data: function data() {
    return {
      state: null
    };
  },
  watch: {
    'state.toolsGroups': {
      handler: function handler(groups) {
        this.$emit('visible', groups.length > 0);
      }
    }
  },
  components: {
    G3wTool: _tool2.default
  }
}));

function ToolsComponent() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  base(this, options);
  this._service = new ToolsService(options);
  this.title = "tools";

  var internalComponent = new InternalComponent({
    toolsService: this._service
  });

  internalComponent.state = this._service.state;
  this.setInternalComponent(internalComponent, {
    events: [{ name: 'visible' }]
  });

  this._setOpen = function () {
    var bool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    this.internalComponent.state.open = bool;
    bool && GUI.closeContent();
  };
}

inherit(ToolsComponent, Component);

module.exports = ToolsComponent;

},{"./tool.vue":803,"./tools.html":804,"babel-runtime/helpers/extends":22,"core/utils/utils":630,"gui/gui":710,"gui/tools/service":802,"gui/vue/component":806,"gui/vue/utils":812}],806:[function(require,module,exports){
var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var resolve = require('core/utils/utils').resolve;
var BaseComponent = require('gui/component');

// class component
var Component = function Component() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._firstLayout = true;
  base(this, options);
};

inherit(Component, BaseComponent);

var proto = Component.prototype;

proto.mount = function (parent, append) {
  var _this = this;

  var d = $.Deferred();
  if (!this.internalComponent) {
    this.setInternalComponent();
  }
  if (append) {
    var iCinstance = this.internalComponent.$mount();
    $(parent).append(iCinstance.$el);
  } else {
    this.internalComponent.$mount(parent);
  }
  this.internalComponent.$nextTick(function () {
    $(parent).localize();
    _this.emit('ready');
    d.resolve(true);
  });
  // emit mount event
  this.emit('mount');
  return d.promise();
};

proto.unmount = function () {
  if (!this.internalComponent) {
    return resolve();
  }
  if (this.state.resizable) {
    this.internalComponent.$off('resize-component', this.internalComponent.layout);
  }
  // destroy vue component
  this.internalComponent.$destroy(true);
  // remove dom element
  $(this.internalComponent.$el).remove();
  // set internal componet to null (for GC)
  this.internalComponent = null;
  // emit unmount event
  this.emit('unmount');
  return resolve();
};

proto.ismount = function () {
  return this.internalComponent && this.internalComponent.$el;
};

proto.layout = function (width, height) {
  var _this2 = this;

  if (this.state.resizable && this._firstLayout) {
    this.internalComponent.$on('resize-component', this.internalComponent.layout);
    this._firstLayout = false;
  }
  this.internalComponent.$nextTick(function () {
    _this2.internalComponent.$emit('resize-component', {
      width: width,
      height: height
    });
  });
  // emit layout event
  this.emit('layout');
};

module.exports = Component;

},{"core/utils/utils":630,"gui/component":689}],807:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "bar-loader",
  props: ['loading'],
  render: function render(createElement) {
    if (this.loading) {
      return createElement('div', {
        class: {
          "bar-loader": true
        }
      });
    }
  }
};

},{}],808:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".modal-content[data-v-09d10241] {\n  background: rgba(255, 255, 255, 0.6);\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n.modal-dialog[data-v-09d10241] {\n  display: inline-block;\n  text-align: left;\n  vertical-align: middle;\n}\n.modal[data-v-09d10241] {\n  text-align: center;\n  padding: 0!important;\n}\n\n.modal[data-v-09d10241]:before {\n  content: '';\n  display: inline-block;\n  height: 100%;\n  vertical-align: middle;\n  margin-right: -4px;\n}\n\n.carousel .carousel-control span[data-v-09d10241] {\n  color: #3c8dbc\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var ProjectsRegistry = require('core/project/projectsregistry');
exports.default = {
  name: "g3w-images-gallery",
  props: {
    images: {
      type: Array,
      default: []
    },
    id: {
      type: String,
      default: 'gallery'
    },
    active: {
      type: Number
    }
  },
  data: function data() {
    return {
      carouselId: 'carousel_' + Date.now()
    };
  },

  methods: {
    isActive: function isActive(src) {
      return src === active;
    },

    isRelativePath: function isRelativePath(url) {
      if (!_.startsWith(url, '/') && !_.startsWith(url, 'http')) {
        return ProjectsRegistry.getConfig().mediaurl + url;
      }
      return url;
    }
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"modal fade modal-fullscreen force-fullscreen",attrs:{"id":_vm.id,"tabindex":"-1","role":"dialog","aria-labelledby":"","aria-hidden":"true"}},[_c('div',{staticClass:"modal-dialog"},[_c('div',{staticClass:"modal-content"},[_c('div',{staticClass:"modal-body"},[_c('div',{staticClass:"carousel slide",attrs:{"id":_vm.carouselId,"data-interval":"false"}},[_c('div',{staticClass:"carousel-inner"},_vm._l((_vm.images),function(image,index){return _c('div',{staticClass:"item",class:_vm.active == index ? 'active' : ''},[_c('img',{staticStyle:{"margin":"auto"},attrs:{"src":_vm.isRelativePath(image.src)}})])}),0),_vm._v(" "),(_vm.images.length> 1)?_c('a',{staticClass:"left carousel-control",attrs:{"href":'#'+_vm.carouselId,"role":"button","data-slide":"prev"}},[_c('span',{class:_vm.g3wtemplate.getFontClass('arrow-left')})]):_vm._e(),_vm._v(" "),(_vm.images.length> 1)?_c('a',{staticClass:"right carousel-control",attrs:{"href":'#'+_vm.carouselId,"role":"button","data-slide":"next"}},[_c('span',{class:_vm.g3wtemplate.getFontClass('arrow-left')})]):_vm._e()])])])])])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-09d10241"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-09d10241", __vue__options__)
  } else {
    hotAPI.reload("data-v-09d10241", __vue__options__)
  }
})()}

},{"core/project/projectsregistry":624,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],809:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".show-hide-geo[data-v-58804640] {\n  color: #3C8DBC;\n  cursor: pointer;\n  font-size: 1.2em;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});


var geoMixin = require('gui/vue/vue.mixins').geoMixin;
exports.default = {
  name: "g3w-geospatial",
  props: {
    data: {}
  },
  mixins: [geoMixin],
  data: function data() {
    return {
      layerId: 'table_layer_' + Date.now(),
      visible: false,
      id: 'geo_table_' + Date.now()
    };
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"geo-content"},[_c('span',{staticClass:"show-hide-geo",class:[_vm.visible ? _vm.g3wtemplate.getFontClass('eye-close') : _vm.g3wtemplate.getFontClass('eye')],on:{"click":function($event){$event.stopPropagation();return _vm.showLayer()}}})])}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-58804640"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-58804640", __vue__options__)
  } else {
    hotAPI.reload("data-v-58804640", __vue__options__)
  }
})()}

},{"gui/vue/vue.mixins":815,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],810:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".img-responsive[data-v-1cb7718a] {\n  cursor: pointer;\n}\n.g3w-image[data-v-1cb7718a]{\n  padding-left: 0 !important;\n  min-width: 100px;\n  max-width: 100%;\n  cursor:pointer;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _gallery = require('./gallery.vue');

var _gallery2 = _interopRequireDefault(_gallery);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = {
  name: "g3w-image",
  props: {
    value: {}
  },
  data: function data() {
    return {
      galleryId: 'gallery_' + Date.now(),
      active: null
    };
  },

  components: {
    'g3w-images-gallery': _gallery2.default
  },
  computed: {
    values: function values() {
      return Array.isArray(this.value) ? this.value : [this.value];
    }
  },
  methods: {
    getSrc: function getSrc(value) {
      if ((typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object') {
        return value.photo;
      }
      return value;
    },
    showGallery: function showGallery(index) {
      this.active = index;
      if ((0, _typeof3.default)(this.value) === 'object') {
        this.value.active = true;
      }
      $('#' + this.galleryId).modal('show');
    },
    getGalleryImages: function getGalleryImages() {
      var _this = this;

      var images = [];
      this.values.forEach(function (image) {
        images.push({
          src: _this.getSrc(image)
        });
      });
      return images;
    }
  },
  created: function created() {}
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"container-fluid"},[_c('div',{staticClass:"row"},_vm._l((_vm.values),function(value,index){return _c('div',{staticClass:"g3w-image col-md-6 col-sm-12"},[_c('img',{staticClass:"img-thumbnail",attrs:{"src":_vm.getSrc(value)},on:{"click":function($event){return _vm.showGallery(index)}}})])}),0),_vm._v(" "),_c('g3w-images-gallery',{attrs:{"id":_vm.galleryId,"active":_vm.active,"images":_vm.getGalleryImages()}})],1)}
__vue__options__.staticRenderFns = []
__vue__options__._scopeId = "data-v-1cb7718a"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-1cb7718a", __vue__options__)
  } else {
    hotAPI.reload("data-v-1cb7718a", __vue__options__)
  }
})()}

},{"./gallery.vue":808,"babel-runtime/helpers/typeof":25,"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],811:[function(require,module,exports){
var __vueify_style_dispose__ = require("vueify/lib/insert-css").insert(".br[data-v-0bb115ee] {\n  border-radius: 8px;\n}\n.card[data-v-0bb115ee] {\n  width: 80%;\n  padding: 10px 20px;\n  margin: 50px auto;\n}\n.item[data-v-0bb115ee] {\n  height: 15px;\n  background: #ccc;\n  margin-top: 15px;\n}\n.item-light[data-v-0bb115ee] {\n  background: #ddd;\n}\n.text80[data-v-0bb115ee] {\n  width: 80%\n}\n.chart-wrapper[data-v-0bb115ee] {\n  height: 50px;\n  display: flex;\n  align-items: baseline;\n  margin-bottom: 20px;\n}\n.chart-item[data-v-0bb115ee] {\n  height: 100%;\n  width: 15px;\n  background: #ccc;\n  margin-right: 10px;\n}\n.chart-item-80[data-v-0bb115ee] {\n  height: 80%;\n}")
;(function(){
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  name: "skeleton",
  mounted: function mounted() {
    this.$nextTick(function () {});
  }
};
})()
if (module.exports.__esModule) module.exports = module.exports.default
var __vue__options__ = (typeof module.exports === "function"? module.exports.options: module.exports)
if (__vue__options__.functional) {console.error("[vueify] functional components are not supported and should be defined in plain js files using render functions.")}
__vue__options__.render = function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
__vue__options__.staticRenderFns = [function render () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"card br"},[_c('div',{staticClass:"chart-wrapper"},[_c('div',{staticClass:"chart-item br"}),_vm._v(" "),_c('div',{staticClass:"chart-item chart-item-80 item-light br"}),_vm._v(" "),_c('div',{staticClass:"chart-item br"}),_vm._v(" "),_c('div',{staticClass:"chart-item br chart-item-80"})]),_vm._v(" "),_c('div',{staticClass:"item br text80"}),_vm._v(" "),_c('div',{staticClass:"item item-light br"}),_vm._v(" "),_c('div',{staticClass:"item br"}),_vm._v(" "),_c('div',{staticClass:"item item-light br text80"})])}]
__vue__options__._scopeId = "data-v-0bb115ee"
if (module.hot) {(function () {  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), true)
  if (!hotAPI.compatible) return
  module.hot.accept()
  module.hot.dispose(__vueify_style_dispose__)
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-0bb115ee", __vue__options__)
  } else {
    hotAPI.reload("data-v-0bb115ee", __vue__options__)
  }
})()}

},{"vue":515,"vue-hot-reload-api":513,"vueify/lib/insert-css":517}],812:[function(require,module,exports){
Object.defineProperty(exports, "__esModule", {
  value: true
});
var createCompiledTemplate = exports.createCompiledTemplate = function createCompiledTemplate(template) {
  var compiledTemplate = Vue.compile(template);
  return compiledTemplate;
};

},{}],813:[function(require,module,exports){
var t = require('core/i18n/i18n.service').t;
var tTemplate = require('core/i18n/i18n.service').tTemplate;
var tPlugin = require('core/i18n/i18n.service').tPlugin;
var GlobalDirective = {
  install: function install(Vue) {
    var prePositioni18n = function prePositioni18n(_ref) {
      var el = _ref.el,
          binding = _ref.binding,
          _ref$i18nFnc = _ref.i18nFnc,
          i18nFnc = _ref$i18nFnc === undefined ? t : _ref$i18nFnc;

      var position = binding.arg ? binding.arg : 'post';
      if (position === 'pre') el.innerHTML = i18nFnc(binding.value) + el.innerHTML;else if (position === 'post') el.innerHTML = el.innerHTML + i18nFnc(binding.value);
    };

    Vue.directive("disabled", function (el, binding) {
      if (binding.value) {
        el.setAttribute('disabled', 'disabled');
      } else {
        el.removeAttribute('disabled');
      }
    });

    Vue.directive("checked", function (el, binding) {
      if (binding.value) {
        el.setAttribute('checked', 'checked');
      } else {
        el.removeAttribute('checked');
      }
    });

    Vue.directive("selected-first", function (el, binding) {
      if (binding.value == 0) {
        el.setAttribute('selected', '');
      } else {
        el.removeAttribute('selected');
      }
    });

    Vue.directive("t", {
      bind: function bind(el, binding) {
        prePositioni18n({
          el: el,
          binding: binding,
          i18nFnc: t
        });
      }
    });

    Vue.directive("t-template", {
      bind: function bind(el, binding) {
        prePositioni18n({
          el: el,
          binding: binding,
          i18nFnc: tTemplate
        });
      }
    });

    Vue.directive("t-plugin", {
      bind: function bind(el, binding) {
        prePositioni18n({
          el: el,
          binding: binding,
          i18nFnc: tPlugin
        });
      }
    });
  }
};

module.exports = GlobalDirective;

},{"core/i18n/i18n.service":572}],814:[function(require,module,exports){
var _image = require('./global-components/image.vue');

var _image2 = _interopRequireDefault(_image);

var _geo = require('./global-components/geo.vue');

var _geo2 = _interopRequireDefault(_geo);

var _skeleton = require('./global-components/skeleton.vue');

var _skeleton2 = _interopRequireDefault(_skeleton);

var _barLoader = require('./global-components/bar-loader');

var _barLoader2 = _interopRequireDefault(_barLoader);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GlobalComponents = {
  install: function install(Vue) {
    Vue.component(_image2.default.name, _image2.default);
    Vue.component(_geo2.default.name, _geo2.default);
    Vue.component(_barLoader2.default.name, _barLoader2.default);
    Vue.component(_skeleton2.default.name, _skeleton2.default);
  }
};

module.exports = GlobalComponents;

},{"./global-components/bar-loader":807,"./global-components/geo.vue":809,"./global-components/image.vue":810,"./global-components/skeleton.vue":811}],815:[function(require,module,exports){
var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GUI = require('gui/gui');

var fieldsMixin = {
  methods: {
    getFieldType: function getFieldType(value) {
      value = value && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value.constructor === Object && !value.coordinates ? value.value : value;
      var Fields = {};
      Fields.SIMPLE = 'simple';
      Fields.GEO = 'geo';
      Fields.LINK = 'link';
      Fields.PHOTO = 'photo';
      Fields.PHOTOLINK = "photolink";
      Fields.IMAGE = 'image';
      Fields.POINTLINK = 'pointlink';
      Fields.ROUTE = 'route';
      var URLPattern = /^(https?:\/\/[^\s]+)/g;
      var PhotoPattern = /[^\s]+.(png|jpg|jpeg|gif)$/g;
      if (_.isNil(value)) {
        return Fields.SIMPLE;
      } else if (value && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) == 'object' && value.coordinates) {
        return Fields.GEO;
      } else if (value && Array.isArray(value)) {
        if (value.length && value[0].photo) return Fields.PHOTO;else return Fields.SIMPLE;
      } else if (value.toString().toLowerCase().match(PhotoPattern)) {
        return Fields.PHOTO;
      } else if (value.toString().match(URLPattern)) {
        return Fields.LINK;
      }
      return Fields.SIMPLE;
    },
    sanitizeFieldValue: function sanitizeFieldValue(value) {
      if (Array.isArray(value) && !value.length) return '';else return value;
    }
  }
};

var mediaMixin = {
  computed: {
    filename: function filename() {
      return this.value ? this.value.split('/').pop() : this.value;
    }
  },
  methods: {
    isMedia: function isMedia(value) {
      if (value && (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) === 'object' && value.constructor === Object) {
        return !!value.mime_type;
      }
      return false;
    },
    getMediaType: function getMediaType(mime_type) {
      var media = {
        type: null,
        options: {}
      };
      switch (mime_type) {
        case 'image/gif':
        case 'image/png':
        case 'image/jpeg':
        case 'image/bmp':
          media.type = 'image';
          break;
        case 'application/pdf':
          media.type = 'pdf';
          break;
        case 'video/mp4':
        case 'video/ogg':
        case 'video/x-ms-wmv':
        case 'video/x-msvideo':
        case 'video/quicktime':
          media.type = 'video';
          media.options.format = mime_type;
          break;
        case 'application/gzip':
        case 'application/zip':
          media.type = 'zip';
          break;
        case 'application/msword':
        case 'application/vnd.oasis.opendocument.text':
          media.type = 'text';
          break;
        case 'application/vnd.ms-office':
        case 'application/vnd.oasis.opendocument.spreadsheet':
          media.type = 'excel';
          break;
        case 'application/vnd.openxmlformats-officedocument.presentationml.presentation':
        case 'application/vnd.ms-powerpoint':
        case 'application/vnd.oasis.opendocument.presentation':
          media.type = 'ppt';
          break;
        default:
          media.type = 'unknow';
      }
      return media;
    }
  }
};

var geoMixin = {
  methods: {
    showLayer: function showLayer() {
      this.visible = !this.visible;
      this.layer.setVisible(this.visible);
    }
  },
  created: function created() {
    var data = this.data;
    var mapService = GUI.getComponent('map').getService();
    var mapProjection = mapService.getProjection().getCode();
    var style = void 0;
    switch (data.type) {
      case 'Point':
      case 'MultiPoint':
        style = [new ol.style.Style({
          image: new ol.style.Circle({
            radius: 6,
            fill: new ol.style.Fill({
              color: [255, 255, 255, 1.0]
            }),
            stroke: new ol.style.Stroke({
              color: [0, 0, 0, 1.0],
              width: 2
            })
          })
        }), new ol.style.Style({
          image: new ol.style.Circle({
            radius: 2,
            fill: new ol.style.Fill({
              color: [255, 255, 255, 1.0]
            }),
            stroke: new ol.style.Stroke({
              color: [0, 0, 0, 1.0],
              width: 2
            })
          })
        })];
        break;
      case 'Line':
      case 'MultiLineString':
      case 'Polygon':
      case 'MultiPolygon':
        style = new ol.style.Style({
          fill: new ol.style.Fill({
            color: 'rgba(255, 255, 255, 0.3)'
          }),
          stroke: new ol.style.Stroke({
            color: [0, 0, 0, 1.0],
            width: 2
          })
        });
        break;
    }
    this.layer = new ol.layer.Vector({
      source: new ol.source.Vector({
        features: new ol.format.GeoJSON().readFeatures(data, {
          featureProjection: mapProjection
        })
      }),
      visible: !!this.visible,
      style: style
    });
    mapService.getMap().addLayer(this.layer);
  },
  beforeDestroy: function beforeDestroy() {
    var mapService = GUI.getComponent('map').getService();
    mapService.getMap().removeLayer(this.layer);
  }
};

module.exports = {
  geoMixin: geoMixin,
  fieldsMixin: fieldsMixin,
  mediaMixin: mediaMixin
};

},{"babel-runtime/helpers/typeof":25,"gui/gui":710}],816:[function(require,module,exports){
var _defineProperty2 = require('babel-runtime/helpers/defineProperty');

var _defineProperty3 = _interopRequireDefault(_defineProperty2);

var _values = require('babel-runtime/core-js/object/values');

var _values2 = _interopRequireDefault(_values);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var GUI = require('gui/gui');
module.exports = function () {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$steps = _ref.steps,
      steps = _ref$steps === undefined ? {} : _ref$steps;

  return {
    data: function data() {
      return {
        steps: steps,
        currentStep: 0
      };
    },

    watch: {
      steps: {
        handler: function handler(steps) {
          var _this = this;

          (0, _values2.default)(steps).find(function (step, index) {
            if (!step.done) {
              _this.currentStep = index;
              return true;
            }
          });
        },

        deep: true
      }
    },
    render: function render(h) {
      var _this2 = this;

      return h('ul', {
        style: {
          alignSelf: 'flex-start',
          listStyle: 'none',
          padding: '10px !important'
        }
      }, (0, _values2.default)(this.steps).map(function (step, index) {
        var _class;

        var state = {
          current: !step.done && index === _this2.currentStep,
          done: step.done,
          todo: !step.done && index !== _this2.currentStep
        };
        return h('li', {
          style: {
            fontWeight: !step.done && index === _this2.currentStep && 'bold' || null,
            marginBottom: '5px',
            color: step.done && "green"
          }
        }, [h('i', {
          style: {
            marginRight: '5px'
          },
          class: (_class = {}, (0, _defineProperty3.default)(_class, GUI.getFontClass('arrow-right'), state.current), (0, _defineProperty3.default)(_class, GUI.getFontClass('empty-circle'), state.todo), (0, _defineProperty3.default)(_class, GUI.getFontClass('success'), state.done), _class)
        }), step.description]);
      }));
    }
  };
};

},{"babel-runtime/core-js/object/values":15,"babel-runtime/helpers/defineProperty":21,"gui/gui":710}],817:[function(require,module,exports){
var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var G3WObject = require('core/g3wobject');
var GUI = require('gui/gui');
var WPSProvider = require('core/layers/providers/wpsprovider');
var PickCoordinatesInteraction = require('g3w-ol3/src/interactions/pickcoordinatesinteraction');
function WPSService() {
  var _this = this;

  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  this._mapService = GUI.getComponent('map').getService();
  this._provider = new WPSProvider(options);
  this._pickcoordinatesinteraction = new PickCoordinatesInteraction();
  this._mapService.getMap().addInteraction(this._pickcoordinatesinteraction);
  this._pickCoordinatesIdentifier = options.pickCoordinatesIdentifier || ['InputX', 'InputY'];
  this.state = {
    currentindex: -1,
    result: null,
    running: false,
    loading: true,
    title: options.name,
    error: false,
    processes: []
  };
  this.getCapabilities().then(function (processes) {
    processes.forEach(function (process) {
      _this.state.processes.push(process);
    });
  }).catch(function (error) {
    _this.state.error = true;
  }).finally((0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
    var id, processform;
    return _regenerator2.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(_this.state.processes.length && !_this.state.currentProcess)) {
              _context.next = 17;
              break;
            }

            _context.prev = 1;
            id = _this.state.processes[0].identifier;
            _context.next = 5;
            return _this.describeProcess(id);

          case 5:
            processform = _context.sent;

            _this.state.currentindex = 0;
            _context.next = 12;
            break;

          case 9:
            _context.prev = 9;
            _context.t0 = _context['catch'](1);

            console.log(_context.t0);

          case 12:
            _context.prev = 12;

            _this.state.loading = false;
            return _context.finish(12);

          case 15:
            _context.next = 18;
            break;

          case 17:
            _this.state.loading = false;

          case 18:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, _this, [[1, 9, 12, 15]]);
  })));
}

inherit(WPSService, G3WObject);

var proto = WPSService.prototype;

proto.getPickCoordinatesIdentifier = function () {
  return this._pickCoordinatesIdentifier;
};

proto.setPickCoordinatesIdentifier = function () {
  var identifiers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['InputX', 'InputY'];

  this._pickCoordinatesIdentifier = identifiers;
};

proto.activePickCoordinateInteraction = function () {
  var _this2 = this;

  this._mapService.deactiveMapControls();
  this._pickcoordinatesinteraction.setActive(true);
  return new _promise2.default(function (resolve, reject) {
    _this2._pickcoordinatesinteraction.on('picked', function (evt) {
      var coordinate = evt.coordinate;

      resolve(coordinate);
    });
  });
};

proto.deactivePickCoordinateInteraction = function () {
  this._pickcoordinatesinteraction.setActive(false);
};

proto.getCapabilities = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2() {
  return _regenerator2.default.wrap(function _callee2$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          return _context2.abrupt('return', this._provider.getCapabilities());

        case 1:
        case 'end':
          return _context2.stop();
      }
    }
  }, _callee2, this);
}));

proto.describeProcess = function () {
  var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(id) {
    var index, form;
    return _regenerator2.default.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            GUI.closeUserMessage();
            this.state.loading = true;
            index = this.state.processes.findIndex(function (process) {
              return process.identifier === id;
            });
            form = this.state.processes[index].form;

            if (!form) {
              _context3.next = 8;
              break;
            }

            this.state.loading = false;
            _context3.next = 20;
            break;

          case 8:
            _context3.prev = 8;
            _context3.next = 11;
            return this._provider.describeProcess({
              id: id, format: 'form'
            });

          case 11:
            form = this.state.processes[index].form = _context3.sent;
            _context3.next = 17;
            break;

          case 14:
            _context3.prev = 14;
            _context3.t0 = _context3['catch'](8);

            this.state.error = true;

          case 17:
            _context3.prev = 17;

            this.state.loading = false;
            return _context3.finish(17);

          case 20:
            this.state.currentindex = index;
            return _context3.abrupt('return', form);

          case 22:
          case 'end':
            return _context3.stop();
        }
      }
    }, _callee3, this, [[8, 14, 17, 20]]);
  }));

  return function (_x3) {
    return _ref3.apply(this, arguments);
  };
}();

proto.run = function () {
  var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4() {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref5$inputs = _ref5.inputs,
        inputs = _ref5$inputs === undefined ? [] : _ref5$inputs,
        id = _ref5.id;

    var mapService, response, type, data, source, layer;
    return _regenerator2.default.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            this.state.loading = true;
            mapService = GUI.getComponent('map').getService();
            _context4.next = 4;
            return this._provider.execute({
              inputs: inputs,
              id: id
            });

          case 4:
            response = _context4.sent;

            if (!(response.status === 'ok')) {
              _context4.next = 20;
              break;
            }

            type = response.type, data = response.data;
            _context4.t0 = type;
            _context4.next = _context4.t0 === 'vector' ? 10 : _context4.t0 === 'string' ? 15 : 17;
            break;

          case 10:
            source = new ol.source.Vector();

            source.addFeatures(data);
            layer = new ol.layer.Vector({
              source: source,
              name: 'Pippo'
            });

            mapService.addExternalLayer(layer);
            return _context4.abrupt('break', 18);

          case 15:
            GUI.showUserMessage({
              type: 'info',
              message: data
            });
            return _context4.abrupt('break', 18);

          case 17:
            console.log(data);

          case 18:
            _context4.next = 21;
            break;

          case 20:
            GUI.showUserMessage({
              type: 'alert',
              message: response.data
            });

          case 21:

            this.state.loading = false;

          case 22:
          case 'end':
            return _context4.stop();
        }
      }
    }, _callee4, this);
  }));

  return function () {
    return _ref4.apply(this, arguments);
  };
}();

proto.clear = function () {
  GUI.closeUserMessage();
  this._pickcoordinatesinteraction.setActive(false);
  this._mapService.getMap().removeInteraction(this._pickcoordinatesinteraction);
  this._pickcoordinatesinteraction = null;
  this._pickCoordinatesIdentifier = null;
};

module.exports = WPSService;

},{"babel-runtime/core-js/promise":16,"babel-runtime/helpers/asyncToGenerator":20,"babel-runtime/regenerator":26,"core/g3wobject":569,"core/layers/providers/wpsprovider":608,"core/utils/utils":630,"g3w-ol3/src/interactions/pickcoordinatesinteraction":670,"gui/gui":710}],818:[function(require,module,exports){
module.exports = "<div class=\"g3w-panel form-group\">\n  <h4><b>{{ state.title }}</b></h4>\n  <form id=\"g3w-wps-form\" class=\"g3w-panel-form\">\n    <bar-loader :loading=\"state.loading\"></bar-loader>\n    <div class=\"form-group\" v-if=\"!state.error\" style=\"background-color: #2c3b41; padding: 5px; display: flex; flex-direction: column\">\n      <div id=\"processes\" class=\"sidebar-divider\">\n        <h4><b v-t=\"'sdk.wps.list_process'\"></b></h4>\n        <select id=\"wps_processes\" style=\"width: 100%; font-weight: bold\">\n          <option v-for=\"process in state.processes\" :value=\"process.identifier\" :key=\"process.identifier\">\n            {{ process.title }}\n          </option>\n        </select>\n        <div class=\"abstract\" style=\"padding: 3px;\">{{ currentProcessForm.abstract }}</div>\n      </div>\n      <div class=\"inputdata sidebar-divider\" style=\"padding:3px; \">\n        <h4 style=\"font-weight: bold\">Inputs</h4>\n        <template v-for=\"input in currentInputs\" :key=\"input.id\">\n          <p style=\"margin-bottom: 3px; margin-top: 3px;\">[ {{ input.id }} ]</p>\n          <label :for=\"input.id\">{{ input.label }}</label>\n          <input :type=\"input.type ==='float' ? 'number' : ''\" class=\"form-control\" :id=\"input.id\" v-model=\"input.value\" min=\"0\">\n          <div v-if=\"showPickCoordinate && input.id === pickcoordinateinputs[0]\"  style=\"margin-top: 5px; margin-bottom: 5px; text-align: center\">\n            <button @click.prevent=\"pickCoordinate\" class=\"btn skin-background-color btn-circle skin-tooltip-left\" :title=\"pickcoordinates_tooltip\" id=\"pickcoordinates\" data-placement=\"left\" data-toggle=\"tooltip\"><i :class=\"g3wtemplate.getFontClass('marker')\"></i></button>\n          </div>\n          <div v-if=\"input.type ==='file'\" @click=\"openInputFile(input.id)\" class=\"g3w_input_button skin-background-color\" style=\"width:100%; cursor: pointer; text-align: center\">\n            <i :class=\"g3wtemplate.getFontClass('file-upload')\" class=\"fa-2x\" style=\"padding: 3px;\">\n              <input style=\"display: none\" type=\"file\" :id=\"input.id\" name=\"file\"  :accept=\"input.options.mimetype\" @change=\"loadFile({input, event:$event})\">\n            </i>\n          </div>\n          <template v-else-if=\"input.type ==='bbox'\">\n            <select :id=\"input.id\"  style=\"width:100%\">\n              <option v-for=\"epsg in input.options.epsg\" :value=\"epsg\" :key=\"epsg\">{{ epsg }}</option>\n            </select>\n            <label :for=\"`bbox_${input.id}`\">BBOX [LLX LLY UPX URY]</label>\n            <div :id=\"`bbox_${input.id}`\" style=\"display: flex; width: 100%\">\n              <input class=\"form-control\" type=\"number\" v-model='input.value.llx'>\n              <input class=\"form-control\" type=\"number\" v-model='input.value.lly'>\n              <input class=\"form-control\" type=\"number\" v-model='input.value.upx'>\n              <input class=\"form-control\" type=\"number\" v-model='input.value.upy'>\n            </div>\n\n          </template>\n        </template>\n      </div >\n      <div class=\"processoutputdata\" class=\"sidebar-divider\">\n        <h4 style=\"font-weight: bold\">Complex Output(s)</h4>\n        <template v-for=\"output in currentProcessForm.outputs\" :key=\"output.id\">\n          <p style=\"margin-bottom: 3px; margin-top: 3px;\">[ {{ output.id }} ]</p>\n          <label>{{ output.label}}</label>\n          <p style=\"margin-bottom: 3px\">{{ output.sublabel }}</p>\n          <p style=\"margin-bottom: 3px\">{{ output.type }}</p>\n\n        </template>\n      </div>\n      <button class=\"run_button btn btn-block pull-right skin-background-color\" @click.stop=\"run\" :disabled=\"disabled\">Run</button>\n    </div>\n    <div v-else>\n      errore\n    </div>\n  </form>\n  <slot name=\"footer\"></slot>\n</div>\n";

},{}],819:[function(require,module,exports){
var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _utils = require('gui/vue/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inherit = require('core/utils/utils').inherit;
var base = require('core/utils/utils').base;
var Panel = require('gui/panel');
var Service = require('gui/wps/service');
var t = require('core/i18n/i18n.service').t;
var compiledTemplate = (0, _utils.createCompiledTemplate)(require('./wpspanel.html'));

var WpsPanelComponent = Vue.extend((0, _extends3.default)({}, compiledTemplate, {
  components: {},
  data: function data() {
    return {
      state: this.$options.service.state,
      selectedProcess: null,
      currentInputs: []
    };
  },

  computed: {
    disabled: function disabled() {
      return this.state.loading || this.state.running;
    },
    currentProcessForm: function currentProcessForm() {
      var currentForm = this.state.currentindex > -1 ? this.state.processes[this.state.currentindex].form : {};
      this.currentInputs = currentForm.inputs || [];
      return currentForm;
    },
    showPickCoordinate: function showPickCoordinate() {
      var inputIds = this.currentProcessForm.inputs.map(function (input) {
        return input.id;
      });
      var find = this.pickcoordinateinputs.reduce(function (accumulator, id) {
        return accumulator - !!inputIds.find(function (inputId) {
          return inputId === id;
        }) * 1;
      }, 2);
      if (find > 0) this.$options.service.deactivePickCoordinateInteraction();
      return !find;
    }
  },
  methods: {
    pickCoordinate: function pickCoordinate() {
      var _this = this;

      this.$options.service.activePickCoordinateInteraction().then(function (coordinate) {
        _this.currentProcessForm.inputs.forEach(function (input) {
          if (input.id === _this.pickcoordinateinputs[0]) input.value = coordinate[0];
          if (input.id === _this.pickcoordinateinputs[1]) input.value = coordinate[1];
        });
      });
    },
    openInputFile: function openInputFile(id) {
      document.getElementById(id).click();
    },
    loadFile: function loadFile() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          input = _ref.input,
          event = _ref.event;

      var reader = new FileReader();
      var file = event.target.files[0];
      reader.readAsText(file, "UTF-8");
      reader.onload = function (evt) {
        input.value = evt.target.result.replace('<?xml version="1.0" encoding="utf-8" ?>', '<![CDATA[');
        input.value = input.value.concat(']]>');
      };
      reader.onerror = function (evt) {
        console.log(evt);
      };
    },

    run: function run(event) {
      event.preventDefault();
      this.state.loading = true;
      this.$options.service.run({
        inputs: this.currentProcessForm.inputs,
        id: this.selectedProcess
      });
    }
  },
  watch: {
    'state.processes': function stateProcesses(processes) {
      this.selectedProcess = processes[0].identifier;
    }
  },
  created: function created() {
    this.pickcoordinates_tooltip = t('sdk.wps.tooltip');
    this.pickcoordinateinputs = this.$options.service.getPickCoordinatesIdentifier();
    this._bbox = {};
  },
  mounted: function mounted() {
    var _this2 = this;

    this.$nextTick(function () {
      _this2.select2 = $('#wps_processes').select2();
      _this2.select2.on('select2:select', function (evt) {
        var id = evt.params.data.id;
        _this2.selectedProcess = id;
        _this2.$options.service.describeProcess(id);
      });
      $('#pickcoordinates[data-toggle="tooltip"]').tooltip();
    });
  },
  updated: function updated() {
    var _this3 = this;

    this.inputSelect && this.inputSelect.select2('destroy');
    this.$nextTick(function () {
      $('#pickcoordinates[data-toggle="tooltip"]').tooltip();
      _this3.inputSelect = $('#g3w-wps-form .inputdata select').select2();
    });
  },
  beforeDestroy: function beforeDestroy() {
    this.pickcoordinateinputs = null;
    this.inputSelect && this.inputSelect.select2('destroy');
    this.select2.select2('destroy');
  }
}));

function WPSpanel() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var service = new Service(options);
  var internalPanel = new WpsPanelComponent({
    service: service
  });
  this.setInternalPanel(internalPanel);
  this.unmount = function () {
    return base(this, 'unmount').then(function () {
      service.clear();
    });
  };
}

inherit(WPSpanel, Panel);

module.exports = WPSpanel;

},{"./wpspanel.html":818,"babel-runtime/helpers/extends":22,"core/i18n/i18n.service":572,"core/utils/utils":630,"gui/panel":770,"gui/vue/utils":812,"gui/wps/service":817}],820:[function(require,module,exports){
var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var g3w = g3w || {};


g3w.core = {
  G3WObject: require('core/g3wobject'),
  utils: require('core/utils/utils'),
  geoutils: require('core/utils/geo'),
  ApplicationService: require('core/applicationservice'),
  ApiService: require('core/apiservice'),
  Router: require('core/router'),
  i18n: require('core/i18n/i18n.service'),
  errors: {
    parsers: {
      Server: require('core/errors/parser/servererrorparser')
    }
  },
  editing: {
    Session: require('core/editing/session'),
    SessionsRegistry: require('core/editing/sessionsregistry'),
    Editor: require('core/editing/editor'),
    ChangesManager: require('core/editing/changesmanager')
  },
  geometry: {
    Geom: require('core/geometry/geom'),
    Geometry: require('core/geometry/geometry')
  },
  project: {
    ProjectsRegistry: require('core/project/projectsregistry'),
    Project: require('core/project/project')
  },
  map: {
    MapLayersStoreRegistry: require('core/map/maplayersstoresregistry')
  },
  catalog: {
    CatalogLayersStoresRegistry: require('core/catalog/cataloglayersstoresregistry')
  },
  layer: {
    LayersStoreRegistry: require('core/layers/layersstoresregistry'), //nel caso un plugin volesse instanziare un layersstoreregistry proprio
    LayersStore: require('core/layers/layersstore'),
    Layer: require('core/layers/layer'),
    LayerFactory: require('core/layers/layerfactory'),
    TableLayer: require('core/layers/tablelayer'),
    VectorLayer: require('core/layers/vectorlayer'),
    ImageLayer: require('core/layers/imagelayer'),
    WmsLayer: require('core/layers/map/wmslayer'),
    XYZLayer: require('core/layers/map/xyzlayer'),
    MapLayer: require('core/layers/map/maplayer'),
    geometry: {
      Geometry: require('core/geometry/geometry'),
      geom: require('core/geometry/geom')
    },
    features: {
      Feature: require('core/layers/features/feature'),
      FeaturesStore: require('core/layers/features/featuresstore'),
      OlFeaturesStore: require('core/layers/features/olfeaturesstore')
    },
    filter: {
      Filter: require('core/layers/filter/filter'),
      Expression: require('core/layers/filter/expression')
    }
  },
  interaction: {
    PickCoordinatesInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    PickFeatureInteraction: require('g3w-ol3/src/interactions/pickfeatureinteraction')
  },
  plugin: {
    Plugin: require('core/plugin/plugin'),
    PluginsRegistry: require('core/plugin/pluginsregistry'),
    PluginService: require('core/plugin/pluginservice')
  },
  workflow: {
    Task: require('core/workflow/task'),
    Step: require('core/workflow/step'),
    Flow: require('core/workflow/flow'),
    Workflow: require('core/workflow/workflow'),
    WorkflowsStack: require('core/workflow/workflowsstack')
  }
};

g3w.gui = {
  GUI: require('gui/gui'),
  Panel: require('gui/panel'),
  ControlFactory: require('gui/map/control/factory'),
  ComponentsFactory: require('gui/componentsfactory'),
  vue: {
    Component: require('gui/vue/component'),
    Panel: require('gui/panel'),
    MetadataComponent: require('gui/metadata/vue/metadata'),
    SearchComponent: require('gui/search/vue/search'),
    SearchPanel: require('gui/search/vue/panel/searchpanel'),
    PrintComponent: require('gui/print/vue/print'),
    CatalogComponent: require('gui/catalog/vue/catalog'),
    MapComponent: require('gui/map/vue/map'),
    ToolsComponent: require('gui/tools/vue/tools'),
    QueryResultsComponent: require('gui/queryresults/vue/queryresults'),
    // main Form Component
    FormComponent: require('gui/form/vue/form'),
    // Form Components
    FormComponents: {
      Body: require('gui/form/components/body/vue/body'),
      Footer: require('gui/form/components/footer/vue/footer')
    },
    Inputs: {
      InputsComponents: require('gui/inputs/inputs')
    },
    Charts: {
      ChartsFactory: require('gui/charts/chartsfactory'),
      c3: {
        lineXY: require('gui/charts/vue/c3/line/lineXY')
      }
    },
    Fields: require('gui/fields/fields'),
    Mixins: require('gui/vue/vue.mixins'),
    services: {
      SearchPanel: require('gui/search/vue/panel/searchservice')
    }
  }
};

g3w.ol = {
  interactions: {
    PickFeatureInteraction: require('g3w-ol3/src/interactions/pickfeatureinteraction'),
    PickCoordinatesInteraction: require('g3w-ol3/src/interactions/pickcoordinatesinteraction'),
    DeleteFeatureInteraction: require('g3w-ol3/src/interactions/deletefeatureinteraction')
  },
  controls: {},
  utils: require('g3w-ol3/src/utils/utils')
};

g3w.utils = {};

g3w.config = _config2.default;

g3w.test = {};

module.exports = {
  core: g3w.core,
  gui: g3w.gui,
  ol: g3w.ol,
  utils: g3w.utils,
  config: g3w.config,
  test: g3w.test
};

},{"./config":558,"core/apiservice":559,"core/applicationservice":560,"core/catalog/cataloglayersstoresregistry":561,"core/editing/changesmanager":563,"core/editing/editor":564,"core/editing/session":566,"core/editing/sessionsregistry":567,"core/errors/parser/servererrorparser":568,"core/g3wobject":569,"core/geometry/geom":570,"core/geometry/geometry":571,"core/i18n/i18n.service":572,"core/layers/features/feature":580,"core/layers/features/featuresstore":581,"core/layers/features/olfeaturesstore":582,"core/layers/filter/expression":583,"core/layers/filter/filter":584,"core/layers/imagelayer":587,"core/layers/layer":588,"core/layers/layerfactory":589,"core/layers/layersstore":590,"core/layers/layersstoresregistry":591,"core/layers/map/maplayer":597,"core/layers/map/wmslayer":599,"core/layers/map/xyzlayer":600,"core/layers/tablelayer":610,"core/layers/vectorlayer":611,"core/map/maplayersstoresregistry":612,"core/plugin/plugin":616,"core/plugin/pluginservice":617,"core/plugin/pluginsregistry":618,"core/project/project":623,"core/project/projectsregistry":624,"core/router":628,"core/utils/geo":629,"core/utils/utils":630,"core/workflow/flow":639,"core/workflow/step":640,"core/workflow/task":641,"core/workflow/workflow":642,"core/workflow/workflowsstack":643,"g3w-ol3/src/interactions/deletefeatureinteraction":667,"g3w-ol3/src/interactions/pickcoordinatesinteraction":670,"g3w-ol3/src/interactions/pickfeatureinteraction":671,"g3w-ol3/src/utils/utils":678,"gui/catalog/vue/catalog":681,"gui/charts/chartsfactory":686,"gui/charts/vue/c3/line/lineXY":688,"gui/componentsfactory":690,"gui/fields/fields":693,"gui/form/components/body/vue/body":702,"gui/form/components/footer/vue/footer":704,"gui/form/vue/form":709,"gui/gui":710,"gui/inputs/inputs":725,"gui/map/control/factory":753,"gui/map/vue/map":759,"gui/metadata/vue/metadata":769,"gui/panel":770,"gui/print/vue/print":774,"gui/queryresults/vue/queryresults":779,"gui/search/vue/panel/searchpanel":787,"gui/search/vue/panel/searchservice":788,"gui/search/vue/search":791,"gui/tools/vue/tools":805,"gui/vue/component":806,"gui/vue/vue.mixins":815}]},{},[527])

//# sourceMappingURL=app.js.map
